!function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define([], factory) : "object" == typeof exports ? exports.VuexSearch = factory() : root.VuexSearch = factory();
}("undefined" != typeof self ? self : this, function() {
    /******/
    return function(modules) {
        // webpackBootstrap
        /******/ // The module cache
        /******/ var installedModules = {};
        /******/
        /******/ // The require function
        /******/        function __webpack_require__(moduleId) {
            /******/
            /******/ // Check if module is in cache
            /******/ if (installedModules[moduleId]) 
            /******/ return installedModules[moduleId].exports;
            /******/
            /******/ // Create a new module (and put it into the cache)
            /******/            var module = installedModules[moduleId] = {
                /******/ i: moduleId,
                /******/ l: !1,
                /******/ exports: {}
                /******/            };
            /******/
            /******/ // Execute the module function
            /******/            
            /******/
            /******/ // Return the exports of the module
            /******/ return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            /******/
            /******/ // Flag the module as loaded
            /******/ module.l = !0, module.exports;
            /******/        }
        /******/
        /******/
        /******/ // expose the modules object (__webpack_modules__)
        /******/        
        /******/
        /******/ // Load entry module and return exports
        /******/ return __webpack_require__.m = modules, 
        /******/
        /******/ // expose the module cache
        /******/ __webpack_require__.c = installedModules, 
        /******/
        /******/ // define getter function for harmony exports
        /******/ __webpack_require__.d = function(exports, name, getter) {
            /******/ __webpack_require__.o(exports, name) || 
            /******/ Object.defineProperty(exports, name, {
                /******/ configurable: !1,
                /******/ enumerable: !0,
                /******/ get: getter
                /******/            })
            /******/;
        }, 
        /******/
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ __webpack_require__.n = function(module) {
            /******/ var getter = module && module.__esModule ? 
            /******/ function() {
                return module.default;
            } : 
            /******/ function() {
                return module;
            };
            /******/            
            /******/ return __webpack_require__.d(getter, "a", getter), getter;
            /******/        }, 
        /******/
        /******/ // Object.prototype.hasOwnProperty.call
        /******/ __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        }, 
        /******/
        /******/ // __webpack_public_path__
        /******/ __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 11);
        /******/    }
    /************************************************************************/
    /******/ ([ 
    /* 0 */
    /***/ function(module, exports) {
        // shim for using process in browser
        var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.
                function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) 
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
            // if setTimeout wasn't available but was latter defined
                        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
            setTimeout(fun, 0);
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        !function() {
            try {
                cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }();
        var currentQueue, queue = [], draining = !1, queueIndex = -1;
        function cleanUpNextTick() {
            draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
            queue.length && drainQueue());
        }
        function drainQueue() {
            if (!draining) {
                var timeout = runTimeout(cleanUpNextTick);
                draining = !0;
                for (var len = queue.length; len; ) {
                    for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                    queueIndex = -1, len = queue.length;
                }
                currentQueue = null, draining = !1, function(marker) {
                    if (cachedClearTimeout === clearTimeout) 
                    //normal enviroments in sane situations
                    return clearTimeout(marker);
                    // if clearTimeout wasn't available but was latter defined
                                        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
                    clearTimeout(marker);
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }(timeout);
            }
        }
        // v8 likes predictible objects
        function Item(fun, array) {
            this.fun = fun, this.array = array;
        }
        function noop() {}
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
        }, Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
        process.version = "", // empty string to avoid regexp issues
        process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, 
        process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
        process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, 
        process.listeners = function(name) {
            return [];
        }, process.binding = function(name) {
            throw new Error("process.binding is not supported");
        }, process.cwd = function() {
            return "/";
        }, process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        }, process.umask = function() {
            return 0;
        };
    }, 
    /* 1 */
    /***/ function(module, exports) {
        var g;
        // This works in non-strict mode
                g = function() {
            return this;
        }();
        try {
            // This works if eval is allowed (see CSP)
            g = g || Function("return this")() || (0, eval)("this");
        } catch (e) {
            // This works if the window reference is available
            "object" == typeof window && (g = window);
        }
        // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}
                module.exports = g;
    }, 
    /* 2 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (immutable) */        __webpack_exports__.c = 
        /**
 * Normalize the map
 * normalizeMap([1, 2]) => [ { key: 1, val: 1 }, { key: 2, val: 2 } ]
 * normalizeMap({a: 1, b: 2}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 } ]
 * @param {Array|Object} map
 * @return {Object}
 */
        function(map) {
            return Array.isArray(map) ? map.map(key => ({
                key: key,
                val: key
            })) : Object.keys(map).map(key => ({
                key: key,
                val: map[key]
            }));
        }
        /**
 * Adds '/'
 *
 * @param {string} namespace
 */ , 
        /* harmony export (immutable) */ __webpack_exports__.d = normalizeNamespaceName, 
        /* unused harmony export modulePathToNamespace */
        /* harmony export (immutable) */ __webpack_exports__.a = 
        /**
 * Basic Promise does not support promise cancellation.
 * This function wraps the basic promise and returns cancellable one.
 *
 * @param {Promise} promise
 */
        function(promise) {
            return __WEBPACK_IMPORTED_MODULE_0_bluebird___default.a.config({
                cancellation: !0
            }), new __WEBPACK_IMPORTED_MODULE_0_bluebird___default.a(async (resolve, reject) => {
                try {
                    resolve(await promise);
                } catch (e) {
                    reject(e);
                }
            });
        }
        /**
 * Postpone its execution until after wait milliseconds
 * have elapsed since the last time it was invoked.
 *
 * @param {Function} fn Function callback after delay
 * @param {Number} delay Debounce time
 */ , 
        /* harmony export (immutable) */ __webpack_exports__.b = function(fn, delay = 0) {
            let timeoutId;
            return 0 === delay ? fn : (...args) => {
                timeoutId && clearTimeout(timeoutId), timeoutId = setTimeout(() => fn(...args), delay);
            };
        }
        /***/;
        /* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_bluebird__ = __webpack_require__(9), __WEBPACK_IMPORTED_MODULE_0_bluebird___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_bluebird__);
        /* harmony import */        function normalizeNamespaceName(namespace) {
            return "" === namespace ? "" : "/" === namespace.slice(-1) ? namespace : namespace.concat("/");
        }
        /**
 * With assumption Vuex Search module starts from root.
 *
 * @param {string | [string]} modulePath
 */    }, 
    /* 3 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var __WEBPACK_IMPORTED_MODULE_0__mutations__ = __webpack_require__(13), __WEBPACK_IMPORTED_MODULE_1__getters__ = __webpack_require__(16), __WEBPACK_IMPORTED_MODULE_2__actions__ = __webpack_require__(17), __WEBPACK_IMPORTED_MODULE_3__action_types__ = __webpack_require__(8), __WEBPACK_IMPORTED_MODULE_4__getter_types__ = __webpack_require__(5), __WEBPACK_IMPORTED_MODULE_5__mutation_types__ = __webpack_require__(4), __WEBPACK_IMPORTED_MODULE_6__utils__ = __webpack_require__(2);
        /* harmony import */        
        /* eslint-disable no-underscore-dangle */
        /**
 * Class that creates submodule in Vuex Store, and manages watched
 * states registration and unregistration, and SearchApi subscriptions.
 */
        class VuexSearch {
            /**
   * Constructor.
   *
   * @param {Store} store A vuex store instance.
   * @param {[resourceName: string]: { getter, indexes, searchApi? }} resources
   *    Options of resources and its index fields, getter, and optional searchApi.
   * @param {SearchApi} searchApi Custom SearchApi to be used and shared by resources
   *    with no custom searchApi.
   */
            constructor({store: store, resources: resources, searchApi: searchApi}) {
                this._base = VuexSearch.base, this._store = store, this._defaultSearchApi = searchApi, 
                this._searchMap = {}, this._resourceOptions = {}, this._unwatchResource = {}, this._customSearch = new Map(), 
                /* eslint-disable-next-line no-param-reassign */
                store.search = this, this._initModule(), this._initResources(resources);
            }
            /**
   * Share map from resourceName to searchApi with actions
   * and register VuexSearch submodule on Vuex Store.
   */            _initModule() {
                const actions = Object(__WEBPACK_IMPORTED_MODULE_2__actions__.a)(this._searchMap);
                this._store.registerModule(this._base, {
                    namespaced: !0,
                    root: !0,
                    mutations: __WEBPACK_IMPORTED_MODULE_0__mutations__.a,
                    actions: actions,
                    getters: __WEBPACK_IMPORTED_MODULE_1__getters__.a,
                    state: {}
                });
            }
            /**
   * Initialize all resources which are statically defined in store.
   *
   * @param {[resourceName: string]: { getter, indexes, watch?, searchApi? }} resources
   *    Options of resources and its index fields, getter, and optional watch and searchApi
   */            _initResources(resources) {
                Object.entries(resources).forEach(([resourceName, config]) => {
                    this.registerResource(resourceName, config);
                });
            }
            /**
   * - Public API -
   * Dynamically register resource for indexing.
   *
   * @param resourceName Uniquely identifies the resource (eg. "databases").
   *
   * config:
   * @param {(state: Object) => Array|Object} getter Function getter
   *    to access resource and to be watched.
   * @param {string[]} index Fields to be indexed.
   * @param {Boolean|Object} [watch] Options to reindex if resource changes
   * @param {SearchApi} [searchApi] Custom SearchApi for this resource.
   */            registerResource(resourceName, config) {
                const store = this._store, namespace = this._getNamespace(this._base);
                store.commit(`${namespace}${__WEBPACK_IMPORTED_MODULE_5__mutation_types__.b}`, {
                    resourceName: resourceName
                });
                const {getter: getter, index: index, watch: watch = !0, searchApi: searchApi = this._defaultSearchApi} = config;
                this._searchMap[resourceName] = searchApi, this._resourceOptions[resourceName] = {
                    getter: getter,
                    index: index
                }, this._searchSubscribeIfNecessary(searchApi, resourceName, ({result: result, text: text}) => {
                    this._store.dispatch(`${namespace}${__WEBPACK_IMPORTED_MODULE_3__action_types__.a}`, {
                        result: result,
                        resourceName: resourceName,
                        text: text
                    });
                }), this.reindex(resourceName);
                const initialSearchString = this._getSearchText(resourceName);
                if (this.search(resourceName, initialSearchString), watch) {
                    const watchCb = () => {
                        const searchString = this._getSearchText(resourceName);
                        this.reindex(resourceName), this.search(resourceName, searchString);
                    }, {delay: delay = 0} = watch;
                    this._unwatchResource[resourceName] = store.watch(getter, Object(__WEBPACK_IMPORTED_MODULE_6__utils__.b)(watchCb, delay), {
                        deep: !0
                    });
                }
            }
            /**
   * - Public API -
   * Search wrapper function for dispatching search action.
   *
   * @param {String} resourceName Uniquely identifies the resource (eg. "databases").
   * @param {String} searchString Text to search.
   */            search(resourceName, searchString) {
                const store = this._store, namespace = this._getNamespace(this._base);
                store.dispatch(`${namespace}${__WEBPACK_IMPORTED_MODULE_3__action_types__.b}`, {
                    resourceName: resourceName,
                    searchString: searchString
                });
            }
            /**
   * - Public API -
   * Reindex resource wrapper function for dispatching reindex action.
   *
   * This method is useful to avoid passing index fields and getter function
   * of the resource.
   *
   * @param {String} resourceName Uniquely identifies the resource (eg. "databases").
   */            reindex(resourceName) {
                const store = this._store, namespace = this._getNamespace(this._base), {getter: getter, index: index} = this._resourceOptions[resourceName];
                store.dispatch(`${namespace}${__WEBPACK_IMPORTED_MODULE_3__action_types__.c.INDEX_RESOURCE}`, {
                    fieldNamesOrIndexFunction: index,
                    resourceName: resourceName,
                    resources: getter(store.state)
                });
                const searchString = this._getSearchText(resourceName);
                this.search(resourceName, searchString);
            }
            /**
   * - Public API -
   * Unregister resource from indexing.
   * This method will unwatch state changes and unsubscribe from searchApi
   * used by the resource.
   *
   * @param resourceName Resource name to be unregistered.
   */            unregisterResource(resourceName) {
                const store = this._store, namespace = this._getNamespace(this._base);
                delete this._resourceOptions[resourceName];
                const searchApi = this._searchMap[resourceName];
                this._searchUnsubscribeIfNecessary(searchApi, resourceName), searchApi.stopSearch(resourceName), 
                delete this._searchMap[resourceName];
                const unwatch = this._unwatchResource[resourceName];
                unwatch instanceof Function && unwatch(), delete this._unwatchResource[resourceName], 
                store.commit(`${namespace}${__WEBPACK_IMPORTED_MODULE_5__mutation_types__.a}`, {
                    resourceName: resourceName
                });
            }
            /**
   * Register resourceName to be kept tracked by customSearch map and check
   * whether need to subscribe if the searchApi is not yet subscribed.
   *
   * customSearch is a map from searchApi instance to list of resources using it
   * and unsubscribe callback.
   *
   * @param {SearchApi} searchApi SearchApi instance to be subscribed.
   *    Will be checked if already been subscribed to prevent duplication.
   * @param resourceName Resource to be kept tracked by the map.
   * @param {({ result: string[], resourceName, text }) => void} fn callback to be subscribed.
   */            _searchSubscribeIfNecessary(searchApi, resourceName, fn) {
                const map = this._customSearch.get(searchApi);
                map ? map.resources.push(resourceName) : this._customSearch.set(searchApi, {
                    unsubscribe: searchApi.subscribe(fn),
                    resources: [ resourceName ]
                });
            }
            /**
   * Remove a resource from searchApi's resources list and
   * unsubscribe searchApi if no resources using it anymore.
   *
   * @param {SearchApi} searchApi SearchApi instance to be unsubscribed.
   * @param resourceName Resource to be removed from customSearch map.
   */            _searchUnsubscribeIfNecessary(searchApi, resourceName) {
                const map = this._customSearch.get(searchApi);
                1 === map.resources.length ? (map.unsubscribe(), this._customSearch.delete(searchApi)) : map.resources = map.resources.filter(name => name !== resourceName);
            }
            /**
   * Wrapper function for getting resource index search text.
   *
   * @param {String} resourceName
   * @returns {String}
   */            _getSearchText(resourceName) {
                const store = this._store, namespace = this._getNamespace(this._base);
                return store.getters[`${namespace}${__WEBPACK_IMPORTED_MODULE_4__getter_types__.c}`](resourceName).text;
            }
            /**
   * Get namespace from Vuex Store's modules' internal map of
   * module path to namespace.
   * @param {String} path
   * @returns {String}
   */            _getNamespace(...modulePath) {
                return this._store._modules.getNamespace(modulePath);
            }
        }
        /**
 * Generate map of actions to be exposed.
 */        
        /**
 * VuexSearch static property 'base'.
 */
        let base = "vuexSearch";
        Object.defineProperty(VuexSearch, "base", {
            get: () => base,
            set(newBase) {
                base = newBase;
            }
        });
        const publicApi = function() {
            const publicApi = {};
            return Object.getOwnPropertyNames(VuexSearch.prototype).filter(methodName => !methodName.startsWith("_")).forEach(methodName => {
                publicApi[methodName] = methodName;
            }), Object.freeze(publicApi), publicApi;
        }();
        /* harmony export (immutable) */        __webpack_exports__.b = publicApi, 
        /* harmony default export */ __webpack_exports__.a = VuexSearch;
    }, 
    /* 4 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (immutable) */ __webpack_exports__.d = "@vuexSearch/mutation/SET_SEARCH_RESULT";
        /* harmony export (immutable) */ __webpack_exports__.b = "@vuexSearch/mutation/SET_INIT_RESOURCE";
        /* harmony export (immutable) */ __webpack_exports__.c = "@vuexSearch/mutation/SET_SEARCH";
        /* harmony export (immutable) */ __webpack_exports__.a = "@vuexSearch/mutation/DELETE_RESOURCE";
    }, 
    /* 5 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (immutable) */ __webpack_exports__.c = "@@vuexSearch/getter/resourceIndex";
        /* harmony export (immutable) */ __webpack_exports__.b = "@@vuexSearch/getter/isSearching";
        /* harmony export (immutable) */ __webpack_exports__.d = "@@vuexSearch/getter/result";
        const api = {
            resourceIndex: "@@vuexSearch/getter/resourceIndex",
            isSearching: "@@vuexSearch/getter/isSearching",
            result: "@@vuexSearch/getter/result"
        };
        /* harmony export (immutable) */        __webpack_exports__.a = api;
    }, 
    /* 6 */
    /***/ function(module, exports) {
        module.exports = 
        /******/ function(modules) {
            // webpackBootstrap
            /******/ // The module cache
            /******/ var installedModules = {};
            /******/
            /******/ // The require function
            /******/            function __webpack_require__(moduleId) {
                /******/
                /******/ // Check if module is in cache
                /******/ if (installedModules[moduleId]) 
                /******/ return installedModules[moduleId].exports;
                /******/
                /******/ // Create a new module (and put it into the cache)
                /******/                var module = installedModules[moduleId] = {
                    /******/ exports: {},
                    /******/ id: moduleId,
                    /******/ loaded: !1
                    /******/                };
                /******/
                /******/ // Execute the module function
                /******/                
                /******/
                /******/ // Return the exports of the module
                /******/ return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
                /******/
                /******/ // Flag the module as loaded
                /******/ module.loaded = !0, module.exports;
                /******/            }
            /******/
            /******/
            /******/ // expose the modules object (__webpack_modules__)
            /******/            
            /******/
            /******/ // Load entry module and return exports
            /******/ return __webpack_require__.m = modules, 
            /******/
            /******/ // expose the module cache
            /******/ __webpack_require__.c = installedModules, 
            /******/
            /******/ // __webpack_public_path__
            /******/ __webpack_require__.p = "", __webpack_require__(0);
            /******/        }
        /************************************************************************/
        /******/ ([ 
        /* 0 */
        /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__(1);
            /***/        }, 
        /* 1 */
        /***/ function(module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.INDEX_MODES = void 0;
            var obj, _SearchApi = __webpack_require__(2), _SearchApi2 = (obj = _SearchApi) && obj.__esModule ? obj : {
                default: obj
            }, _util = __webpack_require__(3);
            exports.default = _SearchApi2.default, exports.INDEX_MODES = _util.INDEX_MODES;
        }, 
        /* 2 */
        /***/ function(module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            var obj, _util = __webpack_require__(3), _worker = __webpack_require__(7), _worker2 = (obj = _worker) && obj.__esModule ? obj : {
                default: obj
            };
            exports.default = // TODO
            function SearchApi() {
                var _this = this, _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, indexMode = _ref.indexMode, tokenizePattern = _ref.tokenizePattern, caseSensitive = _ref.caseSensitive;
                !function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }
                /**
	 * Search API that uses web workers when available.
	 * Indexing and searching is performed in the UI thread as a fallback when web workers aren't supported.
	 */ (this, SearchApi), this.indexDocument = function(uid, text) {
                    return _this._search.indexDocument(uid, text), _this;
                }, this.search = function(query) {
                    // Promise.resolve handles both synchronous and web-worker Search utilities
                    return _this._search.search(query);
                }, 
                // Based on https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers
                // But with added check for Node environment
                "undefined" != typeof window && window.Worker ? this._search = new _worker2.default({
                    indexMode: indexMode,
                    tokenizePattern: tokenizePattern,
                    caseSensitive: caseSensitive
                }) : this._search = new _util.SearchUtility({
                    indexMode: indexMode,
                    tokenizePattern: tokenizePattern,
                    caseSensitive: caseSensitive
                });
            }
            /**
	 * Adds or updates a uid in the search index and associates it with the specified text.
	 * Note that at this time uids can only be added or updated in the index, not removed.
	 *
	 * @param uid Uniquely identifies a searchable object
	 * @param text Text to associate with uid
	 */
            /**
	 * Searches the current index for the specified query text.
	 * Only uids matching all of the words within the text will be accepted.
	 * If an empty query string is provided all indexed uids will be returned.
	 *
	 * Document searches are case-insensitive (e.g. "search" will match "Search").
	 * Document searches use substring matching (e.g. "na" and "me" will both match "name").
	 *
	 * @param query Searchable query text
	 * @return Promise to be resolved with an Array of matching uids
	 */;
        }, 
        /* 3 */
        /***/ function(module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.SearchUtility = exports.INDEX_MODES = void 0;
            var obj, _SearchUtility = __webpack_require__(4), _SearchUtility2 = (obj = _SearchUtility) && obj.__esModule ? obj : {
                default: obj
            }, _constants = __webpack_require__(5);
            exports.default = _SearchUtility2.default, exports.INDEX_MODES = _constants.INDEX_MODES, 
            exports.SearchUtility = _SearchUtility2.default;
        }, 
        /* 4 */
        /***/ function(module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            var obj, _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                        "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                    Constructor;
                };
            }(), _constants = __webpack_require__(5), _SearchIndex = __webpack_require__(6), _SearchIndex2 = (obj = _SearchIndex) && obj.__esModule ? obj : {
                default: obj
            };
            /**
	 * Synchronous client-side full-text search utility.
	 * Forked from JS search (github.com/bvaughn/js-search).
	 */
            var SearchUtility = function() {
                /**
	   * Constructor.
	   *
	   * @param indexMode See #setIndexMode
	   * @param tokenizePattern See #setTokenizePattern
	   * @param caseSensitive See #setCaseSensitive
	   */
                function SearchUtility() {
                    var _this = this, _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref$indexMode = _ref.indexMode, indexMode = void 0 === _ref$indexMode ? _constants.INDEX_MODES.ALL_SUBSTRINGS : _ref$indexMode, _ref$tokenizePattern = _ref.tokenizePattern, tokenizePattern = void 0 === _ref$tokenizePattern ? /\s+/ : _ref$tokenizePattern, _ref$caseSensitive = _ref.caseSensitive, caseSensitive = void 0 !== _ref$caseSensitive && _ref$caseSensitive;
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, SearchUtility), this.indexDocument = function(uid, text) {
                        return _this._uids[uid] = !0, _this._tokenize(_this._sanitize(text)).forEach(function(fieldToken) {
                            _this._expandToken(fieldToken).forEach(function(expandedToken) {
                                _this._searchIndex.indexDocument(expandedToken, uid);
                            });
                        }), _this;
                    }, this.search = function(query) {
                        if (query) {
                            var tokens = _this._tokenize(_this._sanitize(query));
                            return _this._searchIndex.search(tokens);
                        }
                        return Object.keys(_this._uids);
                    }, this._indexMode = indexMode, this._tokenizePattern = tokenizePattern, this._caseSensitive = caseSensitive, 
                    this._searchIndex = new _SearchIndex2.default(), this._uids = {};
                }
                /**
	   * Returns a constant representing the current index mode.
	   */                return _createClass(SearchUtility, [ {
                    key: "getIndexMode",
                    value: function() {
                        return this._indexMode;
                    }
                    /**
	     * Returns a constant representing the current tokenize pattern.
	     */                }, {
                    key: "getTokenizePattern",
                    value: function() {
                        return this._tokenizePattern;
                    }
                    /**
	     * Returns a constant representing the current case-sensitive bit.
	     */                }, {
                    key: "getCaseSensitive",
                    value: function() {
                        return this._caseSensitive;
                    }
                    /**
	     * Adds or updates a uid in the search index and associates it with the specified text.
	     * Note that at this time uids can only be added or updated in the index, not removed.
	     *
	     * @param uid Uniquely identifies a searchable object
	     * @param text Text to associate with uid
	     */
                    /**
	     * Searches the current index for the specified query text.
	     * Only uids matching all of the words within the text will be accepted.
	     * If an empty query string is provided all indexed uids will be returned.
	     *
	     * Document searches are case-insensitive (e.g. "search" will match "Search").
	     * Document searches use substring matching (e.g. "na" and "me" will both match "name").
	     *
	     * @param query Searchable query text
	     * @return Array of uids
	     */                }, {
                    key: "setIndexMode",
                    /**
	     * Sets a new index mode.
	     * See util/constants/INDEX_MODES
	     */
                    value: function(indexMode) {
                        if (Object.keys(this._uids).length > 0) throw Error("indexMode cannot be changed once documents have been indexed");
                        this._indexMode = indexMode;
                    }
                    /**
	     * Sets a new tokenize pattern (regular expression)
	     */                }, {
                    key: "setTokenizePattern",
                    value: function(pattern) {
                        this._tokenizePattern = pattern;
                    }
                    /**
	     * Sets a new case-sensitive bit
	     */                }, {
                    key: "setCaseSensitive",
                    value: function(caseSensitive) {
                        this._caseSensitive = caseSensitive;
                    }
                    /**
	     * Index strategy based on 'all-substrings-index-strategy.ts' in github.com/bvaughn/js-search/
	     *
	     * @private
	     */                }, {
                    key: "_expandToken",
                    value: function(token) {
                        switch (this._indexMode) {
                          case _constants.INDEX_MODES.EXACT_WORDS:
                            return [ token ];

                          case _constants.INDEX_MODES.PREFIXES:
                            return this._expandPrefixTokens(token);

                          case _constants.INDEX_MODES.ALL_SUBSTRINGS:
                          default:
                            return this._expandAllSubstringTokens(token);
                        }
                    }
                }, {
                    key: "_expandAllSubstringTokens",
                    value: function(token) {
                        var expandedTokens = [];
                        // String.prototype.charAt() may return surrogate halves instead of whole characters.
                        // When this happens in the context of a web-worker it can cause Chrome to crash.
                        // Catching the error is a simple solution for now; in the future I may try to better support non-BMP characters.
                        // Resources:
                        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt
                        // https://mathiasbynens.be/notes/javascript-unicode
                                                try {
                            for (var i = 0, length = token.length; i < length; ++i) for (var substring = "", j = i; j < length; ++j) substring += token.charAt(j), 
                            expandedTokens.push(substring);
                        } catch (error) {
                            console.error('Unable to parse token "' + token + '" ' + error);
                        }
                        return expandedTokens;
                    }
                }, {
                    key: "_expandPrefixTokens",
                    value: function(token) {
                        var expandedTokens = [];
                        // String.prototype.charAt() may return surrogate halves instead of whole characters.
                        // When this happens in the context of a web-worker it can cause Chrome to crash.
                        // Catching the error is a simple solution for now; in the future I may try to better support non-BMP characters.
                        // Resources:
                        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt
                        // https://mathiasbynens.be/notes/javascript-unicode
                                                try {
                            for (var i = 0, length = token.length; i < length; ++i) expandedTokens.push(token.substr(0, i + 1));
                        } catch (error) {
                            console.error('Unable to parse token "' + token + '" ' + error);
                        }
                        return expandedTokens;
                    }
                    /**
	     * @private
	     */                }, {
                    key: "_sanitize",
                    value: function(string) {
                        return this._caseSensitive ? string.trim() : string.trim().toLocaleLowerCase();
                    }
                    /**
	     * @private
	     */                }, {
                    key: "_tokenize",
                    value: function(text) {
                        return text.split(this._tokenizePattern).filter(function(text) {
                            return text;
                        });
 // Remove empty tokens
                                        }
                } ]), SearchUtility;
            }();
            exports.default = SearchUtility;
        }, 
        /* 5 */
        /***/ function(module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            exports.INDEX_MODES = {
                // Indexes for all substring searches (e.g. the term "cat" is indexed as "c", "ca", "cat", "a", "at", and "t").
                // Based on 'all-substrings-index-strategy' from js-search;
                // github.com/bvaughn/js-search/blob/master/source/index-strategy/all-substrings-index-strategy.ts
                ALL_SUBSTRINGS: "ALL_SUBSTRINGS",
                // Indexes for exact word matches only.
                // Based on 'exact-word-index-strategy' from js-search;
                // github.com/bvaughn/js-search/blob/master/source/index-strategy/exact-word-index-strategy.ts
                EXACT_WORDS: "EXACT_WORDS",
                // Indexes for prefix searches (e.g. the term "cat" is indexed as "c", "ca", and "cat" allowing prefix search lookups).
                // Based on 'prefix-index-strategy' from js-search;
                // github.com/bvaughn/js-search/blob/master/source/index-strategy/prefix-index-strategy.ts
                PREFIXES: "PREFIXES"
            };
            /***/        }, 
        /* 6 */
        /***/ function(module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                        "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                    Constructor;
                };
            }();
            /**
	 * Maps search tokens to uids using a trie structure.
	 */
            var SearchIndex = function() {
                function SearchIndex() {
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, SearchIndex), this.tokenToUidMap = {};
                }
                /**
	   * Maps the specified token to a uid.
	   *
	   * @param token Searchable token (e.g. "road")
	   * @param uid Identifies a document within the searchable corpus
	   */                return _createClass(SearchIndex, [ {
                    key: "indexDocument",
                    value: function(token, uid) {
                        this.tokenToUidMap[token] || (this.tokenToUidMap[token] = {}), this.tokenToUidMap[token][uid] = uid;
                    }
                    /**
	     * Finds uids that have been mapped to the set of tokens specified.
	     * Only uids that have been mapped to all tokens will be returned.
	     *
	     * @param tokens Array of searchable tokens (e.g. ["long", "road"])
	     * @return Array of uids that have been associated with the set of search tokens
	     */                }, {
                    key: "search",
                    value: function(tokens) {
                        var _this = this, uidMap = {}, initialized = !1;
                        tokens.forEach(function(token) {
                            var currentUidMap = _this.tokenToUidMap[token] || {};
                            if (initialized) for (var _uid2 in uidMap) currentUidMap[_uid2] || delete uidMap[_uid2]; else for (var _uid in initialized = !0, 
                            currentUidMap) uidMap[_uid] = currentUidMap[_uid];
                        });
                        var uids = [];
                        for (var _uid3 in uidMap) uids.push(uidMap[_uid3]);
                        return uids;
                    }
                } ]), SearchIndex;
            }();
            exports.default = SearchIndex;
        }, 
        /* 7 */
        /***/ function(module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            var obj, _SearchWorkerLoader = __webpack_require__(8), _SearchWorkerLoader2 = (obj = _SearchWorkerLoader) && obj.__esModule ? obj : {
                default: obj
            };
            exports.default = _SearchWorkerLoader2.default;
        }, 
        /* 8 */
        /***/ function(module, exports, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            var obj, _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                        "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                    Constructor;
                };
            }(), _uuid = __webpack_require__(9), _uuid2 = (obj = _uuid) && obj.__esModule ? obj : {
                default: obj
            };
            // TODO
            /**
	 * Client side, full text search utility.
	 * This interface exposes web worker search capabilities to the UI thread.
	 */
            var SearchWorkerLoader = function() {
                /**
	   * Constructor.
	   */
                function SearchWorkerLoader() {
                    var _this = this, _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, indexMode = _ref.indexMode, tokenizePattern = _ref.tokenizePattern, caseSensitive = _ref.caseSensitive, WorkerClass = _ref.WorkerClass;
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, SearchWorkerLoader), this.indexDocument = function(uid, text) {
                        return _this._worker.postMessage({
                            method: "indexDocument",
                            text: text,
                            uid: uid
                        }), _this;
                    }, this.search = function(query) {
                        return new Promise(function(resolve, reject) {
                            var callbackId = _uuid2.default.v4(), data = {
                                callbackId: callbackId,
                                complete: !1,
                                error: null,
                                reject: reject,
                                resolve: resolve,
                                results: null
                            };
                            _this._worker.postMessage({
                                method: "search",
                                query: query,
                                callbackId: callbackId
                            }), _this._callbackQueue.push(data), _this._callbackIdMap[callbackId] = data;
                        });
                    }, 
                    // Defer worker import until construction to avoid testing error:
                    // Error: Cannot find module 'worker!./[workername]'
                    WorkerClass || (
                    // $FlowFixMe eslint-disable-next-line
                    WorkerClass = __webpack_require__(11)), this._callbackQueue = [], this._callbackIdMap = {}, 
                    this._worker = new WorkerClass(), this._worker.onerror = function(event) {
                        if (event.data) {
                            var _event$data = event.data, _callbackId = _event$data.callbackId, _error = _event$data.error;
                            _this._updateQueue({
                                callbackId: _callbackId,
                                error: _error
                            });
                        } else console.error(event);
                    }, this._worker.onmessage = function(event) {
                        var _event$data2 = event.data, callbackId = _event$data2.callbackId, results = _event$data2.results;
                        _this._updateQueue({
                            callbackId: callbackId,
                            results: results
                        });
                    }, 
                    // Override default :indexMode if a specific one has been requested
                    indexMode && this._worker.postMessage({
                        method: "setIndexMode",
                        indexMode: indexMode
                    }), 
                    // Override default :tokenizePattern if a specific one has been requested
                    tokenizePattern && this._worker.postMessage({
                        method: "setTokenizePattern",
                        tokenizePattern: tokenizePattern
                    }), 
                    // Override default :caseSensitive bit if a specific one has been requested
                    caseSensitive && this._worker.postMessage({
                        method: "setCaseSensitive",
                        caseSensitive: caseSensitive
                    });
                }
                /**
	   * Adds or updates a uid in the search index and associates it with the specified text.
	   * Note that at this time uids can only be added or updated in the index, not removed.
	   *
	   * @param uid Uniquely identifies a searchable object
	   * @param text Text to associate with uid
	   */
                /**
	   * Searches the current index for the specified query text.
	   * Only uids matching all of the words within the text will be accepted.
	   * If an empty query string is provided all indexed uids will be returned.
	   *
	   * Document searches are case-insensitive (e.g. "search" will match "Search").
	   * Document searches use substring matching (e.g. "na" and "me" will both match "name").
	   *
	   * @param query Searchable query text
	   * @return Promise to be resolved with an array of uids
	   */                return _createClass(SearchWorkerLoader, [ {
                    key: "_updateQueue",
                    /**
	     * Updates the queue and flushes any completed promises that are ready.
	     */
                    value: function(_ref2) {
                        var callbackId = _ref2.callbackId, error = _ref2.error, results = _ref2.results, target = this._callbackIdMap[callbackId];
                        for (target.complete = !0, target.error = error, target.results = results; this._callbackQueue.length; ) {
                            var data = this._callbackQueue[0];
                            if (!data.complete) break;
                            this._callbackQueue.shift(), delete this._callbackIdMap[data.callbackId], data.error ? data.reject(data.error) : 
                            // This type will always be defined in this case;
                            // This casting lets Flow know it's safe.
                            data.resolve(data.results);
                        }
                    }
                } ]), SearchWorkerLoader;
            }();
            exports.default = SearchWorkerLoader;
        }, 
        /* 9 */
        /***/ function(module, exports, __webpack_require__) {
            for (
            //     uuid.js
            //
            //     Copyright (c) 2010-2012 Robert Kieffer
            //     MIT License - http://opensource.org/licenses/mit-license.php
            // Unique ID creation requires a high quality random # generator.  We feature
            // detect to determine the best RNG source, normalizing to a function that
            // returns 128-bits of randomness, since that's what's usually required
            var _rng = __webpack_require__(10), _byteToHex = [], _hexToByte = {}, i = 0
            // Maps for number <-> hex string conversion
            ; i < 256; i++) _byteToHex[i] = (i + 256).toString(16).substr(1), _hexToByte[_byteToHex[i]] = i;
            // **`parse()` - Parse a UUID into it's component bytes**
                        // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
            function unparse(buf, offset) {
                var i = offset || 0, bth = _byteToHex;
                return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
            }
            // **`v1()` - Generate time-based UUID**
            //
            // Inspired by https://github.com/LiosK/UUID.js
            // and http://docs.python.org/library/uuid.html
            // random #'s we need to init node and clockseq
                        var _seedBytes = _rng(), _nodeId = [ 1 | _seedBytes[0], _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5] ], _clockseq = 16383 & (_seedBytes[6] << 8 | _seedBytes[7]), _lastMSecs = 0, _lastNSecs = 0;
            // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
                        // **`v4()` - Generate random UUID**
            // See https://github.com/broofa/node-uuid for API details
            function v4(options, buf, offset) {
                // Deprecated - 'format' argument, as supported in v1.2
                var i = buf && offset || 0;
                "string" == typeof options && (buf = "binary" == options ? new Array(16) : null, 
                options = null);
                var rnds = (options = options || {}).random || (options.rng || _rng)();
                // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
                                // Copy bytes to buffer, if provided
                if (rnds[6] = 15 & rnds[6] | 64, rnds[8] = 63 & rnds[8] | 128, buf) for (var ii = 0; ii < 16; ii++) buf[i + ii] = rnds[ii];
                return buf || unparse(rnds);
            }
            // Export public API
                        var uuid = v4;
            uuid.v1 = 
            // See https://github.com/broofa/node-uuid for API details
            function(options, buf, offset) {
                var i = buf && offset || 0, b = buf || [], clockseq = void 0 !== (options = options || {}).clockseq ? options.clockseq : _clockseq, msecs = void 0 !== options.msecs ? options.msecs : new Date().getTime(), nsecs = void 0 !== options.nsecs ? options.nsecs : _lastNSecs + 1, dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
                // Per 4.2.1.2 Throw error if too many uuids are requested
                if (
                // Per 4.2.1.2, Bump clockseq on clock regression
                dt < 0 && void 0 === options.clockseq && (clockseq = clockseq + 1 & 16383), 
                // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
                // time interval
                (dt < 0 || msecs > _lastMSecs) && void 0 === options.nsecs && (nsecs = 0), nsecs >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
                _lastMSecs = msecs, _lastNSecs = nsecs, _clockseq = clockseq;
                // `time_low`
                var tl = (1e4 * (268435455 & (
                // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
                msecs += 122192928e5)) + nsecs) % 4294967296;
                b[i++] = tl >>> 24 & 255, b[i++] = tl >>> 16 & 255, b[i++] = tl >>> 8 & 255, b[i++] = 255 & tl;
                // `time_mid`
                var tmh = msecs / 4294967296 * 1e4 & 268435455;
                b[i++] = tmh >>> 8 & 255, b[i++] = 255 & tmh, 
                // `time_high_and_version`
                b[i++] = tmh >>> 24 & 15 | 16, // include version
                b[i++] = tmh >>> 16 & 255, 
                // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
                b[i++] = clockseq >>> 8 | 128, 
                // `clock_seq_low`
                b[i++] = 255 & clockseq;
                for (
                // `node`
                var node = options.node || _nodeId, n = 0; n < 6; n++) b[i + n] = node[n];
                return buf || unparse(b);
            }, uuid.v4 = v4, uuid.parse = function(s, buf, offset) {
                var i = buf && offset || 0, ii = 0;
                // Zero out remaining bytes if string was short
                for (buf = buf || [], s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
                    ii < 16 && (// Don't overflow!
                    buf[i + ii++] = _hexToByte[oct]);
                }); ii < 16; ) buf[i + ii++] = 0;
                return buf;
            }, uuid.unparse = unparse, module.exports = uuid;
        }, 
        /* 10 */
        /***/ function(module, exports) {
            /* WEBPACK VAR INJECTION */ (function(global) {
                var rng, crypto = global.crypto || global.msCrypto;
                // for IE 11
                if (crypto && crypto.getRandomValues) {
                    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
                    // Moderately fast, high quality
                    var _rnds8 = new Uint8Array(16);
                    rng = function() {
                        return crypto.getRandomValues(_rnds8), _rnds8;
                    };
                }
                if (!rng) {
                    // Math.random()-based (RNG)
                    //
                    // If all else fails, use Math.random().  It's fast, but is of unspecified
                    // quality.
                    var _rnds = new Array(16);
                    rng = function() {
                        for (var r, i = 0; i < 16; i++) 0 == (3 & i) && (r = 4294967296 * Math.random()), 
                        _rnds[i] = r >>> ((3 & i) << 3) & 255;
                        return _rnds;
                    };
                }
                module.exports = rng;
            }).call(exports, function() {
                return this;
            }())
            /***/;
        }, 
        /* 11 */
        /***/ function(module, exports, __webpack_require__) {
            module.exports = function() {
                return __webpack_require__(12)('/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t"use strict";\n\t\n\tvar _util = __webpack_require__(1);\n\t\n\t/**\n\t * Search entry point to web worker.\n\t * Builds search index and performs searches on separate thread from the ui.\n\t */\n\t\n\tvar searchUtility = new _util.SearchUtility();\n\t\n\tself.addEventListener("message", function (event) {\n\t  var data = event.data;\n\t  var method = data.method;\n\t\n\t\n\t  switch (method) {\n\t    case "indexDocument":\n\t      var uid = data.uid,\n\t          text = data.text;\n\t\n\t\n\t      searchUtility.indexDocument(uid, text);\n\t      break;\n\t    case "search":\n\t      var callbackId = data.callbackId,\n\t          query = data.query;\n\t\n\t\n\t      var results = searchUtility.search(query);\n\t\n\t      self.postMessage({ callbackId: callbackId, results: results });\n\t      break;\n\t    case "setIndexMode":\n\t      var indexMode = data.indexMode;\n\t\n\t\n\t      searchUtility.setIndexMode(indexMode);\n\t      break;\n\t    case "setTokenizePattern":\n\t      var tokenizePattern = data.tokenizePattern;\n\t\n\t\n\t      searchUtility.setTokenizePattern(tokenizePattern);\n\t      break;\n\t    case "setCaseSensitive":\n\t      var caseSensitive = data.caseSensitive;\n\t\n\t\n\t      searchUtility.setCaseSensitive(caseSensitive);\n\t      break;\n\t  }\n\t}, false);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t"use strict";\n\t\n\tObject.defineProperty(exports, "__esModule", {\n\t  value: true\n\t});\n\texports.SearchUtility = exports.INDEX_MODES = undefined;\n\t\n\tvar _SearchUtility = __webpack_require__(2);\n\t\n\tvar _SearchUtility2 = _interopRequireDefault(_SearchUtility);\n\t\n\tvar _constants = __webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _SearchUtility2.default;\n\texports.INDEX_MODES = _constants.INDEX_MODES;\n\texports.SearchUtility = _SearchUtility2.default;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t"use strict";\n\t\n\tObject.defineProperty(exports, "__esModule", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _constants = __webpack_require__(3);\n\t\n\tvar _SearchIndex = __webpack_require__(4);\n\t\n\tvar _SearchIndex2 = _interopRequireDefault(_SearchIndex);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\t\n\t/**\n\t * Synchronous client-side full-text search utility.\n\t * Forked from JS search (github.com/bvaughn/js-search).\n\t */\n\tvar SearchUtility = function () {\n\t\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param indexMode See #setIndexMode\n\t   * @param tokenizePattern See #setTokenizePattern\n\t   * @param caseSensitive See #setCaseSensitive\n\t   */\n\t  function SearchUtility() {\n\t    var _this = this;\n\t\n\t    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n\t        _ref$indexMode = _ref.indexMode,\n\t        indexMode = _ref$indexMode === undefined ? _constants.INDEX_MODES.ALL_SUBSTRINGS : _ref$indexMode,\n\t        _ref$tokenizePattern = _ref.tokenizePattern,\n\t        tokenizePattern = _ref$tokenizePattern === undefined ? /\\s+/ : _ref$tokenizePattern,\n\t        _ref$caseSensitive = _ref.caseSensitive,\n\t        caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive;\n\t\n\t    _classCallCheck(this, SearchUtility);\n\t\n\t    this.indexDocument = function (uid, text) {\n\t      _this._uids[uid] = true;\n\t\n\t      var fieldTokens = _this._tokenize(_this._sanitize(text));\n\t\n\t      fieldTokens.forEach(function (fieldToken) {\n\t        var expandedTokens = _this._expandToken(fieldToken);\n\t\n\t        expandedTokens.forEach(function (expandedToken) {\n\t          _this._searchIndex.indexDocument(expandedToken, uid);\n\t        });\n\t      });\n\t\n\t      return _this;\n\t    };\n\t\n\t    this.search = function (query) {\n\t      if (!query) {\n\t        return Object.keys(_this._uids);\n\t      } else {\n\t        var tokens = _this._tokenize(_this._sanitize(query));\n\t\n\t        return _this._searchIndex.search(tokens);\n\t      }\n\t    };\n\t\n\t    this._indexMode = indexMode;\n\t    this._tokenizePattern = tokenizePattern;\n\t    this._caseSensitive = caseSensitive;\n\t\n\t    this._searchIndex = new _SearchIndex2.default();\n\t    this._uids = {};\n\t  }\n\t\n\t  /**\n\t   * Returns a constant representing the current index mode.\n\t   */\n\t\n\t\n\t  _createClass(SearchUtility, [{\n\t    key: "getIndexMode",\n\t    value: function getIndexMode() {\n\t      return this._indexMode;\n\t    }\n\t\n\t    /**\n\t     * Returns a constant representing the current tokenize pattern.\n\t     */\n\t\n\t  }, {\n\t    key: "getTokenizePattern",\n\t    value: function getTokenizePattern() {\n\t      return this._tokenizePattern;\n\t    }\n\t\n\t    /**\n\t     * Returns a constant representing the current case-sensitive bit.\n\t     */\n\t\n\t  }, {\n\t    key: "getCaseSensitive",\n\t    value: function getCaseSensitive() {\n\t      return this._caseSensitive;\n\t    }\n\t\n\t    /**\n\t     * Adds or updates a uid in the search index and associates it with the specified text.\n\t     * Note that at this time uids can only be added or updated in the index, not removed.\n\t     *\n\t     * @param uid Uniquely identifies a searchable object\n\t     * @param text Text to associate with uid\n\t     */\n\t\n\t\n\t    /**\n\t     * Searches the current index for the specified query text.\n\t     * Only uids matching all of the words within the text will be accepted.\n\t     * If an empty query string is provided all indexed uids will be returned.\n\t     *\n\t     * Document searches are case-insensitive (e.g. "search" will match "Search").\n\t     * Document searches use substring matching (e.g. "na" and "me" will both match "name").\n\t     *\n\t     * @param query Searchable query text\n\t     * @return Array of uids\n\t     */\n\t\n\t  }, {\n\t    key: "setIndexMode",\n\t\n\t\n\t    /**\n\t     * Sets a new index mode.\n\t     * See util/constants/INDEX_MODES\n\t     */\n\t    value: function setIndexMode(indexMode) {\n\t      if (Object.keys(this._uids).length > 0) {\n\t        throw Error("indexMode cannot be changed once documents have been indexed");\n\t      }\n\t\n\t      this._indexMode = indexMode;\n\t    }\n\t\n\t    /**\n\t     * Sets a new tokenize pattern (regular expression)\n\t     */\n\t\n\t  }, {\n\t    key: "setTokenizePattern",\n\t    value: function setTokenizePattern(pattern) {\n\t      this._tokenizePattern = pattern;\n\t    }\n\t\n\t    /**\n\t     * Sets a new case-sensitive bit\n\t     */\n\t\n\t  }, {\n\t    key: "setCaseSensitive",\n\t    value: function setCaseSensitive(caseSensitive) {\n\t      this._caseSensitive = caseSensitive;\n\t    }\n\t\n\t    /**\n\t     * Index strategy based on \'all-substrings-index-strategy.ts\' in github.com/bvaughn/js-search/\n\t     *\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: "_expandToken",\n\t    value: function _expandToken(token) {\n\t      switch (this._indexMode) {\n\t        case _constants.INDEX_MODES.EXACT_WORDS:\n\t          return [token];\n\t        case _constants.INDEX_MODES.PREFIXES:\n\t          return this._expandPrefixTokens(token);\n\t        case _constants.INDEX_MODES.ALL_SUBSTRINGS:\n\t        default:\n\t          return this._expandAllSubstringTokens(token);\n\t      }\n\t    }\n\t  }, {\n\t    key: "_expandAllSubstringTokens",\n\t    value: function _expandAllSubstringTokens(token) {\n\t      var expandedTokens = [];\n\t\n\t      // String.prototype.charAt() may return surrogate halves instead of whole characters.\n\t      // When this happens in the context of a web-worker it can cause Chrome to crash.\n\t      // Catching the error is a simple solution for now; in the future I may try to better support non-BMP characters.\n\t      // Resources:\n\t      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt\n\t      // https://mathiasbynens.be/notes/javascript-unicode\n\t      try {\n\t        for (var i = 0, length = token.length; i < length; ++i) {\n\t          var substring = "";\n\t\n\t          for (var j = i; j < length; ++j) {\n\t            substring += token.charAt(j);\n\t            expandedTokens.push(substring);\n\t          }\n\t        }\n\t      } catch (error) {\n\t        console.error("Unable to parse token \\"" + token + "\\" " + error);\n\t      }\n\t\n\t      return expandedTokens;\n\t    }\n\t  }, {\n\t    key: "_expandPrefixTokens",\n\t    value: function _expandPrefixTokens(token) {\n\t      var expandedTokens = [];\n\t\n\t      // String.prototype.charAt() may return surrogate halves instead of whole characters.\n\t      // When this happens in the context of a web-worker it can cause Chrome to crash.\n\t      // Catching the error is a simple solution for now; in the future I may try to better support non-BMP characters.\n\t      // Resources:\n\t      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt\n\t      // https://mathiasbynens.be/notes/javascript-unicode\n\t      try {\n\t        for (var i = 0, length = token.length; i < length; ++i) {\n\t          expandedTokens.push(token.substr(0, i + 1));\n\t        }\n\t      } catch (error) {\n\t        console.error("Unable to parse token \\"" + token + "\\" " + error);\n\t      }\n\t\n\t      return expandedTokens;\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: "_sanitize",\n\t    value: function _sanitize(string) {\n\t      return this._caseSensitive ? string.trim() : string.trim().toLocaleLowerCase();\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: "_tokenize",\n\t    value: function _tokenize(text) {\n\t      return text.split(this._tokenizePattern).filter(function (text) {\n\t        return text;\n\t      }); // Remove empty tokens\n\t    }\n\t  }]);\n\t\n\t  return SearchUtility;\n\t}();\n\t\n\texports.default = SearchUtility;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t"use strict";\n\t\n\tObject.defineProperty(exports, "__esModule", {\n\t  value: true\n\t});\n\tvar INDEX_MODES = exports.INDEX_MODES = {\n\t  // Indexes for all substring searches (e.g. the term "cat" is indexed as "c", "ca", "cat", "a", "at", and "t").\n\t  // Based on \'all-substrings-index-strategy\' from js-search;\n\t  // github.com/bvaughn/js-search/blob/master/source/index-strategy/all-substrings-index-strategy.ts\n\t  ALL_SUBSTRINGS: "ALL_SUBSTRINGS",\n\t\n\t  // Indexes for exact word matches only.\n\t  // Based on \'exact-word-index-strategy\' from js-search;\n\t  // github.com/bvaughn/js-search/blob/master/source/index-strategy/exact-word-index-strategy.ts\n\t  EXACT_WORDS: "EXACT_WORDS",\n\t\n\t  // Indexes for prefix searches (e.g. the term "cat" is indexed as "c", "ca", and "cat" allowing prefix search lookups).\n\t  // Based on \'prefix-index-strategy\' from js-search;\n\t  // github.com/bvaughn/js-search/blob/master/source/index-strategy/prefix-index-strategy.ts\n\t  PREFIXES: "PREFIXES"\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t"use strict";\n\t\n\tObject.defineProperty(exports, "__esModule", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\t\n\t/**\n\t * Maps search tokens to uids using a trie structure.\n\t */\n\tvar SearchIndex = function () {\n\t  function SearchIndex() {\n\t    _classCallCheck(this, SearchIndex);\n\t\n\t    this.tokenToUidMap = {};\n\t  }\n\t\n\t  /**\n\t   * Maps the specified token to a uid.\n\t   *\n\t   * @param token Searchable token (e.g. "road")\n\t   * @param uid Identifies a document within the searchable corpus\n\t   */\n\t\n\t\n\t  _createClass(SearchIndex, [{\n\t    key: "indexDocument",\n\t    value: function indexDocument(token, uid) {\n\t      if (!this.tokenToUidMap[token]) {\n\t        this.tokenToUidMap[token] = {};\n\t      }\n\t\n\t      this.tokenToUidMap[token][uid] = uid;\n\t    }\n\t\n\t    /**\n\t     * Finds uids that have been mapped to the set of tokens specified.\n\t     * Only uids that have been mapped to all tokens will be returned.\n\t     *\n\t     * @param tokens Array of searchable tokens (e.g. ["long", "road"])\n\t     * @return Array of uids that have been associated with the set of search tokens\n\t     */\n\t\n\t  }, {\n\t    key: "search",\n\t    value: function search(tokens) {\n\t      var _this = this;\n\t\n\t      var uidMap = {};\n\t      var initialized = false;\n\t\n\t      tokens.forEach(function (token) {\n\t        var currentUidMap = _this.tokenToUidMap[token] || {};\n\t\n\t        if (!initialized) {\n\t          initialized = true;\n\t\n\t          for (var _uid in currentUidMap) {\n\t            uidMap[_uid] = currentUidMap[_uid];\n\t          }\n\t        } else {\n\t          for (var _uid2 in uidMap) {\n\t            if (!currentUidMap[_uid2]) {\n\t              delete uidMap[_uid2];\n\t            }\n\t          }\n\t        }\n\t      });\n\t\n\t      var uids = [];\n\t      for (var _uid3 in uidMap) {\n\t        uids.push(uidMap[_uid3]);\n\t      }\n\t\n\t      return uids;\n\t    }\n\t  }]);\n\t\n\t  return SearchIndex;\n\t}();\n\t\n\texports.default = SearchIndex;\n\n/***/ }\n/******/ ]);\n//# sourceMappingURL=ad4edc03e86dc4df85ea.worker.js.map', __webpack_require__.p + "ad4edc03e86dc4df85ea.worker.js");
            };
            /***/        }, 
        /* 12 */
        /***/ function(module, exports) {
            // http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string
            var URL = window.URL || window.webkitURL;
            module.exports = function(content, url) {
                try {
                    try {
                        var blob;
                        try {
                            (blob = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder)()).append(content), 
                            blob = blob.getBlob();
                        } catch (e) {
                            // The proposed API
                            blob = new Blob([ content ]);
                        }
                        return new Worker(URL.createObjectURL(blob));
                    } catch (e) {
                        return new Worker("data:application/javascript," + encodeURIComponent(content));
                    }
                } catch (e) {
                    if (!url) throw Error("Inline worker is not supported");
                    return new Worker(url);
                }
            }
            /***/;
        }
        /******/ ]);
        //# sourceMappingURL=js-worker-search.js.map
        /***/    }, 
    /* 7 */
    /***/ function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function(global) {
            var apply = Function.prototype.apply;
            // DOM APIs, for completeness
                        function Timeout(id, clearFn) {
                this._id = id, this._clearFn = clearFn;
            }
            exports.setTimeout = function() {
                return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
            }, exports.setInterval = function() {
                return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
            }, exports.clearTimeout = exports.clearInterval = function(timeout) {
                timeout && timeout.close();
            }, Timeout.prototype.unref = Timeout.prototype.ref = function() {}, Timeout.prototype.close = function() {
                this._clearFn.call(window, this._id);
            }, 
            // Does not start the time, just sets up the members needed.
            exports.enroll = function(item, msecs) {
                clearTimeout(item._idleTimeoutId), item._idleTimeout = msecs;
            }, exports.unenroll = function(item) {
                clearTimeout(item._idleTimeoutId), item._idleTimeout = -1;
            }, exports._unrefActive = exports.active = function(item) {
                clearTimeout(item._idleTimeoutId);
                var msecs = item._idleTimeout;
                msecs >= 0 && (item._idleTimeoutId = setTimeout(function() {
                    item._onTimeout && item._onTimeout();
                }, msecs));
            }, 
            // setimmediate attaches itself to the global object
            __webpack_require__(15), 
            // On some exotic environments, it's not clear which object `setimmeidate` was
            // able to install onto.  Search each possibility in the same order as the
            // `setimmediate` library.
            exports.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== global && global.setImmediate || this && this.setImmediate, 
            exports.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== global && global.clearImmediate || this && this.clearImmediate;
        }).call(exports, __webpack_require__(1))
        /***/;
    }, 
    /* 8 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (immutable) */ __webpack_exports__.a = "@@vuexSearch/action/RECEIVE_RESULT";
        /* harmony export (immutable) */ __webpack_exports__.b = "@@vuexSearch/action/SEARCH";
        /* harmony export (immutable) */ __webpack_exports__.c = {
            INDEX_RESOURCE: "@@vuexSearch/action/API/INDEX_RESOURCE",
            DEFINE_INDEX: "@@vuexSearch/action/API/DEFINE_INDEX",
            PERFORM_SEARCH: "@@vuexSearch/action/API/PERFORM_SEARCH"
        };
    }, 
    /* 9 */
    /***/ function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function(process, global, setImmediate) {
            var e;
            e = function() {
                var define, module, exports;
                return function e(t, n, r) {
                    function s(o, u) {
                        if (!n[o]) {
                            if (!t[o]) {
                                var a = "function" == typeof _dereq_ && _dereq_;
                                if (!u && a) return a(o, !0);
                                if (i) return i(o, !0);
                                var f = new Error("Cannot find module '" + o + "'");
                                throw f.code = "MODULE_NOT_FOUND", f;
                            }
                            var l = n[o] = {
                                exports: {}
                            };
                            t[o][0].call(l.exports, function(e) {
                                var n = t[o][1][e];
                                return s(n || e);
                            }, l, l.exports, e, t, n, r);
                        }
                        return n[o].exports;
                    }
                    for (var i = "function" == typeof _dereq_ && _dereq_, o = 0; o < r.length; o++) s(r[o]);
                    return s;
                }({
                    1: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise) {
                            var SomePromiseArray = Promise._SomePromiseArray;
                            function any(promises) {
                                var ret = new SomePromiseArray(promises), promise = ret.promise();
                                return ret.setHowMany(1), ret.setUnwrap(), ret.init(), promise;
                            }
                            Promise.any = function(promises) {
                                return any(promises);
                            }, Promise.prototype.any = function() {
                                return any(this);
                            };
                        };
                    }, {} ],
                    2: [ function(_dereq_, module, exports) {
                        "use strict";
                        var firstLineError;
                        try {
                            throw new Error();
                        } catch (e) {
                            firstLineError = e;
                        }
                        var schedule = _dereq_("./schedule"), Queue = _dereq_("./queue"), util = _dereq_("./util");
                        function Async() {
                            this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new Queue(16), 
                            this._normalQueue = new Queue(16), this._haveDrainedQueues = !1, this._trampolineEnabled = !0;
                            var self = this;
                            this.drainQueues = function() {
                                self._drainQueues();
                            }, this._schedule = schedule;
                        }
                        function AsyncInvokeLater(fn, receiver, arg) {
                            this._lateQueue.push(fn, receiver, arg), this._queueTick();
                        }
                        function AsyncInvoke(fn, receiver, arg) {
                            this._normalQueue.push(fn, receiver, arg), this._queueTick();
                        }
                        function AsyncSettlePromises(promise) {
                            this._normalQueue._pushOne(promise), this._queueTick();
                        }
                        Async.prototype.setScheduler = function(fn) {
                            var prev = this._schedule;
                            return this._schedule = fn, this._customScheduler = !0, prev;
                        }, Async.prototype.hasCustomScheduler = function() {
                            return this._customScheduler;
                        }, Async.prototype.enableTrampoline = function() {
                            this._trampolineEnabled = !0;
                        }, Async.prototype.disableTrampolineIfNecessary = function() {
                            util.hasDevTools && (this._trampolineEnabled = !1);
                        }, Async.prototype.haveItemsQueued = function() {
                            return this._isTickUsed || this._haveDrainedQueues;
                        }, Async.prototype.fatalError = function(e, isNode) {
                            isNode ? (process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n"), 
                            process.exit(2)) : this.throwLater(e);
                        }, Async.prototype.throwLater = function(fn, arg) {
                            if (1 === arguments.length && (arg = fn, fn = function() {
                                throw arg;
                            }), "undefined" != typeof setTimeout) setTimeout(function() {
                                fn(arg);
                            }, 0); else try {
                                this._schedule(function() {
                                    fn(arg);
                                });
                            } catch (e) {
                                throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
                            }
                        }, util.hasDevTools ? (Async.prototype.invokeLater = function(fn, receiver, arg) {
                            this._trampolineEnabled ? AsyncInvokeLater.call(this, fn, receiver, arg) : this._schedule(function() {
                                setTimeout(function() {
                                    fn.call(receiver, arg);
                                }, 100);
                            });
                        }, Async.prototype.invoke = function(fn, receiver, arg) {
                            this._trampolineEnabled ? AsyncInvoke.call(this, fn, receiver, arg) : this._schedule(function() {
                                fn.call(receiver, arg);
                            });
                        }, Async.prototype.settlePromises = function(promise) {
                            this._trampolineEnabled ? AsyncSettlePromises.call(this, promise) : this._schedule(function() {
                                promise._settlePromises();
                            });
                        }) : (Async.prototype.invokeLater = AsyncInvokeLater, Async.prototype.invoke = AsyncInvoke, 
                        Async.prototype.settlePromises = AsyncSettlePromises), Async.prototype._drainQueue = function(queue) {
                            for (;queue.length() > 0; ) {
                                var fn = queue.shift();
                                if ("function" == typeof fn) {
                                    var receiver = queue.shift(), arg = queue.shift();
                                    fn.call(receiver, arg);
                                } else fn._settlePromises();
                            }
                        }, Async.prototype._drainQueues = function() {
                            this._drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, 
                            this._drainQueue(this._lateQueue);
                        }, Async.prototype._queueTick = function() {
                            this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
                        }, Async.prototype._reset = function() {
                            this._isTickUsed = !1;
                        }, module.exports = Async, module.exports.firstLineError = firstLineError;
                    }, {
                        "./queue": 26,
                        "./schedule": 29,
                        "./util": 36
                    } ],
                    3: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
                            var calledBind = !1, rejectThis = function(_, e) {
                                this._reject(e);
                            }, targetRejected = function(e, context) {
                                context.promiseRejectionQueued = !0, context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
                            }, bindingResolved = function(thisArg, context) {
                                0 == (50397184 & this._bitField) && this._resolveCallback(context.target);
                            }, bindingRejected = function(e, context) {
                                context.promiseRejectionQueued || this._reject(e);
                            };
                            Promise.prototype.bind = function(thisArg) {
                                calledBind || (calledBind = !0, Promise.prototype._propagateFrom = debug.propagateFromFunction(), 
                                Promise.prototype._boundValue = debug.boundValueFunction());
                                var maybePromise = tryConvertToPromise(thisArg), ret = new Promise(INTERNAL);
                                ret._propagateFrom(this, 1);
                                var target = this._target();
                                if (ret._setBoundTo(maybePromise), maybePromise instanceof Promise) {
                                    var context = {
                                        promiseRejectionQueued: !1,
                                        promise: ret,
                                        target: target,
                                        bindingPromise: maybePromise
                                    };
                                    target._then(INTERNAL, targetRejected, void 0, ret, context), maybePromise._then(bindingResolved, bindingRejected, void 0, ret, context), 
                                    ret._setOnCancel(maybePromise);
                                } else ret._resolveCallback(target);
                                return ret;
                            }, Promise.prototype._setBoundTo = function(obj) {
                                void 0 !== obj ? (this._bitField = 2097152 | this._bitField, this._boundTo = obj) : this._bitField = -2097153 & this._bitField;
                            }, Promise.prototype._isBound = function() {
                                return 2097152 == (2097152 & this._bitField);
                            }, Promise.bind = function(thisArg, value) {
                                return Promise.resolve(value).bind(thisArg);
                            };
                        };
                    }, {} ],
                    4: [ function(_dereq_, module, exports) {
                        "use strict";
                        var old;
                        "undefined" != typeof Promise && (old = Promise);
                        var bluebird = _dereq_("./promise")();
                        bluebird.noConflict = function() {
                            try {
                                Promise === bluebird && (Promise = old);
                            } catch (e) {}
                            return bluebird;
                        }, module.exports = bluebird;
                    }, {
                        "./promise": 22
                    } ],
                    5: [ function(_dereq_, module, exports) {
                        "use strict";
                        var cr = Object.create;
                        if (cr) {
                            var callerCache = cr(null), getterCache = cr(null);
                            callerCache[" size"] = getterCache[" size"] = 0;
                        }
                        module.exports = function(Promise) {
                            var getGetter, util = _dereq_("./util"), canEvaluate = util.canEvaluate;
                            util.isIdentifier;
                            function ensureMethod(obj, methodName) {
                                var fn;
                                if (null != obj && (fn = obj[methodName]), "function" != typeof fn) {
                                    var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
                                    throw new Promise.TypeError(message);
                                }
                                return fn;
                            }
                            function caller(obj) {
                                return ensureMethod(obj, this.pop()).apply(obj, this);
                            }
                            function namedGetter(obj) {
                                return obj[this];
                            }
                            function indexedGetter(obj) {
                                var index = +this;
                                return index < 0 && (index = Math.max(0, index + obj.length)), obj[index];
                            }
                            Promise.prototype.call = function(methodName) {
                                var args = [].slice.call(arguments, 1);
                                return args.push(methodName), this._then(caller, void 0, void 0, args, void 0);
                            }, Promise.prototype.get = function(propertyName) {
                                var getter;
                                if ("number" == typeof propertyName) getter = indexedGetter; else if (canEvaluate) {
                                    var maybeGetter = getGetter(propertyName);
                                    getter = null !== maybeGetter ? maybeGetter : namedGetter;
                                } else getter = namedGetter;
                                return this._then(getter, void 0, void 0, propertyName, void 0);
                            };
                        };
                    }, {
                        "./util": 36
                    } ],
                    6: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, PromiseArray, apiRejection, debug) {
                            var util = _dereq_("./util"), tryCatch = util.tryCatch, errorObj = util.errorObj, async = Promise._async;
                            Promise.prototype.break = Promise.prototype.cancel = function() {
                                if (!debug.cancellation()) return this._warn("cancellation is disabled");
                                for (var promise = this, child = promise; promise._isCancellable(); ) {
                                    if (!promise._cancelBy(child)) {
                                        child._isFollowing() ? child._followee().cancel() : child._cancelBranched();
                                        break;
                                    }
                                    var parent = promise._cancellationParent;
                                    if (null == parent || !parent._isCancellable()) {
                                        promise._isFollowing() ? promise._followee().cancel() : promise._cancelBranched();
                                        break;
                                    }
                                    promise._isFollowing() && promise._followee().cancel(), promise._setWillBeCancelled(), 
                                    child = promise, promise = parent;
                                }
                            }, Promise.prototype._branchHasCancelled = function() {
                                this._branchesRemainingToCancel--;
                            }, Promise.prototype._enoughBranchesHaveCancelled = function() {
                                return void 0 === this._branchesRemainingToCancel || this._branchesRemainingToCancel <= 0;
                            }, Promise.prototype._cancelBy = function(canceller) {
                                return canceller === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), 
                                !0) : (this._branchHasCancelled(), !!this._enoughBranchesHaveCancelled() && (this._invokeOnCancel(), 
                                !0));
                            }, Promise.prototype._cancelBranched = function() {
                                this._enoughBranchesHaveCancelled() && this._cancel();
                            }, Promise.prototype._cancel = function() {
                                this._isCancellable() && (this._setCancelled(), async.invoke(this._cancelPromises, this, void 0));
                            }, Promise.prototype._cancelPromises = function() {
                                this._length() > 0 && this._settlePromises();
                            }, Promise.prototype._unsetOnCancel = function() {
                                this._onCancelField = void 0;
                            }, Promise.prototype._isCancellable = function() {
                                return this.isPending() && !this._isCancelled();
                            }, Promise.prototype.isCancellable = function() {
                                return this.isPending() && !this.isCancelled();
                            }, Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
                                if (util.isArray(onCancelCallback)) for (var i = 0; i < onCancelCallback.length; ++i) this._doInvokeOnCancel(onCancelCallback[i], internalOnly); else if (void 0 !== onCancelCallback) if ("function" == typeof onCancelCallback) {
                                    if (!internalOnly) {
                                        var e = tryCatch(onCancelCallback).call(this._boundValue());
                                        e === errorObj && (this._attachExtraTrace(e.e), async.throwLater(e.e));
                                    }
                                } else onCancelCallback._resultCancelled(this);
                            }, Promise.prototype._invokeOnCancel = function() {
                                var onCancelCallback = this._onCancel();
                                this._unsetOnCancel(), async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
                            }, Promise.prototype._invokeInternalOnCancel = function() {
                                this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
                            }, Promise.prototype._resultCancelled = function() {
                                this.cancel();
                            };
                        };
                    }, {
                        "./util": 36
                    } ],
                    7: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(NEXT_FILTER) {
                            var util = _dereq_("./util"), getKeys = _dereq_("./es5").keys, tryCatch = util.tryCatch, errorObj = util.errorObj;
                            return function(instances, cb, promise) {
                                return function(e) {
                                    var boundTo = promise._boundValue();
                                    predicateLoop: for (var i = 0; i < instances.length; ++i) {
                                        var item = instances[i];
                                        if (item === Error || null != item && item.prototype instanceof Error) {
                                            if (e instanceof item) return tryCatch(cb).call(boundTo, e);
                                        } else if ("function" == typeof item) {
                                            var matchesPredicate = tryCatch(item).call(boundTo, e);
                                            if (matchesPredicate === errorObj) return matchesPredicate;
                                            if (matchesPredicate) return tryCatch(cb).call(boundTo, e);
                                        } else if (util.isObject(e)) {
                                            for (var keys = getKeys(item), j = 0; j < keys.length; ++j) {
                                                var key = keys[j];
                                                if (item[key] != e[key]) continue predicateLoop;
                                            }
                                            return tryCatch(cb).call(boundTo, e);
                                        }
                                    }
                                    return NEXT_FILTER;
                                };
                            };
                        };
                    }, {
                        "./es5": 13,
                        "./util": 36
                    } ],
                    8: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise) {
                            var longStackTraces = !1, contextStack = [];
                            function Context() {
                                this._trace = new Context.CapturedTrace(peekContext());
                            }
                            function peekContext() {
                                var lastIndex = contextStack.length - 1;
                                if (lastIndex >= 0) return contextStack[lastIndex];
                            }
                            return Promise.prototype._promiseCreated = function() {}, Promise.prototype._pushContext = function() {}, 
                            Promise.prototype._popContext = function() {
                                return null;
                            }, Promise._peekContext = Promise.prototype._peekContext = function() {}, Context.prototype._pushContext = function() {
                                void 0 !== this._trace && (this._trace._promiseCreated = null, contextStack.push(this._trace));
                            }, Context.prototype._popContext = function() {
                                if (void 0 !== this._trace) {
                                    var trace = contextStack.pop(), ret = trace._promiseCreated;
                                    return trace._promiseCreated = null, ret;
                                }
                                return null;
                            }, Context.CapturedTrace = null, Context.create = function() {
                                if (longStackTraces) return new Context();
                            }, Context.deactivateLongStackTraces = function() {}, Context.activateLongStackTraces = function() {
                                var Promise_pushContext = Promise.prototype._pushContext, Promise_popContext = Promise.prototype._popContext, Promise_PeekContext = Promise._peekContext, Promise_peekContext = Promise.prototype._peekContext, Promise_promiseCreated = Promise.prototype._promiseCreated;
                                Context.deactivateLongStackTraces = function() {
                                    Promise.prototype._pushContext = Promise_pushContext, Promise.prototype._popContext = Promise_popContext, 
                                    Promise._peekContext = Promise_PeekContext, Promise.prototype._peekContext = Promise_peekContext, 
                                    Promise.prototype._promiseCreated = Promise_promiseCreated, longStackTraces = !1;
                                }, longStackTraces = !0, Promise.prototype._pushContext = Context.prototype._pushContext, 
                                Promise.prototype._popContext = Context.prototype._popContext, Promise._peekContext = Promise.prototype._peekContext = peekContext, 
                                Promise.prototype._promiseCreated = function() {
                                    var ctx = this._peekContext();
                                    ctx && null == ctx._promiseCreated && (ctx._promiseCreated = this);
                                };
                            }, Context;
                        };
                    }, {} ],
                    9: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, Context) {
                            var unhandledRejectionHandled, possiblyUnhandledRejection, printWarning, getDomain = Promise._getDomain, async = Promise._async, Warning = _dereq_("./errors").Warning, util = _dereq_("./util"), canAttachTrace = util.canAttachTrace, bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/, parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, stackFramePattern = null, formatStack = null, indentStackFrames = !1, debugging = !(0 == util.env("BLUEBIRD_DEBUG")), warnings = !(0 == util.env("BLUEBIRD_WARNINGS") || !debugging && !util.env("BLUEBIRD_WARNINGS")), longStackTraces = !(0 == util.env("BLUEBIRD_LONG_STACK_TRACES") || !debugging && !util.env("BLUEBIRD_LONG_STACK_TRACES")), wForgottenReturn = 0 != util.env("BLUEBIRD_W_FORGOTTEN_RETURN") && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
                            Promise.prototype.suppressUnhandledRejections = function() {
                                var target = this._target();
                                target._bitField = -1048577 & target._bitField | 524288;
                            }, Promise.prototype._ensurePossibleRejectionHandled = function() {
                                if (0 == (524288 & this._bitField)) {
                                    this._setRejectionIsUnhandled();
                                    var self = this;
                                    setTimeout(function() {
                                        self._notifyUnhandledRejection();
                                    }, 1);
                                }
                            }, Promise.prototype._notifyUnhandledRejectionIsHandled = function() {
                                fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, void 0, this);
                            }, Promise.prototype._setReturnedNonUndefined = function() {
                                this._bitField = 268435456 | this._bitField;
                            }, Promise.prototype._returnedNonUndefined = function() {
                                return 0 != (268435456 & this._bitField);
                            }, Promise.prototype._notifyUnhandledRejection = function() {
                                if (this._isRejectionUnhandled()) {
                                    var reason = this._settledValue();
                                    this._setUnhandledRejectionIsNotified(), fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
                                }
                            }, Promise.prototype._setUnhandledRejectionIsNotified = function() {
                                this._bitField = 262144 | this._bitField;
                            }, Promise.prototype._unsetUnhandledRejectionIsNotified = function() {
                                this._bitField = -262145 & this._bitField;
                            }, Promise.prototype._isUnhandledRejectionNotified = function() {
                                return (262144 & this._bitField) > 0;
                            }, Promise.prototype._setRejectionIsUnhandled = function() {
                                this._bitField = 1048576 | this._bitField;
                            }, Promise.prototype._unsetRejectionIsUnhandled = function() {
                                this._bitField = -1048577 & this._bitField, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), 
                                this._notifyUnhandledRejectionIsHandled());
                            }, Promise.prototype._isRejectionUnhandled = function() {
                                return (1048576 & this._bitField) > 0;
                            }, Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
                                return warn(message, shouldUseOwnTrace, promise || this);
                            }, Promise.onPossiblyUnhandledRejection = function(fn) {
                                var domain = getDomain();
                                possiblyUnhandledRejection = "function" == typeof fn ? null === domain ? fn : util.domainBind(domain, fn) : void 0;
                            }, Promise.onUnhandledRejectionHandled = function(fn) {
                                var domain = getDomain();
                                unhandledRejectionHandled = "function" == typeof fn ? null === domain ? fn : util.domainBind(domain, fn) : void 0;
                            };
                            var disableLongStackTraces = function() {};
                            Promise.longStackTraces = function() {
                                if (async.haveItemsQueued() && !config.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
                                if (!config.longStackTraces && longStackTracesIsSupported()) {
                                    var Promise_captureStackTrace = Promise.prototype._captureStackTrace, Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
                                    config.longStackTraces = !0, disableLongStackTraces = function() {
                                        if (async.haveItemsQueued() && !config.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
                                        Promise.prototype._captureStackTrace = Promise_captureStackTrace, Promise.prototype._attachExtraTrace = Promise_attachExtraTrace, 
                                        Context.deactivateLongStackTraces(), async.enableTrampoline(), config.longStackTraces = !1;
                                    }, Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace, Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace, 
                                    Context.activateLongStackTraces(), async.disableTrampolineIfNecessary();
                                }
                            }, Promise.hasLongStackTraces = function() {
                                return config.longStackTraces && longStackTracesIsSupported();
                            };
                            var fireDomEvent = function() {
                                try {
                                    if ("function" == typeof CustomEvent) {
                                        var event = new CustomEvent("CustomEvent");
                                        return util.global.dispatchEvent(event), function(name, event) {
                                            var domEvent = new CustomEvent(name.toLowerCase(), {
                                                detail: event,
                                                cancelable: !0
                                            });
                                            return !util.global.dispatchEvent(domEvent);
                                        };
                                    }
                                    if ("function" == typeof Event) {
                                        event = new Event("CustomEvent");
                                        return util.global.dispatchEvent(event), function(name, event) {
                                            var domEvent = new Event(name.toLowerCase(), {
                                                cancelable: !0
                                            });
                                            return domEvent.detail = event, !util.global.dispatchEvent(domEvent);
                                        };
                                    }
                                    return (event = document.createEvent("CustomEvent")).initCustomEvent("testingtheevent", !1, !0, {}), 
                                    util.global.dispatchEvent(event), function(name, event) {
                                        var domEvent = document.createEvent("CustomEvent");
                                        return domEvent.initCustomEvent(name.toLowerCase(), !1, !0, event), !util.global.dispatchEvent(domEvent);
                                    };
                                } catch (e) {}
                                return function() {
                                    return !1;
                                };
                            }(), fireGlobalEvent = util.isNode ? function() {
                                return process.emit.apply(process, arguments);
                            } : util.global ? function(name) {
                                var methodName = "on" + name.toLowerCase(), method = util.global[methodName];
                                return !!method && (method.apply(util.global, [].slice.call(arguments, 1)), !0);
                            } : function() {
                                return !1;
                            };
                            function generatePromiseLifecycleEventObject(name, promise) {
                                return {
                                    promise: promise
                                };
                            }
                            var eventToObjectGenerator = {
                                promiseCreated: generatePromiseLifecycleEventObject,
                                promiseFulfilled: generatePromiseLifecycleEventObject,
                                promiseRejected: generatePromiseLifecycleEventObject,
                                promiseResolved: generatePromiseLifecycleEventObject,
                                promiseCancelled: generatePromiseLifecycleEventObject,
                                promiseChained: function(name, promise, child) {
                                    return {
                                        promise: promise,
                                        child: child
                                    };
                                },
                                warning: function(name, warning) {
                                    return {
                                        warning: warning
                                    };
                                },
                                unhandledRejection: function(name, reason, promise) {
                                    return {
                                        reason: reason,
                                        promise: promise
                                    };
                                },
                                rejectionHandled: generatePromiseLifecycleEventObject
                            }, activeFireEvent = function(name) {
                                var globalEventFired = !1;
                                try {
                                    globalEventFired = fireGlobalEvent.apply(null, arguments);
                                } catch (e) {
                                    async.throwLater(e), globalEventFired = !0;
                                }
                                var domEventFired = !1;
                                try {
                                    domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
                                } catch (e) {
                                    async.throwLater(e), domEventFired = !0;
                                }
                                return domEventFired || globalEventFired;
                            };
                            function defaultFireEvent() {
                                return !1;
                            }
                            function cancellationExecute(executor, resolve, reject) {
                                var promise = this;
                                try {
                                    executor(resolve, reject, function(onCancel) {
                                        if ("function" != typeof onCancel) throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
                                        promise._attachCancellationCallback(onCancel);
                                    });
                                } catch (e) {
                                    return e;
                                }
                            }
                            function cancellationAttachCancellationCallback(onCancel) {
                                if (!this._isCancellable()) return this;
                                var previousOnCancel = this._onCancel();
                                void 0 !== previousOnCancel ? util.isArray(previousOnCancel) ? previousOnCancel.push(onCancel) : this._setOnCancel([ previousOnCancel, onCancel ]) : this._setOnCancel(onCancel);
                            }
                            function cancellationOnCancel() {
                                return this._onCancelField;
                            }
                            function cancellationSetOnCancel(onCancel) {
                                this._onCancelField = onCancel;
                            }
                            function cancellationClearCancellationData() {
                                this._cancellationParent = void 0, this._onCancelField = void 0;
                            }
                            function cancellationPropagateFrom(parent, flags) {
                                if (0 != (1 & flags)) {
                                    this._cancellationParent = parent;
                                    var branchesRemainingToCancel = parent._branchesRemainingToCancel;
                                    void 0 === branchesRemainingToCancel && (branchesRemainingToCancel = 0), parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
                                }
                                0 != (2 & flags) && parent._isBound() && this._setBoundTo(parent._boundTo);
                            }
                            Promise.config = function(opts) {
                                if ("longStackTraces" in (opts = Object(opts)) && (opts.longStackTraces ? Promise.longStackTraces() : !opts.longStackTraces && Promise.hasLongStackTraces() && disableLongStackTraces()), 
                                "warnings" in opts) {
                                    var warningsOption = opts.warnings;
                                    config.warnings = !!warningsOption, wForgottenReturn = config.warnings, util.isObject(warningsOption) && "wForgottenReturn" in warningsOption && (wForgottenReturn = !!warningsOption.wForgottenReturn);
                                }
                                if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
                                    if (async.haveItemsQueued()) throw new Error("cannot enable cancellation after promises are in use");
                                    Promise.prototype._clearCancellationData = cancellationClearCancellationData, Promise.prototype._propagateFrom = cancellationPropagateFrom, 
                                    Promise.prototype._onCancel = cancellationOnCancel, Promise.prototype._setOnCancel = cancellationSetOnCancel, 
                                    Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback, 
                                    Promise.prototype._execute = cancellationExecute, propagateFromFunction = cancellationPropagateFrom, 
                                    config.cancellation = !0;
                                }
                                return "monitoring" in opts && (opts.monitoring && !config.monitoring ? (config.monitoring = !0, 
                                Promise.prototype._fireEvent = activeFireEvent) : !opts.monitoring && config.monitoring && (config.monitoring = !1, 
                                Promise.prototype._fireEvent = defaultFireEvent)), Promise;
                            }, Promise.prototype._fireEvent = defaultFireEvent, Promise.prototype._execute = function(executor, resolve, reject) {
                                try {
                                    executor(resolve, reject);
                                } catch (e) {
                                    return e;
                                }
                            }, Promise.prototype._onCancel = function() {}, Promise.prototype._setOnCancel = function(handler) {}, 
                            Promise.prototype._attachCancellationCallback = function(onCancel) {}, Promise.prototype._captureStackTrace = function() {}, 
                            Promise.prototype._attachExtraTrace = function() {}, Promise.prototype._clearCancellationData = function() {}, 
                            Promise.prototype._propagateFrom = function(parent, flags) {};
                            var propagateFromFunction = function(parent, flags) {
                                0 != (2 & flags) && parent._isBound() && this._setBoundTo(parent._boundTo);
                            };
                            function boundValueFunction() {
                                var ret = this._boundTo;
                                return void 0 !== ret && ret instanceof Promise ? ret.isFulfilled() ? ret.value() : void 0 : ret;
                            }
                            function longStackTracesCaptureStackTrace() {
                                this._trace = new CapturedTrace(this._peekContext());
                            }
                            function longStackTracesAttachExtraTrace(error, ignoreSelf) {
                                if (canAttachTrace(error)) {
                                    var trace = this._trace;
                                    if (void 0 !== trace && ignoreSelf && (trace = trace._parent), void 0 !== trace) trace.attachExtraTrace(error); else if (!error.__stackCleaned__) {
                                        var parsed = parseStackAndMessage(error);
                                        util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n")), 
                                        util.notEnumerableProp(error, "__stackCleaned__", !0);
                                    }
                                }
                            }
                            function warn(message, shouldUseOwnTrace, promise) {
                                if (config.warnings) {
                                    var ctx, warning = new Warning(message);
                                    if (shouldUseOwnTrace) promise._attachExtraTrace(warning); else if (config.longStackTraces && (ctx = Promise._peekContext())) ctx.attachExtraTrace(warning); else {
                                        var parsed = parseStackAndMessage(warning);
                                        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
                                    }
                                    activeFireEvent("warning", warning) || formatAndLogError(warning, "", !0);
                                }
                            }
                            function cleanStack(stack) {
                                for (var ret = [], i = 0; i < stack.length; ++i) {
                                    var line = stack[i], isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line), isInternalFrame = isTraceLine && shouldIgnore(line);
                                    isTraceLine && !isInternalFrame && (indentStackFrames && " " !== line.charAt(0) && (line = "    " + line), 
                                    ret.push(line));
                                }
                                return ret;
                            }
                            function parseStackAndMessage(error) {
                                var stack = error.stack, message = error.toString();
                                return stack = "string" == typeof stack && stack.length > 0 ? function(error) {
                                    for (var stack = error.stack.replace(/\s+$/g, "").split("\n"), i = 0; i < stack.length; ++i) {
                                        var line = stack[i];
                                        if ("    (No stack trace)" === line || stackFramePattern.test(line)) break;
                                    }
                                    return i > 0 && "SyntaxError" != error.name && (stack = stack.slice(i)), stack;
                                }(error) : [ "    (No stack trace)" ], {
                                    message: message,
                                    stack: "SyntaxError" == error.name ? stack : cleanStack(stack)
                                };
                            }
                            function formatAndLogError(error, title, isSoft) {
                                if ("undefined" != typeof console) {
                                    var message;
                                    if (util.isObject(error)) {
                                        var stack = error.stack;
                                        message = title + formatStack(stack, error);
                                    } else message = title + String(error);
                                    "function" == typeof printWarning ? printWarning(message, isSoft) : "function" != typeof console.log && "object" != typeof console.log || console.log(message);
                                }
                            }
                            function fireRejectionEvent(name, localHandler, reason, promise) {
                                var localEventFired = !1;
                                try {
                                    "function" == typeof localHandler && (localEventFired = !0, "rejectionHandled" === name ? localHandler(promise) : localHandler(reason, promise));
                                } catch (e) {
                                    async.throwLater(e);
                                }
                                "unhandledRejection" === name ? activeFireEvent(name, reason, promise) || localEventFired || formatAndLogError(reason, "Unhandled rejection ") : activeFireEvent(name, promise);
                            }
                            function formatNonError(obj) {
                                var str;
                                if ("function" == typeof obj) str = "[function " + (obj.name || "anonymous") + "]"; else {
                                    str = obj && "function" == typeof obj.toString ? obj.toString() : util.toString(obj);
                                    if (/\[object [a-zA-Z0-9$_]+\]/.test(str)) try {
                                        str = JSON.stringify(obj);
                                    } catch (e) {}
                                    0 === str.length && (str = "(empty array)");
                                }
                                return "(<" + function(str) {
                                    if (str.length < 41) return str;
                                    return str.substr(0, 38) + "...";
                                }(str) + ">, no stack trace)";
                            }
                            function longStackTracesIsSupported() {
                                return "function" == typeof captureStackTrace;
                            }
                            var shouldIgnore = function() {
                                return !1;
                            }, parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
                            function parseLineInfo(line) {
                                var matches = line.match(parseLineInfoRegex);
                                if (matches) return {
                                    fileName: matches[1],
                                    line: parseInt(matches[2], 10)
                                };
                            }
                            function CapturedTrace(parent) {
                                this._parent = parent, this._promisesCreated = 0;
                                var length = this._length = 1 + (void 0 === parent ? 0 : parent._length);
                                captureStackTrace(this, CapturedTrace), length > 32 && this.uncycle();
                            }
                            util.inherits(CapturedTrace, Error), Context.CapturedTrace = CapturedTrace, CapturedTrace.prototype.uncycle = function() {
                                var length = this._length;
                                if (!(length < 2)) {
                                    for (var nodes = [], stackToIndex = {}, i = 0, node = this; void 0 !== node; ++i) nodes.push(node), 
                                    node = node._parent;
                                    for (i = (length = this._length = i) - 1; i >= 0; --i) {
                                        var stack = nodes[i].stack;
                                        void 0 === stackToIndex[stack] && (stackToIndex[stack] = i);
                                    }
                                    for (i = 0; i < length; ++i) {
                                        var index = stackToIndex[nodes[i].stack];
                                        if (void 0 !== index && index !== i) {
                                            index > 0 && (nodes[index - 1]._parent = void 0, nodes[index - 1]._length = 1), 
                                            nodes[i]._parent = void 0, nodes[i]._length = 1;
                                            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                                            index < length - 1 ? (cycleEdgeNode._parent = nodes[index + 1], cycleEdgeNode._parent.uncycle(), 
                                            cycleEdgeNode._length = cycleEdgeNode._parent._length + 1) : (cycleEdgeNode._parent = void 0, 
                                            cycleEdgeNode._length = 1);
                                            for (var currentChildLength = cycleEdgeNode._length + 1, j = i - 2; j >= 0; --j) nodes[j]._length = currentChildLength, 
                                            currentChildLength++;
                                            return;
                                        }
                                    }
                                }
                            }, CapturedTrace.prototype.attachExtraTrace = function(error) {
                                if (!error.__stackCleaned__) {
                                    this.uncycle();
                                    for (var parsed = parseStackAndMessage(error), message = parsed.message, stacks = [ parsed.stack ], trace = this; void 0 !== trace; ) stacks.push(cleanStack(trace.stack.split("\n"))), 
                                    trace = trace._parent;
                                    !function(stacks) {
                                        for (var current = stacks[0], i = 1; i < stacks.length; ++i) {
                                            for (var prev = stacks[i], currentLastIndex = current.length - 1, currentLastLine = current[currentLastIndex], commonRootMeetPoint = -1, j = prev.length - 1; j >= 0; --j) if (prev[j] === currentLastLine) {
                                                commonRootMeetPoint = j;
                                                break;
                                            }
                                            for (j = commonRootMeetPoint; j >= 0; --j) {
                                                var line = prev[j];
                                                if (current[currentLastIndex] !== line) break;
                                                current.pop(), currentLastIndex--;
                                            }
                                            current = prev;
                                        }
                                    }(stacks), function(stacks) {
                                        for (var i = 0; i < stacks.length; ++i) (0 === stacks[i].length || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) && (stacks.splice(i, 1), 
                                        i--);
                                    }(stacks), util.notEnumerableProp(error, "stack", function(message, stacks) {
                                        for (var i = 0; i < stacks.length - 1; ++i) stacks[i].push("From previous event:"), 
                                        stacks[i] = stacks[i].join("\n");
                                        return i < stacks.length && (stacks[i] = stacks[i].join("\n")), message + "\n" + stacks.join("\n");
                                    }(message, stacks)), util.notEnumerableProp(error, "__stackCleaned__", !0);
                                }
                            };
                            var captureStackTrace = function() {
                                var v8stackFramePattern = /^\s*at\s*/, v8stackFormatter = function(stack, error) {
                                    return "string" == typeof stack ? stack : void 0 !== error.name && void 0 !== error.message ? error.toString() : formatNonError(error);
                                };
                                if ("number" == typeof Error.stackTraceLimit && "function" == typeof Error.captureStackTrace) {
                                    Error.stackTraceLimit += 6, stackFramePattern = v8stackFramePattern, formatStack = v8stackFormatter;
                                    var captureStackTrace = Error.captureStackTrace;
                                    return shouldIgnore = function(line) {
                                        return bluebirdFramePattern.test(line);
                                    }, function(receiver, ignoreUntil) {
                                        Error.stackTraceLimit += 6, captureStackTrace(receiver, ignoreUntil), Error.stackTraceLimit -= 6;
                                    };
                                }
                                var hasStackAfterThrow, err = new Error();
                                if ("string" == typeof err.stack && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) return stackFramePattern = /@/, 
                                formatStack = v8stackFormatter, indentStackFrames = !0, function(o) {
                                    o.stack = new Error().stack;
                                };
                                try {
                                    throw new Error();
                                } catch (e) {
                                    hasStackAfterThrow = "stack" in e;
                                }
                                return "stack" in err || !hasStackAfterThrow || "number" != typeof Error.stackTraceLimit ? (formatStack = function(stack, error) {
                                    return "string" == typeof stack ? stack : "object" != typeof error && "function" != typeof error || void 0 === error.name || void 0 === error.message ? formatNonError(error) : error.toString();
                                }, null) : (stackFramePattern = v8stackFramePattern, formatStack = v8stackFormatter, 
                                function(o) {
                                    Error.stackTraceLimit += 6;
                                    try {
                                        throw new Error();
                                    } catch (e) {
                                        o.stack = e.stack;
                                    }
                                    Error.stackTraceLimit -= 6;
                                });
                            }();
                            "undefined" != typeof console && void 0 !== console.warn && (printWarning = function(message) {
                                console.warn(message);
                            }, util.isNode && process.stderr.isTTY ? printWarning = function(message, isSoft) {
                                var color = isSoft ? "[33m" : "[31m";
                                console.warn(color + message + "[0m\n");
                            } : util.isNode || "string" != typeof new Error().stack || (printWarning = function(message, isSoft) {
                                console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
                            }));
                            var config = {
                                warnings: warnings,
                                longStackTraces: !1,
                                cancellation: !1,
                                monitoring: !1
                            };
                            return longStackTraces && Promise.longStackTraces(), {
                                longStackTraces: function() {
                                    return config.longStackTraces;
                                },
                                warnings: function() {
                                    return config.warnings;
                                },
                                cancellation: function() {
                                    return config.cancellation;
                                },
                                monitoring: function() {
                                    return config.monitoring;
                                },
                                propagateFromFunction: function() {
                                    return propagateFromFunction;
                                },
                                boundValueFunction: function() {
                                    return boundValueFunction;
                                },
                                checkForgottenReturns: function(returnValue, promiseCreated, name, promise, parent) {
                                    if (void 0 === returnValue && null !== promiseCreated && wForgottenReturn) {
                                        if (void 0 !== parent && parent._returnedNonUndefined()) return;
                                        if (0 == (65535 & promise._bitField)) return;
                                        name && (name += " ");
                                        var handlerLine = "", creatorLine = "";
                                        if (promiseCreated._trace) {
                                            for (var traceLines = promiseCreated._trace.stack.split("\n"), stack = cleanStack(traceLines), i = stack.length - 1; i >= 0; --i) {
                                                var line = stack[i];
                                                if (!nodeFramePattern.test(line)) {
                                                    var lineMatches = line.match(parseLinePattern);
                                                    lineMatches && (handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ");
                                                    break;
                                                }
                                            }
                                            if (stack.length > 0) {
                                                var firstUserLine = stack[0];
                                                for (i = 0; i < traceLines.length; ++i) if (traceLines[i] === firstUserLine) {
                                                    i > 0 && (creatorLine = "\n" + traceLines[i - 1]);
                                                    break;
                                                }
                                            }
                                        }
                                        var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
                                        promise._warn(msg, !0, promiseCreated);
                                    }
                                },
                                setBounds: function(firstLineError, lastLineError) {
                                    if (longStackTracesIsSupported()) {
                                        for (var firstFileName, lastFileName, firstStackLines = firstLineError.stack.split("\n"), lastStackLines = lastLineError.stack.split("\n"), firstIndex = -1, lastIndex = -1, i = 0; i < firstStackLines.length; ++i) if (result = parseLineInfo(firstStackLines[i])) {
                                            firstFileName = result.fileName, firstIndex = result.line;
                                            break;
                                        }
                                        for (i = 0; i < lastStackLines.length; ++i) {
                                            var result;
                                            if (result = parseLineInfo(lastStackLines[i])) {
                                                lastFileName = result.fileName, lastIndex = result.line;
                                                break;
                                            }
                                        }
                                        firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex || (shouldIgnore = function(line) {
                                            if (bluebirdFramePattern.test(line)) return !0;
                                            var info = parseLineInfo(line);
                                            return !!(info && info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex);
                                        });
                                    }
                                },
                                warn: warn,
                                deprecated: function(name, replacement) {
                                    var message = name + " is deprecated and will be removed in a future version.";
                                    return replacement && (message += " Use " + replacement + " instead."), warn(message);
                                },
                                CapturedTrace: CapturedTrace,
                                fireDomEvent: fireDomEvent,
                                fireGlobalEvent: fireGlobalEvent
                            };
                        };
                    }, {
                        "./errors": 12,
                        "./util": 36
                    } ],
                    10: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise) {
                            function returner() {
                                return this.value;
                            }
                            function thrower() {
                                throw this.reason;
                            }
                            Promise.prototype.return = Promise.prototype.thenReturn = function(value) {
                                return value instanceof Promise && value.suppressUnhandledRejections(), this._then(returner, void 0, void 0, {
                                    value: value
                                }, void 0);
                            }, Promise.prototype.throw = Promise.prototype.thenThrow = function(reason) {
                                return this._then(thrower, void 0, void 0, {
                                    reason: reason
                                }, void 0);
                            }, Promise.prototype.catchThrow = function(reason) {
                                if (arguments.length <= 1) return this._then(void 0, thrower, void 0, {
                                    reason: reason
                                }, void 0);
                                var _reason = arguments[1];
                                return this.caught(reason, function() {
                                    throw _reason;
                                });
                            }, Promise.prototype.catchReturn = function(value) {
                                if (arguments.length <= 1) return value instanceof Promise && value.suppressUnhandledRejections(), 
                                this._then(void 0, returner, void 0, {
                                    value: value
                                }, void 0);
                                var _value = arguments[1];
                                _value instanceof Promise && _value.suppressUnhandledRejections();
                                return this.caught(value, function() {
                                    return _value;
                                });
                            };
                        };
                    }, {} ],
                    11: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, INTERNAL) {
                            var PromiseReduce = Promise.reduce, PromiseAll = Promise.all;
                            function promiseAllThis() {
                                return PromiseAll(this);
                            }
                            Promise.prototype.each = function(fn) {
                                return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
                            }, Promise.prototype.mapSeries = function(fn) {
                                return PromiseReduce(this, fn, INTERNAL, INTERNAL);
                            }, Promise.each = function(promises, fn) {
                                return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
                            }, Promise.mapSeries = function(promises, fn) {
                                return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
                            };
                        };
                    }, {} ],
                    12: [ function(_dereq_, module, exports) {
                        "use strict";
                        var _TypeError, _RangeError, es5 = _dereq_("./es5"), Objectfreeze = es5.freeze, util = _dereq_("./util"), inherits = util.inherits, notEnumerableProp = util.notEnumerableProp;
                        function subError(nameProperty, defaultMessage) {
                            function SubError(message) {
                                if (!(this instanceof SubError)) return new SubError(message);
                                notEnumerableProp(this, "message", "string" == typeof message ? message : defaultMessage), 
                                notEnumerableProp(this, "name", nameProperty), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this);
                            }
                            return inherits(SubError, Error), SubError;
                        }
                        var Warning = subError("Warning", "warning"), CancellationError = subError("CancellationError", "cancellation error"), TimeoutError = subError("TimeoutError", "timeout error"), AggregateError = subError("AggregateError", "aggregate error");
                        try {
                            _TypeError = TypeError, _RangeError = RangeError;
                        } catch (e) {
                            _TypeError = subError("TypeError", "type error"), _RangeError = subError("RangeError", "range error");
                        }
                        for (var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), i = 0; i < methods.length; ++i) "function" == typeof Array.prototype[methods[i]] && (AggregateError.prototype[methods[i]] = Array.prototype[methods[i]]);
                        es5.defineProperty(AggregateError.prototype, "length", {
                            value: 0,
                            configurable: !1,
                            writable: !0,
                            enumerable: !0
                        }), AggregateError.prototype.isOperational = !0;
                        var level = 0;
                        function OperationalError(message) {
                            if (!(this instanceof OperationalError)) return new OperationalError(message);
                            notEnumerableProp(this, "name", "OperationalError"), notEnumerableProp(this, "message", message), 
                            this.cause = message, this.isOperational = !0, message instanceof Error ? (notEnumerableProp(this, "message", message.message), 
                            notEnumerableProp(this, "stack", message.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
                        }
                        AggregateError.prototype.toString = function() {
                            var indent = Array(4 * level + 1).join(" "), ret = "\n" + indent + "AggregateError of:\n";
                            level++, indent = Array(4 * level + 1).join(" ");
                            for (var i = 0; i < this.length; ++i) {
                                for (var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "", lines = str.split("\n"), j = 0; j < lines.length; ++j) lines[j] = indent + lines[j];
                                ret += (str = lines.join("\n")) + "\n";
                            }
                            return level--, ret;
                        }, inherits(OperationalError, Error);
                        var errorTypes = Error.__BluebirdErrorTypes__;
                        errorTypes || (errorTypes = Objectfreeze({
                            CancellationError: CancellationError,
                            TimeoutError: TimeoutError,
                            OperationalError: OperationalError,
                            RejectionError: OperationalError,
                            AggregateError: AggregateError
                        }), es5.defineProperty(Error, "__BluebirdErrorTypes__", {
                            value: errorTypes,
                            writable: !1,
                            enumerable: !1,
                            configurable: !1
                        })), module.exports = {
                            Error: Error,
                            TypeError: _TypeError,
                            RangeError: _RangeError,
                            CancellationError: errorTypes.CancellationError,
                            OperationalError: errorTypes.OperationalError,
                            TimeoutError: errorTypes.TimeoutError,
                            AggregateError: errorTypes.AggregateError,
                            Warning: Warning
                        };
                    }, {
                        "./es5": 13,
                        "./util": 36
                    } ],
                    13: [ function(_dereq_, module, exports) {
                        var isES5 = function() {
                            "use strict";
                            return void 0 === this;
                        }();
                        if (isES5) module.exports = {
                            freeze: Object.freeze,
                            defineProperty: Object.defineProperty,
                            getDescriptor: Object.getOwnPropertyDescriptor,
                            keys: Object.keys,
                            names: Object.getOwnPropertyNames,
                            getPrototypeOf: Object.getPrototypeOf,
                            isArray: Array.isArray,
                            isES5: isES5,
                            propertyIsWritable: function(obj, prop) {
                                var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
                                return !(descriptor && !descriptor.writable && !descriptor.set);
                            }
                        }; else {
                            var has = {}.hasOwnProperty, str = {}.toString, proto = {}.constructor.prototype, ObjectKeys = function(o) {
                                var ret = [];
                                for (var key in o) has.call(o, key) && ret.push(key);
                                return ret;
                            };
                            module.exports = {
                                isArray: function(obj) {
                                    try {
                                        return "[object Array]" === str.call(obj);
                                    } catch (e) {
                                        return !1;
                                    }
                                },
                                keys: ObjectKeys,
                                names: ObjectKeys,
                                defineProperty: function(o, key, desc) {
                                    return o[key] = desc.value, o;
                                },
                                getDescriptor: function(o, key) {
                                    return {
                                        value: o[key]
                                    };
                                },
                                freeze: function(obj) {
                                    return obj;
                                },
                                getPrototypeOf: function(obj) {
                                    try {
                                        return Object(obj).constructor.prototype;
                                    } catch (e) {
                                        return proto;
                                    }
                                },
                                isES5: isES5,
                                propertyIsWritable: function() {
                                    return !0;
                                }
                            };
                        }
                    }, {} ],
                    14: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, INTERNAL) {
                            var PromiseMap = Promise.map;
                            Promise.prototype.filter = function(fn, options) {
                                return PromiseMap(this, fn, options, INTERNAL);
                            }, Promise.filter = function(promises, fn, options) {
                                return PromiseMap(promises, fn, options, INTERNAL);
                            };
                        };
                    }, {} ],
                    15: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {
                            var util = _dereq_("./util"), CancellationError = Promise.CancellationError, errorObj = util.errorObj, catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
                            function PassThroughHandlerContext(promise, type, handler) {
                                this.promise = promise, this.type = type, this.handler = handler, this.called = !1, 
                                this.cancelPromise = null;
                            }
                            function FinallyHandlerCancelReaction(finallyHandler) {
                                this.finallyHandler = finallyHandler;
                            }
                            function checkCancel(ctx, reason) {
                                return null != ctx.cancelPromise && (arguments.length > 1 ? ctx.cancelPromise._reject(reason) : ctx.cancelPromise._cancel(), 
                                ctx.cancelPromise = null, !0);
                            }
                            function succeed() {
                                return finallyHandler.call(this, this.promise._target()._settledValue());
                            }
                            function fail(reason) {
                                if (!checkCancel(this, reason)) return errorObj.e = reason, errorObj;
                            }
                            function finallyHandler(reasonOrValue) {
                                var promise = this.promise, handler = this.handler;
                                if (!this.called) {
                                    this.called = !0;
                                    var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
                                    if (ret === NEXT_FILTER) return ret;
                                    if (void 0 !== ret) {
                                        promise._setReturnedNonUndefined();
                                        var maybePromise = tryConvertToPromise(ret, promise);
                                        if (maybePromise instanceof Promise) {
                                            if (null != this.cancelPromise) {
                                                if (maybePromise._isCancelled()) {
                                                    var reason = new CancellationError("late cancellation observer");
                                                    return promise._attachExtraTrace(reason), errorObj.e = reason, errorObj;
                                                }
                                                maybePromise.isPending() && maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                                            }
                                            return maybePromise._then(succeed, fail, void 0, this, void 0);
                                        }
                                    }
                                }
                                return promise.isRejected() ? (checkCancel(this), errorObj.e = reasonOrValue, errorObj) : (checkCancel(this), 
                                reasonOrValue);
                            }
                            return PassThroughHandlerContext.prototype.isFinallyHandler = function() {
                                return 0 === this.type;
                            }, FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
                                checkCancel(this.finallyHandler);
                            }, Promise.prototype._passThrough = function(handler, type, success, fail) {
                                return "function" != typeof handler ? this.then() : this._then(success, fail, void 0, new PassThroughHandlerContext(this, type, handler), void 0);
                            }, Promise.prototype.lastly = Promise.prototype.finally = function(handler) {
                                return this._passThrough(handler, 0, finallyHandler, finallyHandler);
                            }, Promise.prototype.tap = function(handler) {
                                return this._passThrough(handler, 1, finallyHandler);
                            }, Promise.prototype.tapCatch = function(handlerOrPredicate) {
                                var len = arguments.length;
                                if (1 === len) return this._passThrough(handlerOrPredicate, 1, void 0, finallyHandler);
                                var i, catchInstances = new Array(len - 1), j = 0;
                                for (i = 0; i < len - 1; ++i) {
                                    var item = arguments[i];
                                    if (!util.isObject(item)) return Promise.reject(new TypeError("tapCatch statement predicate: expecting an object but got " + util.classString(item)));
                                    catchInstances[j++] = item;
                                }
                                catchInstances.length = j;
                                var handler = arguments[i];
                                return this._passThrough(catchFilter(catchInstances, handler, this), 1, void 0, finallyHandler);
                            }, PassThroughHandlerContext;
                        };
                    }, {
                        "./catch_filter": 7,
                        "./util": 36
                    } ],
                    16: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
                            var TypeError = _dereq_("./errors").TypeError, util = _dereq_("./util"), errorObj = util.errorObj, tryCatch = util.tryCatch, yieldHandlers = [];
                            function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
                                if (debug.cancellation()) {
                                    var internal = new Promise(INTERNAL), _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
                                    this._promise = internal.lastly(function() {
                                        return _finallyPromise;
                                    }), internal._captureStackTrace(), internal._setOnCancel(this);
                                } else {
                                    (this._promise = new Promise(INTERNAL))._captureStackTrace();
                                }
                                this._stack = stack, this._generatorFunction = generatorFunction, this._receiver = receiver, 
                                this._generator = void 0, this._yieldHandlers = "function" == typeof yieldHandler ? [ yieldHandler ].concat(yieldHandlers) : yieldHandlers, 
                                this._yieldedPromise = null, this._cancellationPhase = !1;
                            }
                            util.inherits(PromiseSpawn, Proxyable), PromiseSpawn.prototype._isResolved = function() {
                                return null === this._promise;
                            }, PromiseSpawn.prototype._cleanup = function() {
                                this._promise = this._generator = null, debug.cancellation() && null !== this._finallyPromise && (this._finallyPromise._fulfill(), 
                                this._finallyPromise = null);
                            }, PromiseSpawn.prototype._promiseCancelled = function() {
                                if (!this._isResolved()) {
                                    var result;
                                    if (void 0 !== this._generator.return) this._promise._pushContext(), result = tryCatch(this._generator.return).call(this._generator, void 0), 
                                    this._promise._popContext(); else {
                                        var reason = new Promise.CancellationError("generator .return() sentinel");
                                        Promise.coroutine.returnSentinel = reason, this._promise._attachExtraTrace(reason), 
                                        this._promise._pushContext(), result = tryCatch(this._generator.throw).call(this._generator, reason), 
                                        this._promise._popContext();
                                    }
                                    this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(result);
                                }
                            }, PromiseSpawn.prototype._promiseFulfilled = function(value) {
                                this._yieldedPromise = null, this._promise._pushContext();
                                var result = tryCatch(this._generator.next).call(this._generator, value);
                                this._promise._popContext(), this._continue(result);
                            }, PromiseSpawn.prototype._promiseRejected = function(reason) {
                                this._yieldedPromise = null, this._promise._attachExtraTrace(reason), this._promise._pushContext();
                                var result = tryCatch(this._generator.throw).call(this._generator, reason);
                                this._promise._popContext(), this._continue(result);
                            }, PromiseSpawn.prototype._resultCancelled = function() {
                                if (this._yieldedPromise instanceof Promise) {
                                    var promise = this._yieldedPromise;
                                    this._yieldedPromise = null, promise.cancel();
                                }
                            }, PromiseSpawn.prototype.promise = function() {
                                return this._promise;
                            }, PromiseSpawn.prototype._run = function() {
                                this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, 
                                this._promiseFulfilled(void 0);
                            }, PromiseSpawn.prototype._continue = function(result) {
                                var promise = this._promise;
                                if (result === errorObj) return this._cleanup(), this._cancellationPhase ? promise.cancel() : promise._rejectCallback(result.e, !1);
                                var value = result.value;
                                if (!0 === result.done) return this._cleanup(), this._cancellationPhase ? promise.cancel() : promise._resolveCallback(value);
                                var maybePromise = tryConvertToPromise(value, this._promise);
                                if (maybePromise instanceof Promise || null !== (maybePromise = function(value, yieldHandlers, traceParent) {
                                    for (var i = 0; i < yieldHandlers.length; ++i) {
                                        traceParent._pushContext();
                                        var result = tryCatch(yieldHandlers[i])(value);
                                        if (traceParent._popContext(), result === errorObj) {
                                            traceParent._pushContext();
                                            var ret = Promise.reject(errorObj.e);
                                            return traceParent._popContext(), ret;
                                        }
                                        var maybePromise = tryConvertToPromise(result, traceParent);
                                        if (maybePromise instanceof Promise) return maybePromise;
                                    }
                                    return null;
                                }(maybePromise, this._yieldHandlers, this._promise))) {
                                    var bitField = (maybePromise = maybePromise._target())._bitField;
                                    0 == (50397184 & bitField) ? (this._yieldedPromise = maybePromise, maybePromise._proxy(this, null)) : 0 != (33554432 & bitField) ? Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value()) : 0 != (16777216 & bitField) ? Promise._async.invoke(this._promiseRejected, this, maybePromise._reason()) : this._promiseCancelled();
                                } else this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));
                            }, Promise.coroutine = function(generatorFunction, options) {
                                if ("function" != typeof generatorFunction) throw new TypeError("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
                                var yieldHandler = Object(options).yieldHandler, PromiseSpawn$ = PromiseSpawn, stack = new Error().stack;
                                return function() {
                                    var generator = generatorFunction.apply(this, arguments), spawn = new PromiseSpawn$(void 0, void 0, yieldHandler, stack), ret = spawn.promise();
                                    return spawn._generator = generator, spawn._promiseFulfilled(void 0), ret;
                                };
                            }, Promise.coroutine.addYieldHandler = function(fn) {
                                if ("function" != typeof fn) throw new TypeError("expecting a function but got " + util.classString(fn));
                                yieldHandlers.push(fn);
                            }, Promise.spawn = function(generatorFunction) {
                                if (debug.deprecated("Promise.spawn()", "Promise.coroutine()"), "function" != typeof generatorFunction) return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
                                var spawn = new PromiseSpawn(generatorFunction, this), ret = spawn.promise();
                                return spawn._run(Promise.spawn), ret;
                            };
                        };
                    }, {
                        "./errors": 12,
                        "./util": 36
                    } ],
                    17: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
                            var util = _dereq_("./util");
                            util.canEvaluate, util.tryCatch, util.errorObj;
                            Promise.join = function() {
                                var fn, last = arguments.length - 1;
                                last > 0 && "function" == typeof arguments[last] && (fn = arguments[last]);
                                var args = [].slice.call(arguments);
                                fn && args.pop();
                                var ret = new PromiseArray(args).promise();
                                return void 0 !== fn ? ret.spread(fn) : ret;
                            };
                        };
                    }, {
                        "./util": 36
                    } ],
                    18: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
                            var getDomain = Promise._getDomain, util = _dereq_("./util"), tryCatch = util.tryCatch, errorObj = util.errorObj, async = Promise._async;
                            function MappingPromiseArray(promises, fn, limit, _filter) {
                                this.constructor$(promises), this._promise._captureStackTrace();
                                var domain = getDomain();
                                this._callback = null === domain ? fn : util.domainBind(domain, fn), this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null, 
                                this._limit = limit, this._inFlight = 0, this._queue = [], async.invoke(this._asyncInit, this, void 0);
                            }
                            function map(promises, fn, options, _filter) {
                                if ("function" != typeof fn) return apiRejection("expecting a function but got " + util.classString(fn));
                                var limit = 0;
                                if (void 0 !== options) {
                                    if ("object" != typeof options || null === options) return Promise.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
                                    if ("number" != typeof options.concurrency) return Promise.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
                                    limit = options.concurrency;
                                }
                                return new MappingPromiseArray(promises, fn, limit = "number" == typeof limit && isFinite(limit) && limit >= 1 ? limit : 0, _filter).promise();
                            }
                            util.inherits(MappingPromiseArray, PromiseArray), MappingPromiseArray.prototype._asyncInit = function() {
                                this._init$(void 0, -2);
                            }, MappingPromiseArray.prototype._init = function() {}, MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
                                var values = this._values, length = this.length(), preservedValues = this._preservedValues, limit = this._limit;
                                if (index < 0) {
                                    if (values[index = -1 * index - 1] = value, limit >= 1 && (this._inFlight--, this._drainQueue(), 
                                    this._isResolved())) return !0;
                                } else {
                                    if (limit >= 1 && this._inFlight >= limit) return values[index] = value, this._queue.push(index), 
                                    !1;
                                    null !== preservedValues && (preservedValues[index] = value);
                                    var promise = this._promise, callback = this._callback, receiver = promise._boundValue();
                                    promise._pushContext();
                                    var ret = tryCatch(callback).call(receiver, value, index, length), promiseCreated = promise._popContext();
                                    if (debug.checkForgottenReturns(ret, promiseCreated, null !== preservedValues ? "Promise.filter" : "Promise.map", promise), 
                                    ret === errorObj) return this._reject(ret.e), !0;
                                    var maybePromise = tryConvertToPromise(ret, this._promise);
                                    if (maybePromise instanceof Promise) {
                                        var bitField = (maybePromise = maybePromise._target())._bitField;
                                        if (0 == (50397184 & bitField)) return limit >= 1 && this._inFlight++, values[index] = maybePromise, 
                                        maybePromise._proxy(this, -1 * (index + 1)), !1;
                                        if (0 == (33554432 & bitField)) return 0 != (16777216 & bitField) ? (this._reject(maybePromise._reason()), 
                                        !0) : (this._cancel(), !0);
                                        ret = maybePromise._value();
                                    }
                                    values[index] = ret;
                                }
                                return ++this._totalResolved >= length && (null !== preservedValues ? this._filter(values, preservedValues) : this._resolve(values), 
                                !0);
                            }, MappingPromiseArray.prototype._drainQueue = function() {
                                for (var queue = this._queue, limit = this._limit, values = this._values; queue.length > 0 && this._inFlight < limit; ) {
                                    if (this._isResolved()) return;
                                    var index = queue.pop();
                                    this._promiseFulfilled(values[index], index);
                                }
                            }, MappingPromiseArray.prototype._filter = function(booleans, values) {
                                for (var len = values.length, ret = new Array(len), j = 0, i = 0; i < len; ++i) booleans[i] && (ret[j++] = values[i]);
                                ret.length = j, this._resolve(ret);
                            }, MappingPromiseArray.prototype.preservedValues = function() {
                                return this._preservedValues;
                            }, Promise.prototype.map = function(fn, options) {
                                return map(this, fn, options, null);
                            }, Promise.map = function(promises, fn, options, _filter) {
                                return map(promises, fn, options, _filter);
                            };
                        };
                    }, {
                        "./util": 36
                    } ],
                    19: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
                            var util = _dereq_("./util"), tryCatch = util.tryCatch;
                            Promise.method = function(fn) {
                                if ("function" != typeof fn) throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
                                return function() {
                                    var ret = new Promise(INTERNAL);
                                    ret._captureStackTrace(), ret._pushContext();
                                    var value = tryCatch(fn).apply(this, arguments), promiseCreated = ret._popContext();
                                    return debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret), 
                                    ret._resolveFromSyncValue(value), ret;
                                };
                            }, Promise.attempt = Promise.try = function(fn) {
                                if ("function" != typeof fn) return apiRejection("expecting a function but got " + util.classString(fn));
                                var value, ret = new Promise(INTERNAL);
                                if (ret._captureStackTrace(), ret._pushContext(), arguments.length > 1) {
                                    debug.deprecated("calling Promise.try with more than 1 argument");
                                    var arg = arguments[1], ctx = arguments[2];
                                    value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
                                } else value = tryCatch(fn)();
                                var promiseCreated = ret._popContext();
                                return debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret), ret._resolveFromSyncValue(value), 
                                ret;
                            }, Promise.prototype._resolveFromSyncValue = function(value) {
                                value === util.errorObj ? this._rejectCallback(value.e, !1) : this._resolveCallback(value, !0);
                            };
                        };
                    }, {
                        "./util": 36
                    } ],
                    20: [ function(_dereq_, module, exports) {
                        "use strict";
                        var util = _dereq_("./util"), maybeWrapAsError = util.maybeWrapAsError, OperationalError = _dereq_("./errors").OperationalError, es5 = _dereq_("./es5");
                        var rErrorKey = /^(?:name|message|stack|cause)$/;
                        function wrapAsOperationalError(obj) {
                            var ret;
                            if (function(obj) {
                                return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
                            }(obj)) {
                                (ret = new OperationalError(obj)).name = obj.name, ret.message = obj.message, ret.stack = obj.stack;
                                for (var keys = es5.keys(obj), i = 0; i < keys.length; ++i) {
                                    var key = keys[i];
                                    rErrorKey.test(key) || (ret[key] = obj[key]);
                                }
                                return ret;
                            }
                            return util.markAsOriginatingFromRejection(obj), obj;
                        }
                        module.exports = function(promise, multiArgs) {
                            return function(err, value) {
                                if (null !== promise) {
                                    if (err) {
                                        var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
                                        promise._attachExtraTrace(wrapped), promise._reject(wrapped);
                                    } else if (multiArgs) {
                                        var args = [].slice.call(arguments, 1);
                                        promise._fulfill(args);
                                    } else promise._fulfill(value);
                                    promise = null;
                                }
                            };
                        };
                    }, {
                        "./errors": 12,
                        "./es5": 13,
                        "./util": 36
                    } ],
                    21: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise) {
                            var util = _dereq_("./util"), async = Promise._async, tryCatch = util.tryCatch, errorObj = util.errorObj;
                            function spreadAdapter(val, nodeback) {
                                if (!util.isArray(val)) return successAdapter.call(this, val, nodeback);
                                var ret = tryCatch(nodeback).apply(this._boundValue(), [ null ].concat(val));
                                ret === errorObj && async.throwLater(ret.e);
                            }
                            function successAdapter(val, nodeback) {
                                var receiver = this._boundValue(), ret = void 0 === val ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
                                ret === errorObj && async.throwLater(ret.e);
                            }
                            function errorAdapter(reason, nodeback) {
                                if (!reason) {
                                    var newReason = new Error(reason + "");
                                    newReason.cause = reason, reason = newReason;
                                }
                                var ret = tryCatch(nodeback).call(this._boundValue(), reason);
                                ret === errorObj && async.throwLater(ret.e);
                            }
                            Promise.prototype.asCallback = Promise.prototype.nodeify = function(nodeback, options) {
                                if ("function" == typeof nodeback) {
                                    var adapter = successAdapter;
                                    void 0 !== options && Object(options).spread && (adapter = spreadAdapter), this._then(adapter, errorAdapter, void 0, this, nodeback);
                                }
                                return this;
                            };
                        };
                    }, {
                        "./util": 36
                    } ],
                    22: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function() {
                            var makeSelfResolutionError = function() {
                                return new TypeError("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
                            }, reflectHandler = function() {
                                return new Promise.PromiseInspection(this._target());
                            }, apiRejection = function(msg) {
                                return Promise.reject(new TypeError(msg));
                            };
                            function Proxyable() {}
                            var getDomain, UNDEFINED_BINDING = {}, util = _dereq_("./util");
                            getDomain = util.isNode ? function() {
                                var ret = process.domain;
                                return void 0 === ret && (ret = null), ret;
                            } : function() {
                                return null;
                            }, util.notEnumerableProp(Promise, "_getDomain", getDomain);
                            var es5 = _dereq_("./es5"), Async = _dereq_("./async"), async = new Async();
                            es5.defineProperty(Promise, "_async", {
                                value: async
                            });
                            var errors = _dereq_("./errors"), TypeError = Promise.TypeError = errors.TypeError;
                            Promise.RangeError = errors.RangeError;
                            var CancellationError = Promise.CancellationError = errors.CancellationError;
                            Promise.TimeoutError = errors.TimeoutError, Promise.OperationalError = errors.OperationalError, 
                            Promise.RejectionError = errors.OperationalError, Promise.AggregateError = errors.AggregateError;
                            var INTERNAL = function() {}, APPLY = {}, NEXT_FILTER = {}, tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL), PromiseArray = _dereq_("./promise_array")(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable), Context = _dereq_("./context")(Promise), createContext = Context.create, debug = _dereq_("./debuggability")(Promise, Context), PassThroughHandlerContext = (debug.CapturedTrace, 
                            _dereq_("./finally")(Promise, tryConvertToPromise, NEXT_FILTER)), catchFilter = _dereq_("./catch_filter")(NEXT_FILTER), nodebackForPromise = _dereq_("./nodeback"), errorObj = util.errorObj, tryCatch = util.tryCatch;
                            function Promise(executor) {
                                executor !== INTERNAL && function(self, executor) {
                                    if (null == self || self.constructor !== Promise) throw new TypeError("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
                                    if ("function" != typeof executor) throw new TypeError("expecting a function but got " + util.classString(executor));
                                }(this, executor), this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, 
                                this._promise0 = void 0, this._receiver0 = void 0, this._resolveFromExecutor(executor), 
                                this._promiseCreated(), this._fireEvent("promiseCreated", this);
                            }
                            function deferResolve(v) {
                                this.promise._resolveCallback(v);
                            }
                            function deferReject(v) {
                                this.promise._rejectCallback(v, !1);
                            }
                            function fillTypes(value) {
                                var p = new Promise(INTERNAL);
                                p._fulfillmentHandler0 = value, p._rejectionHandler0 = value, p._promise0 = value, 
                                p._receiver0 = value;
                            }
                            // Complete slack tracking, opt out of field-type tracking and           
                            // stabilize map                                                         
                                                        return Promise.prototype.toString = function() {
                                return "[object Promise]";
                            }, Promise.prototype.caught = Promise.prototype.catch = function(fn) {
                                var len = arguments.length;
                                if (len > 1) {
                                    var i, catchInstances = new Array(len - 1), j = 0;
                                    for (i = 0; i < len - 1; ++i) {
                                        var item = arguments[i];
                                        if (!util.isObject(item)) return apiRejection("Catch statement predicate: expecting an object but got " + util.classString(item));
                                        catchInstances[j++] = item;
                                    }
                                    return catchInstances.length = j, fn = arguments[i], this.then(void 0, catchFilter(catchInstances, fn, this));
                                }
                                return this.then(void 0, fn);
                            }, Promise.prototype.reflect = function() {
                                return this._then(reflectHandler, reflectHandler, void 0, this, void 0);
                            }, Promise.prototype.then = function(didFulfill, didReject) {
                                if (debug.warnings() && arguments.length > 0 && "function" != typeof didFulfill && "function" != typeof didReject) {
                                    var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
                                    arguments.length > 1 && (msg += ", " + util.classString(didReject)), this._warn(msg);
                                }
                                return this._then(didFulfill, didReject, void 0, void 0, void 0);
                            }, Promise.prototype.done = function(didFulfill, didReject) {
                                this._then(didFulfill, didReject, void 0, void 0, void 0)._setIsFinal();
                            }, Promise.prototype.spread = function(fn) {
                                return "function" != typeof fn ? apiRejection("expecting a function but got " + util.classString(fn)) : this.all()._then(fn, void 0, void 0, APPLY, void 0);
                            }, Promise.prototype.toJSON = function() {
                                var ret = {
                                    isFulfilled: !1,
                                    isRejected: !1,
                                    fulfillmentValue: void 0,
                                    rejectionReason: void 0
                                };
                                return this.isFulfilled() ? (ret.fulfillmentValue = this.value(), ret.isFulfilled = !0) : this.isRejected() && (ret.rejectionReason = this.reason(), 
                                ret.isRejected = !0), ret;
                            }, Promise.prototype.all = function() {
                                return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), 
                                new PromiseArray(this).promise();
                            }, Promise.prototype.error = function(fn) {
                                return this.caught(util.originatesFromRejection, fn);
                            }, Promise.getNewLibraryCopy = module.exports, Promise.is = function(val) {
                                return val instanceof Promise;
                            }, Promise.fromNode = Promise.fromCallback = function(fn) {
                                var ret = new Promise(INTERNAL);
                                ret._captureStackTrace();
                                var multiArgs = arguments.length > 1 && !!Object(arguments[1]).multiArgs, result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
                                return result === errorObj && ret._rejectCallback(result.e, !0), ret._isFateSealed() || ret._setAsyncGuaranteed(), 
                                ret;
                            }, Promise.all = function(promises) {
                                return new PromiseArray(promises).promise();
                            }, Promise.cast = function(obj) {
                                var ret = tryConvertToPromise(obj);
                                return ret instanceof Promise || ((ret = new Promise(INTERNAL))._captureStackTrace(), 
                                ret._setFulfilled(), ret._rejectionHandler0 = obj), ret;
                            }, Promise.resolve = Promise.fulfilled = Promise.cast, Promise.reject = Promise.rejected = function(reason) {
                                var ret = new Promise(INTERNAL);
                                return ret._captureStackTrace(), ret._rejectCallback(reason, !0), ret;
                            }, Promise.setScheduler = function(fn) {
                                if ("function" != typeof fn) throw new TypeError("expecting a function but got " + util.classString(fn));
                                return async.setScheduler(fn);
                            }, Promise.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
                                var haveInternalData = void 0 !== internalData, promise = haveInternalData ? internalData : new Promise(INTERNAL), target = this._target(), bitField = target._bitField;
                                haveInternalData || (promise._propagateFrom(this, 3), promise._captureStackTrace(), 
                                void 0 === receiver && 0 != (2097152 & this._bitField) && (receiver = 0 != (50397184 & bitField) ? this._boundValue() : target === this ? void 0 : this._boundTo), 
                                this._fireEvent("promiseChained", this, promise));
                                var domain = getDomain();
                                if (0 != (50397184 & bitField)) {
                                    var handler, value, settler = target._settlePromiseCtx;
                                    0 != (33554432 & bitField) ? (value = target._rejectionHandler0, handler = didFulfill) : 0 != (16777216 & bitField) ? (value = target._fulfillmentHandler0, 
                                    handler = didReject, target._unsetRejectionIsUnhandled()) : (settler = target._settlePromiseLateCancellationObserver, 
                                    value = new CancellationError("late cancellation observer"), target._attachExtraTrace(value), 
                                    handler = didReject), async.invoke(settler, target, {
                                        handler: null === domain ? handler : "function" == typeof handler && util.domainBind(domain, handler),
                                        promise: promise,
                                        receiver: receiver,
                                        value: value
                                    });
                                } else target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
                                return promise;
                            }, Promise.prototype._length = function() {
                                return 65535 & this._bitField;
                            }, Promise.prototype._isFateSealed = function() {
                                return 0 != (117506048 & this._bitField);
                            }, Promise.prototype._isFollowing = function() {
                                return 67108864 == (67108864 & this._bitField);
                            }, Promise.prototype._setLength = function(len) {
                                this._bitField = -65536 & this._bitField | 65535 & len;
                            }, Promise.prototype._setFulfilled = function() {
                                this._bitField = 33554432 | this._bitField, this._fireEvent("promiseFulfilled", this);
                            }, Promise.prototype._setRejected = function() {
                                this._bitField = 16777216 | this._bitField, this._fireEvent("promiseRejected", this);
                            }, Promise.prototype._setFollowing = function() {
                                this._bitField = 67108864 | this._bitField, this._fireEvent("promiseResolved", this);
                            }, Promise.prototype._setIsFinal = function() {
                                this._bitField = 4194304 | this._bitField;
                            }, Promise.prototype._isFinal = function() {
                                return (4194304 & this._bitField) > 0;
                            }, Promise.prototype._unsetCancelled = function() {
                                this._bitField = -65537 & this._bitField;
                            }, Promise.prototype._setCancelled = function() {
                                this._bitField = 65536 | this._bitField, this._fireEvent("promiseCancelled", this);
                            }, Promise.prototype._setWillBeCancelled = function() {
                                this._bitField = 8388608 | this._bitField;
                            }, Promise.prototype._setAsyncGuaranteed = function() {
                                async.hasCustomScheduler() || (this._bitField = 134217728 | this._bitField);
                            }, Promise.prototype._receiverAt = function(index) {
                                var ret = 0 === index ? this._receiver0 : this[4 * index - 4 + 3];
                                if (ret !== UNDEFINED_BINDING) return void 0 === ret && this._isBound() ? this._boundValue() : ret;
                            }, Promise.prototype._promiseAt = function(index) {
                                return this[4 * index - 4 + 2];
                            }, Promise.prototype._fulfillmentHandlerAt = function(index) {
                                return this[4 * index - 4 + 0];
                            }, Promise.prototype._rejectionHandlerAt = function(index) {
                                return this[4 * index - 4 + 1];
                            }, Promise.prototype._boundValue = function() {}, Promise.prototype._migrateCallback0 = function(follower) {
                                follower._bitField;
                                var fulfill = follower._fulfillmentHandler0, reject = follower._rejectionHandler0, promise = follower._promise0, receiver = follower._receiverAt(0);
                                void 0 === receiver && (receiver = UNDEFINED_BINDING), this._addCallbacks(fulfill, reject, promise, receiver, null);
                            }, Promise.prototype._migrateCallbackAt = function(follower, index) {
                                var fulfill = follower._fulfillmentHandlerAt(index), reject = follower._rejectionHandlerAt(index), promise = follower._promiseAt(index), receiver = follower._receiverAt(index);
                                void 0 === receiver && (receiver = UNDEFINED_BINDING), this._addCallbacks(fulfill, reject, promise, receiver, null);
                            }, Promise.prototype._addCallbacks = function(fulfill, reject, promise, receiver, domain) {
                                var index = this._length();
                                if (index >= 65531 && (index = 0, this._setLength(0)), 0 === index) this._promise0 = promise, 
                                this._receiver0 = receiver, "function" == typeof fulfill && (this._fulfillmentHandler0 = null === domain ? fulfill : util.domainBind(domain, fulfill)), 
                                "function" == typeof reject && (this._rejectionHandler0 = null === domain ? reject : util.domainBind(domain, reject)); else {
                                    var base = 4 * index - 4;
                                    this[base + 2] = promise, this[base + 3] = receiver, "function" == typeof fulfill && (this[base + 0] = null === domain ? fulfill : util.domainBind(domain, fulfill)), 
                                    "function" == typeof reject && (this[base + 1] = null === domain ? reject : util.domainBind(domain, reject));
                                }
                                return this._setLength(index + 1), index;
                            }, Promise.prototype._proxy = function(proxyable, arg) {
                                this._addCallbacks(void 0, void 0, arg, proxyable, null);
                            }, Promise.prototype._resolveCallback = function(value, shouldBind) {
                                if (0 == (117506048 & this._bitField)) {
                                    if (value === this) return this._rejectCallback(makeSelfResolutionError(), !1);
                                    var maybePromise = tryConvertToPromise(value, this);
                                    if (!(maybePromise instanceof Promise)) return this._fulfill(value);
                                    shouldBind && this._propagateFrom(maybePromise, 2);
                                    var promise = maybePromise._target();
                                    if (promise !== this) {
                                        var bitField = promise._bitField;
                                        if (0 == (50397184 & bitField)) {
                                            var len = this._length();
                                            len > 0 && promise._migrateCallback0(this);
                                            for (var i = 1; i < len; ++i) promise._migrateCallbackAt(this, i);
                                            this._setFollowing(), this._setLength(0), this._setFollowee(promise);
                                        } else if (0 != (33554432 & bitField)) this._fulfill(promise._value()); else if (0 != (16777216 & bitField)) this._reject(promise._reason()); else {
                                            var reason = new CancellationError("late cancellation observer");
                                            promise._attachExtraTrace(reason), this._reject(reason);
                                        }
                                    } else this._reject(makeSelfResolutionError());
                                }
                            }, Promise.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
                                var trace = util.ensureErrorObject(reason), hasStack = trace === reason;
                                if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
                                    var message = "a promise was rejected with a non-error: " + util.classString(reason);
                                    this._warn(message, !0);
                                }
                                this._attachExtraTrace(trace, !!synchronous && hasStack), this._reject(reason);
                            }, Promise.prototype._resolveFromExecutor = function(executor) {
                                if (executor !== INTERNAL) {
                                    var promise = this;
                                    this._captureStackTrace(), this._pushContext();
                                    var synchronous = !0, r = this._execute(executor, function(value) {
                                        promise._resolveCallback(value);
                                    }, function(reason) {
                                        promise._rejectCallback(reason, synchronous);
                                    });
                                    synchronous = !1, this._popContext(), void 0 !== r && promise._rejectCallback(r, !0);
                                }
                            }, Promise.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
                                var bitField = promise._bitField;
                                if (0 == (65536 & bitField)) {
                                    var x;
                                    promise._pushContext(), receiver === APPLY ? value && "number" == typeof value.length ? x = tryCatch(handler).apply(this._boundValue(), value) : (x = errorObj).e = new TypeError("cannot .spread() a non-array: " + util.classString(value)) : x = tryCatch(handler).call(receiver, value);
                                    var promiseCreated = promise._popContext();
                                    0 == (65536 & (bitField = promise._bitField)) && (x === NEXT_FILTER ? promise._reject(value) : x === errorObj ? promise._rejectCallback(x.e, !1) : (debug.checkForgottenReturns(x, promiseCreated, "", promise, this), 
                                    promise._resolveCallback(x)));
                                }
                            }, Promise.prototype._target = function() {
                                for (var ret = this; ret._isFollowing(); ) ret = ret._followee();
                                return ret;
                            }, Promise.prototype._followee = function() {
                                return this._rejectionHandler0;
                            }, Promise.prototype._setFollowee = function(promise) {
                                this._rejectionHandler0 = promise;
                            }, Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
                                var isPromise = promise instanceof Promise, bitField = this._bitField, asyncGuaranteed = 0 != (134217728 & bitField);
                                0 != (65536 & bitField) ? (isPromise && promise._invokeInternalOnCancel(), receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler() ? (receiver.cancelPromise = promise, 
                                tryCatch(handler).call(receiver, value) === errorObj && promise._reject(errorObj.e)) : handler === reflectHandler ? promise._fulfill(reflectHandler.call(receiver)) : receiver instanceof Proxyable ? receiver._promiseCancelled(promise) : isPromise || promise instanceof PromiseArray ? promise._cancel() : receiver.cancel()) : "function" == typeof handler ? isPromise ? (asyncGuaranteed && promise._setAsyncGuaranteed(), 
                                this._settlePromiseFromHandler(handler, receiver, value, promise)) : handler.call(receiver, value, promise) : receiver instanceof Proxyable ? receiver._isResolved() || (0 != (33554432 & bitField) ? receiver._promiseFulfilled(value, promise) : receiver._promiseRejected(value, promise)) : isPromise && (asyncGuaranteed && promise._setAsyncGuaranteed(), 
                                0 != (33554432 & bitField) ? promise._fulfill(value) : promise._reject(value));
                            }, Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
                                var handler = ctx.handler, promise = ctx.promise, receiver = ctx.receiver, value = ctx.value;
                                "function" == typeof handler ? promise instanceof Promise ? this._settlePromiseFromHandler(handler, receiver, value, promise) : handler.call(receiver, value, promise) : promise instanceof Promise && promise._reject(value);
                            }, Promise.prototype._settlePromiseCtx = function(ctx) {
                                this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
                            }, Promise.prototype._settlePromise0 = function(handler, value, bitField) {
                                var promise = this._promise0, receiver = this._receiverAt(0);
                                this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(promise, handler, receiver, value);
                            }, Promise.prototype._clearCallbackDataAtIndex = function(index) {
                                var base = 4 * index - 4;
                                this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
                            }, Promise.prototype._fulfill = function(value) {
                                var bitField = this._bitField;
                                if (!((117506048 & bitField) >>> 16)) {
                                    if (value === this) {
                                        var err = makeSelfResolutionError();
                                        return this._attachExtraTrace(err), this._reject(err);
                                    }
                                    this._setFulfilled(), this._rejectionHandler0 = value, (65535 & bitField) > 0 && (0 != (134217728 & bitField) ? this._settlePromises() : async.settlePromises(this));
                                }
                            }, Promise.prototype._reject = function(reason) {
                                var bitField = this._bitField;
                                if (!((117506048 & bitField) >>> 16)) {
                                    if (this._setRejected(), this._fulfillmentHandler0 = reason, this._isFinal()) return async.fatalError(reason, util.isNode);
                                    (65535 & bitField) > 0 ? async.settlePromises(this) : this._ensurePossibleRejectionHandled();
                                }
                            }, Promise.prototype._fulfillPromises = function(len, value) {
                                for (var i = 1; i < len; i++) {
                                    var handler = this._fulfillmentHandlerAt(i), promise = this._promiseAt(i), receiver = this._receiverAt(i);
                                    this._clearCallbackDataAtIndex(i), this._settlePromise(promise, handler, receiver, value);
                                }
                            }, Promise.prototype._rejectPromises = function(len, reason) {
                                for (var i = 1; i < len; i++) {
                                    var handler = this._rejectionHandlerAt(i), promise = this._promiseAt(i), receiver = this._receiverAt(i);
                                    this._clearCallbackDataAtIndex(i), this._settlePromise(promise, handler, receiver, reason);
                                }
                            }, Promise.prototype._settlePromises = function() {
                                var bitField = this._bitField, len = 65535 & bitField;
                                if (len > 0) {
                                    if (0 != (16842752 & bitField)) {
                                        var reason = this._fulfillmentHandler0;
                                        this._settlePromise0(this._rejectionHandler0, reason, bitField), this._rejectPromises(len, reason);
                                    } else {
                                        var value = this._rejectionHandler0;
                                        this._settlePromise0(this._fulfillmentHandler0, value, bitField), this._fulfillPromises(len, value);
                                    }
                                    this._setLength(0);
                                }
                                this._clearCancellationData();
                            }, Promise.prototype._settledValue = function() {
                                var bitField = this._bitField;
                                return 0 != (33554432 & bitField) ? this._rejectionHandler0 : 0 != (16777216 & bitField) ? this._fulfillmentHandler0 : void 0;
                            }, Promise.defer = Promise.pending = function() {
                                return debug.deprecated("Promise.defer", "new Promise"), {
                                    promise: new Promise(INTERNAL),
                                    resolve: deferResolve,
                                    reject: deferReject
                                };
                            }, util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError), 
                            _dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug), 
                            _dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug), _dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug), 
                            _dereq_("./direct_resolve")(Promise), _dereq_("./synchronous_inspection")(Promise), 
                            _dereq_("./join")(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain), 
                            Promise.Promise = Promise, Promise.version = "3.5.1", _dereq_("./map.js")(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug), 
                            _dereq_("./call_get.js")(Promise), _dereq_("./using.js")(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug), 
                            _dereq_("./timers.js")(Promise, INTERNAL, debug), _dereq_("./generators.js")(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug), 
                            _dereq_("./nodeify.js")(Promise), _dereq_("./promisify.js")(Promise, INTERNAL), 
                            _dereq_("./props.js")(Promise, PromiseArray, tryConvertToPromise, apiRejection), 
                            _dereq_("./race.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection), _dereq_("./reduce.js")(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug), 
                            _dereq_("./settle.js")(Promise, PromiseArray, debug), _dereq_("./some.js")(Promise, PromiseArray, apiRejection), 
                            _dereq_("./filter.js")(Promise, INTERNAL), _dereq_("./each.js")(Promise, INTERNAL), 
                            _dereq_("./any.js")(Promise), util.toFastProperties(Promise), util.toFastProperties(Promise.prototype), 
                            fillTypes({
                                a: 1
                            }), fillTypes({
                                b: 2
                            }), fillTypes({
                                c: 3
                            }), fillTypes(1), fillTypes(function() {}), fillTypes(void 0), fillTypes(!1), fillTypes(new Promise(INTERNAL)), 
                            debug.setBounds(Async.firstLineError, util.lastLineError), Promise;
                        };
                    }, {
                        "./any.js": 1,
                        "./async": 2,
                        "./bind": 3,
                        "./call_get.js": 5,
                        "./cancel": 6,
                        "./catch_filter": 7,
                        "./context": 8,
                        "./debuggability": 9,
                        "./direct_resolve": 10,
                        "./each.js": 11,
                        "./errors": 12,
                        "./es5": 13,
                        "./filter.js": 14,
                        "./finally": 15,
                        "./generators.js": 16,
                        "./join": 17,
                        "./map.js": 18,
                        "./method": 19,
                        "./nodeback": 20,
                        "./nodeify.js": 21,
                        "./promise_array": 23,
                        "./promisify.js": 24,
                        "./props.js": 25,
                        "./race.js": 27,
                        "./reduce.js": 28,
                        "./settle.js": 30,
                        "./some.js": 31,
                        "./synchronous_inspection": 32,
                        "./thenables": 33,
                        "./timers.js": 34,
                        "./using.js": 35,
                        "./util": 36
                    } ],
                    23: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
                            var util = _dereq_("./util");
                            util.isArray;
                            function PromiseArray(values) {
                                var promise = this._promise = new Promise(INTERNAL);
                                values instanceof Promise && promise._propagateFrom(values, 3), promise._setOnCancel(this), 
                                this._values = values, this._length = 0, this._totalResolved = 0, this._init(void 0, -2);
                            }
                            return util.inherits(PromiseArray, Proxyable), PromiseArray.prototype.length = function() {
                                return this._length;
                            }, PromiseArray.prototype.promise = function() {
                                return this._promise;
                            }, PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
                                var values = tryConvertToPromise(this._values, this._promise);
                                if (values instanceof Promise) {
                                    var bitField = (values = values._target())._bitField;
                                    if (this._values = values, 0 == (50397184 & bitField)) return this._promise._setAsyncGuaranteed(), 
                                    values._then(init, this._reject, void 0, this, resolveValueIfEmpty);
                                    if (0 == (33554432 & bitField)) return 0 != (16777216 & bitField) ? this._reject(values._reason()) : this._cancel();
                                    values = values._value();
                                }
                                if (null !== (values = util.asArray(values))) 0 !== values.length ? this._iterate(values) : -5 === resolveValueIfEmpty ? this._resolveEmptyArray() : this._resolve(function(val) {
                                    switch (val) {
                                      case -2:
                                        return [];

                                      case -3:
                                        return {};

                                      case -6:
                                        return new Map();
                                    }
                                }(resolveValueIfEmpty)); else {
                                    var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
                                    this._promise._rejectCallback(err, !1);
                                }
                            }, PromiseArray.prototype._iterate = function(values) {
                                var len = this.getActualLength(values.length);
                                this._length = len, this._values = this.shouldCopyValues() ? new Array(len) : this._values;
                                for (var result = this._promise, isResolved = !1, bitField = null, i = 0; i < len; ++i) {
                                    var maybePromise = tryConvertToPromise(values[i], result);
                                    bitField = maybePromise instanceof Promise ? (maybePromise = maybePromise._target())._bitField : null, 
                                    isResolved ? null !== bitField && maybePromise.suppressUnhandledRejections() : null !== bitField ? 0 == (50397184 & bitField) ? (maybePromise._proxy(this, i), 
                                    this._values[i] = maybePromise) : isResolved = 0 != (33554432 & bitField) ? this._promiseFulfilled(maybePromise._value(), i) : 0 != (16777216 & bitField) ? this._promiseRejected(maybePromise._reason(), i) : this._promiseCancelled(i) : isResolved = this._promiseFulfilled(maybePromise, i);
                                }
                                isResolved || result._setAsyncGuaranteed();
                            }, PromiseArray.prototype._isResolved = function() {
                                return null === this._values;
                            }, PromiseArray.prototype._resolve = function(value) {
                                this._values = null, this._promise._fulfill(value);
                            }, PromiseArray.prototype._cancel = function() {
                                !this._isResolved() && this._promise._isCancellable() && (this._values = null, this._promise._cancel());
                            }, PromiseArray.prototype._reject = function(reason) {
                                this._values = null, this._promise._rejectCallback(reason, !1);
                            }, PromiseArray.prototype._promiseFulfilled = function(value, index) {
                                return this._values[index] = value, ++this._totalResolved >= this._length && (this._resolve(this._values), 
                                !0);
                            }, PromiseArray.prototype._promiseCancelled = function() {
                                return this._cancel(), !0;
                            }, PromiseArray.prototype._promiseRejected = function(reason) {
                                return this._totalResolved++, this._reject(reason), !0;
                            }, PromiseArray.prototype._resultCancelled = function() {
                                if (!this._isResolved()) {
                                    var values = this._values;
                                    if (this._cancel(), values instanceof Promise) values.cancel(); else for (var i = 0; i < values.length; ++i) values[i] instanceof Promise && values[i].cancel();
                                }
                            }, PromiseArray.prototype.shouldCopyValues = function() {
                                return !0;
                            }, PromiseArray.prototype.getActualLength = function(len) {
                                return len;
                            }, PromiseArray;
                        };
                    }, {
                        "./util": 36
                    } ],
                    24: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, INTERNAL) {
                            var THIS = {}, util = _dereq_("./util"), nodebackForPromise = _dereq_("./nodeback"), withAppended = util.withAppended, maybeWrapAsError = util.maybeWrapAsError, canEvaluate = util.canEvaluate, TypeError = _dereq_("./errors").TypeError, defaultPromisified = {
                                __isPromisified__: !0
                            }, noCopyPropsPattern = new RegExp("^(?:" + [ "arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__" ].join("|") + ")$"), defaultFilter = function(name) {
                                return util.isIdentifier(name) && "_" !== name.charAt(0) && "constructor" !== name;
                            };
                            function propsFilter(key) {
                                return !noCopyPropsPattern.test(key);
                            }
                            function isPromisified(fn) {
                                try {
                                    return !0 === fn.__isPromisified__;
                                } catch (e) {
                                    return !1;
                                }
                            }
                            function hasPromisified(obj, key, suffix) {
                                var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
                                return !!val && isPromisified(val);
                            }
                            function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
                                for (var keys = util.inheritedDataKeys(obj), ret = [], i = 0; i < keys.length; ++i) {
                                    var key = keys[i], value = obj[key], passesDefaultFilter = filter === defaultFilter || defaultFilter(key, value, obj);
                                    "function" != typeof value || isPromisified(value) || hasPromisified(obj, key, suffix) || !filter(key, value, obj, passesDefaultFilter) || ret.push(key, value);
                                }
                                return function(ret, suffix, suffixRegexp) {
                                    for (var i = 0; i < ret.length; i += 2) {
                                        var key = ret[i];
                                        if (suffixRegexp.test(key)) for (var keyWithoutAsyncSuffix = key.replace(suffixRegexp, ""), j = 0; j < ret.length; j += 2) if (ret[j] === keyWithoutAsyncSuffix) throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
                                    }
                                }(ret, suffix, suffixRegexp), ret;
                            }
                            var makeNodePromisifiedEval, escapeIdentRegex = function(str) {
                                return str.replace(/([$])/, "\\$");
                            };
                            var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : function(callback, receiver, _, fn, __, multiArgs) {
                                var defaultThis = function() {
                                    return this;
                                }(), method = callback;
                                function promisified() {
                                    var _receiver = receiver;
                                    receiver === THIS && (_receiver = this);
                                    var promise = new Promise(INTERNAL);
                                    promise._captureStackTrace();
                                    var cb = "string" == typeof method && this !== defaultThis ? this[method] : callback, fn = nodebackForPromise(promise, multiArgs);
                                    try {
                                        cb.apply(_receiver, withAppended(arguments, fn));
                                    } catch (e) {
                                        promise._rejectCallback(maybeWrapAsError(e), !0, !0);
                                    }
                                    return promise._isFateSealed() || promise._setAsyncGuaranteed(), promise;
                                }
                                return "string" == typeof method && (callback = fn), util.notEnumerableProp(promisified, "__isPromisified__", !0), 
                                promisified;
                            };
                            function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
                                for (var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$"), methods = promisifiableMethods(obj, suffix, suffixRegexp, filter), i = 0, len = methods.length; i < len; i += 2) {
                                    var key = methods[i], fn = methods[i + 1], promisifiedKey = key + suffix;
                                    if (promisifier === makeNodePromisified) obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs); else {
                                        var promisified = promisifier(fn, function() {
                                            return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
                                        });
                                        util.notEnumerableProp(promisified, "__isPromisified__", !0), obj[promisifiedKey] = promisified;
                                    }
                                }
                                return util.toFastProperties(obj), obj;
                            }
                            Promise.promisify = function(fn, options) {
                                if ("function" != typeof fn) throw new TypeError("expecting a function but got " + util.classString(fn));
                                if (isPromisified(fn)) return fn;
                                var ret = function(callback, receiver, multiArgs) {
                                    return makeNodePromisified(callback, receiver, void 0, callback, null, multiArgs);
                                }(fn, void 0 === (options = Object(options)).context ? THIS : options.context, !!options.multiArgs);
                                return util.copyDescriptors(fn, ret, propsFilter), ret;
                            }, Promise.promisifyAll = function(target, options) {
                                if ("function" != typeof target && "object" != typeof target) throw new TypeError("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
                                var multiArgs = !!(options = Object(options)).multiArgs, suffix = options.suffix;
                                "string" != typeof suffix && (suffix = "Async");
                                var filter = options.filter;
                                "function" != typeof filter && (filter = defaultFilter);
                                var promisifier = options.promisifier;
                                if ("function" != typeof promisifier && (promisifier = makeNodePromisified), !util.isIdentifier(suffix)) throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
                                for (var keys = util.inheritedDataKeys(target), i = 0; i < keys.length; ++i) {
                                    var value = target[keys[i]];
                                    "constructor" !== keys[i] && util.isClass(value) && (promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs), 
                                    promisifyAll(value, suffix, filter, promisifier, multiArgs));
                                }
                                return promisifyAll(target, suffix, filter, promisifier, multiArgs);
                            };
                        };
                    }, {
                        "./errors": 12,
                        "./nodeback": 20,
                        "./util": 36
                    } ],
                    25: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, PromiseArray, tryConvertToPromise, apiRejection) {
                            var Es6Map, util = _dereq_("./util"), isObject = util.isObject, es5 = _dereq_("./es5");
                            "function" == typeof Map && (Es6Map = Map);
                            var mapToEntries = function() {
                                var index = 0, size = 0;
                                function extractEntry(value, key) {
                                    this[index] = value, this[index + size] = key, index++;
                                }
                                return function(map) {
                                    size = map.size, index = 0;
                                    var ret = new Array(2 * map.size);
                                    return map.forEach(extractEntry, ret), ret;
                                };
                            }();
                            function PropertiesPromiseArray(obj) {
                                var entries, isMap = !1;
                                if (void 0 !== Es6Map && obj instanceof Es6Map) entries = mapToEntries(obj), isMap = !0; else {
                                    var keys = es5.keys(obj), len = keys.length;
                                    entries = new Array(2 * len);
                                    for (var i = 0; i < len; ++i) {
                                        var key = keys[i];
                                        entries[i] = obj[key], entries[i + len] = key;
                                    }
                                }
                                this.constructor$(entries), this._isMap = isMap, this._init$(void 0, isMap ? -6 : -3);
                            }
                            function props(promises) {
                                var ret, castValue = tryConvertToPromise(promises);
                                return isObject(castValue) ? (ret = castValue instanceof Promise ? castValue._then(Promise.props, void 0, void 0, void 0, void 0) : new PropertiesPromiseArray(castValue).promise(), 
                                castValue instanceof Promise && ret._propagateFrom(castValue, 2), ret) : apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
                            }
                            util.inherits(PropertiesPromiseArray, PromiseArray), PropertiesPromiseArray.prototype._init = function() {}, 
                            PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
                                if (this._values[index] = value, ++this._totalResolved >= this._length) {
                                    var val;
                                    if (this._isMap) val = function(entries) {
                                        for (var ret = new Es6Map(), length = entries.length / 2 | 0, i = 0; i < length; ++i) {
                                            var key = entries[length + i], value = entries[i];
                                            ret.set(key, value);
                                        }
                                        return ret;
                                    }(this._values); else {
                                        val = {};
                                        for (var keyOffset = this.length(), i = 0, len = this.length(); i < len; ++i) val[this._values[i + keyOffset]] = this._values[i];
                                    }
                                    return this._resolve(val), !0;
                                }
                                return !1;
                            }, PropertiesPromiseArray.prototype.shouldCopyValues = function() {
                                return !1;
                            }, PropertiesPromiseArray.prototype.getActualLength = function(len) {
                                return len >> 1;
                            }, Promise.prototype.props = function() {
                                return props(this);
                            }, Promise.props = function(promises) {
                                return props(promises);
                            };
                        };
                    }, {
                        "./es5": 13,
                        "./util": 36
                    } ],
                    26: [ function(_dereq_, module, exports) {
                        "use strict";
                        function Queue(capacity) {
                            this._capacity = capacity, this._length = 0, this._front = 0;
                        }
                        Queue.prototype._willBeOverCapacity = function(size) {
                            return this._capacity < size;
                        }, Queue.prototype._pushOne = function(arg) {
                            var length = this.length();
                            this._checkCapacity(length + 1), this[this._front + length & this._capacity - 1] = arg, 
                            this._length = length + 1;
                        }, Queue.prototype.push = function(fn, receiver, arg) {
                            var length = this.length() + 3;
                            if (this._willBeOverCapacity(length)) return this._pushOne(fn), this._pushOne(receiver), 
                            void this._pushOne(arg);
                            var j = this._front + length - 3;
                            this._checkCapacity(length);
                            var wrapMask = this._capacity - 1;
                            this[j + 0 & wrapMask] = fn, this[j + 1 & wrapMask] = receiver, this[j + 2 & wrapMask] = arg, 
                            this._length = length;
                        }, Queue.prototype.shift = function() {
                            var front = this._front, ret = this[front];
                            return this[front] = void 0, this._front = front + 1 & this._capacity - 1, this._length--, 
                            ret;
                        }, Queue.prototype.length = function() {
                            return this._length;
                        }, Queue.prototype._checkCapacity = function(size) {
                            this._capacity < size && this._resizeTo(this._capacity << 1);
                        }, Queue.prototype._resizeTo = function(capacity) {
                            var oldCapacity = this._capacity;
                            this._capacity = capacity, function(src, srcIndex, dst, dstIndex, len) {
                                for (var j = 0; j < len; ++j) dst[j + dstIndex] = src[j + srcIndex], src[j + srcIndex] = void 0;
                            }(this, 0, this, oldCapacity, this._front + this._length & oldCapacity - 1);
                        }, module.exports = Queue;
                    }, {} ],
                    27: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
                            var util = _dereq_("./util"), raceLater = function(promise) {
                                return promise.then(function(array) {
                                    return race(array, promise);
                                });
                            };
                            function race(promises, parent) {
                                var maybePromise = tryConvertToPromise(promises);
                                if (maybePromise instanceof Promise) return raceLater(maybePromise);
                                if (null === (promises = util.asArray(promises))) return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
                                var ret = new Promise(INTERNAL);
                                void 0 !== parent && ret._propagateFrom(parent, 3);
                                for (var fulfill = ret._fulfill, reject = ret._reject, i = 0, len = promises.length; i < len; ++i) {
                                    var val = promises[i];
                                    (void 0 !== val || i in promises) && Promise.cast(val)._then(fulfill, reject, void 0, ret, null);
                                }
                                return ret;
                            }
                            Promise.race = function(promises) {
                                return race(promises, void 0);
                            }, Promise.prototype.race = function() {
                                return race(this, void 0);
                            };
                        };
                    }, {
                        "./util": 36
                    } ],
                    28: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
                            var getDomain = Promise._getDomain, util = _dereq_("./util"), tryCatch = util.tryCatch;
                            function ReductionPromiseArray(promises, fn, initialValue, _each) {
                                this.constructor$(promises);
                                var domain = getDomain();
                                this._fn = null === domain ? fn : util.domainBind(domain, fn), void 0 !== initialValue && (initialValue = Promise.resolve(initialValue))._attachCancellationCallback(this), 
                                this._initialValue = initialValue, this._currentCancellable = null, this._eachValues = _each === INTERNAL ? Array(this._length) : 0 === _each ? null : void 0, 
                                this._promise._captureStackTrace(), this._init$(void 0, -5);
                            }
                            function completed(valueOrReason, array) {
                                this.isFulfilled() ? array._resolve(valueOrReason) : array._reject(valueOrReason);
                            }
                            function reduce(promises, fn, initialValue, _each) {
                                return "function" != typeof fn ? apiRejection("expecting a function but got " + util.classString(fn)) : new ReductionPromiseArray(promises, fn, initialValue, _each).promise();
                            }
                            function gotAccum(accum) {
                                this.accum = accum, this.array._gotAccum(accum);
                                var value = tryConvertToPromise(this.value, this.array._promise);
                                return value instanceof Promise ? (this.array._currentCancellable = value, value._then(gotValue, void 0, void 0, this, void 0)) : gotValue.call(this, value);
                            }
                            function gotValue(value) {
                                var ret, array = this.array, promise = array._promise, fn = tryCatch(array._fn);
                                promise._pushContext(), (ret = void 0 !== array._eachValues ? fn.call(promise._boundValue(), value, this.index, this.length) : fn.call(promise._boundValue(), this.accum, value, this.index, this.length)) instanceof Promise && (array._currentCancellable = ret);
                                var promiseCreated = promise._popContext();
                                return debug.checkForgottenReturns(ret, promiseCreated, void 0 !== array._eachValues ? "Promise.each" : "Promise.reduce", promise), 
                                ret;
                            }
                            util.inherits(ReductionPromiseArray, PromiseArray), ReductionPromiseArray.prototype._gotAccum = function(accum) {
                                void 0 !== this._eachValues && null !== this._eachValues && accum !== INTERNAL && this._eachValues.push(accum);
                            }, ReductionPromiseArray.prototype._eachComplete = function(value) {
                                return null !== this._eachValues && this._eachValues.push(value), this._eachValues;
                            }, ReductionPromiseArray.prototype._init = function() {}, ReductionPromiseArray.prototype._resolveEmptyArray = function() {
                                this._resolve(void 0 !== this._eachValues ? this._eachValues : this._initialValue);
                            }, ReductionPromiseArray.prototype.shouldCopyValues = function() {
                                return !1;
                            }, ReductionPromiseArray.prototype._resolve = function(value) {
                                this._promise._resolveCallback(value), this._values = null;
                            }, ReductionPromiseArray.prototype._resultCancelled = function(sender) {
                                if (sender === this._initialValue) return this._cancel();
                                this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof Promise && this._currentCancellable.cancel(), 
                                this._initialValue instanceof Promise && this._initialValue.cancel());
                            }, ReductionPromiseArray.prototype._iterate = function(values) {
                                var value, i;
                                this._values = values;
                                var length = values.length;
                                if (void 0 !== this._initialValue ? (value = this._initialValue, i = 0) : (value = Promise.resolve(values[0]), 
                                i = 1), this._currentCancellable = value, !value.isRejected()) for (;i < length; ++i) {
                                    var ctx = {
                                        accum: null,
                                        value: values[i],
                                        index: i,
                                        length: length,
                                        array: this
                                    };
                                    value = value._then(gotAccum, void 0, void 0, ctx, void 0);
                                }
                                void 0 !== this._eachValues && (value = value._then(this._eachComplete, void 0, void 0, this, void 0)), 
                                value._then(completed, completed, void 0, value, this);
                            }, Promise.prototype.reduce = function(fn, initialValue) {
                                return reduce(this, fn, initialValue, null);
                            }, Promise.reduce = function(promises, fn, initialValue, _each) {
                                return reduce(promises, fn, initialValue, _each);
                            };
                        };
                    }, {
                        "./util": 36
                    } ],
                    29: [ function(_dereq_, module, exports) {
                        "use strict";
                        var schedule, util = _dereq_("./util"), NativePromise = util.getNativePromise();
                        if (util.isNode && "undefined" == typeof MutationObserver) {
                            var GlobalSetImmediate = global.setImmediate, ProcessNextTick = process.nextTick;
                            schedule = util.isRecentNode ? function(fn) {
                                GlobalSetImmediate.call(global, fn);
                            } : function(fn) {
                                ProcessNextTick.call(process, fn);
                            };
                        } else if ("function" == typeof NativePromise && "function" == typeof NativePromise.resolve) {
                            var nativePromise = NativePromise.resolve();
                            schedule = function(fn) {
                                nativePromise.then(fn);
                            };
                        } else schedule = "undefined" == typeof MutationObserver || "undefined" != typeof window && window.navigator && (window.navigator.standalone || window.cordova) ? void 0 !== setImmediate ? function(fn) {
                            setImmediate(fn);
                        } : "undefined" != typeof setTimeout ? function(fn) {
                            setTimeout(fn, 0);
                        } : function() {
                            throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
                        } : function() {
                            var div = document.createElement("div"), opts = {
                                attributes: !0
                            }, toggleScheduled = !1, div2 = document.createElement("div");
                            new MutationObserver(function() {
                                div.classList.toggle("foo"), toggleScheduled = !1;
                            }).observe(div2, opts);
                            return function(fn) {
                                var o = new MutationObserver(function() {
                                    o.disconnect(), fn();
                                });
                                o.observe(div, opts), toggleScheduled || (toggleScheduled = !0, div2.classList.toggle("foo"));
                            };
                        }();
                        module.exports = schedule;
                    }, {
                        "./util": 36
                    } ],
                    30: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, PromiseArray, debug) {
                            var PromiseInspection = Promise.PromiseInspection;
                            function SettledPromiseArray(values) {
                                this.constructor$(values);
                            }
                            _dereq_("./util").inherits(SettledPromiseArray, PromiseArray), SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
                                return this._values[index] = inspection, ++this._totalResolved >= this._length && (this._resolve(this._values), 
                                !0);
                            }, SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
                                var ret = new PromiseInspection();
                                return ret._bitField = 33554432, ret._settledValueField = value, this._promiseResolved(index, ret);
                            }, SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
                                var ret = new PromiseInspection();
                                return ret._bitField = 16777216, ret._settledValueField = reason, this._promiseResolved(index, ret);
                            }, Promise.settle = function(promises) {
                                return debug.deprecated(".settle()", ".reflect()"), new SettledPromiseArray(promises).promise();
                            }, Promise.prototype.settle = function() {
                                return Promise.settle(this);
                            };
                        };
                    }, {
                        "./util": 36
                    } ],
                    31: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, PromiseArray, apiRejection) {
                            var util = _dereq_("./util"), RangeError = _dereq_("./errors").RangeError, AggregateError = _dereq_("./errors").AggregateError, isArray = util.isArray, CANCELLATION = {};
                            function SomePromiseArray(values) {
                                this.constructor$(values), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
                            }
                            function some(promises, howMany) {
                                if ((0 | howMany) !== howMany || howMany < 0) return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
                                var ret = new SomePromiseArray(promises), promise = ret.promise();
                                return ret.setHowMany(howMany), ret.init(), promise;
                            }
                            util.inherits(SomePromiseArray, PromiseArray), SomePromiseArray.prototype._init = function() {
                                if (this._initialized) if (0 !== this._howMany) {
                                    this._init$(void 0, -5);
                                    var isArrayResolved = isArray(this._values);
                                    !this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
                                } else this._resolve([]);
                            }, SomePromiseArray.prototype.init = function() {
                                this._initialized = !0, this._init();
                            }, SomePromiseArray.prototype.setUnwrap = function() {
                                this._unwrap = !0;
                            }, SomePromiseArray.prototype.howMany = function() {
                                return this._howMany;
                            }, SomePromiseArray.prototype.setHowMany = function(count) {
                                this._howMany = count;
                            }, SomePromiseArray.prototype._promiseFulfilled = function(value) {
                                return this._addFulfilled(value), this._fulfilled() === this.howMany() && (this._values.length = this.howMany(), 
                                1 === this.howMany() && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), 
                                !0);
                            }, SomePromiseArray.prototype._promiseRejected = function(reason) {
                                return this._addRejected(reason), this._checkOutcome();
                            }, SomePromiseArray.prototype._promiseCancelled = function() {
                                return this._values instanceof Promise || null == this._values ? this._cancel() : (this._addRejected(CANCELLATION), 
                                this._checkOutcome());
                            }, SomePromiseArray.prototype._checkOutcome = function() {
                                if (this.howMany() > this._canPossiblyFulfill()) {
                                    for (var e = new AggregateError(), i = this.length(); i < this._values.length; ++i) this._values[i] !== CANCELLATION && e.push(this._values[i]);
                                    return e.length > 0 ? this._reject(e) : this._cancel(), !0;
                                }
                                return !1;
                            }, SomePromiseArray.prototype._fulfilled = function() {
                                return this._totalResolved;
                            }, SomePromiseArray.prototype._rejected = function() {
                                return this._values.length - this.length();
                            }, SomePromiseArray.prototype._addRejected = function(reason) {
                                this._values.push(reason);
                            }, SomePromiseArray.prototype._addFulfilled = function(value) {
                                this._values[this._totalResolved++] = value;
                            }, SomePromiseArray.prototype._canPossiblyFulfill = function() {
                                return this.length() - this._rejected();
                            }, SomePromiseArray.prototype._getRangeError = function(count) {
                                var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
                                return new RangeError(message);
                            }, SomePromiseArray.prototype._resolveEmptyArray = function() {
                                this._reject(this._getRangeError(0));
                            }, Promise.some = function(promises, howMany) {
                                return some(promises, howMany);
                            }, Promise.prototype.some = function(howMany) {
                                return some(this, howMany);
                            }, Promise._SomePromiseArray = SomePromiseArray;
                        };
                    }, {
                        "./errors": 12,
                        "./util": 36
                    } ],
                    32: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise) {
                            function PromiseInspection(promise) {
                                void 0 !== promise ? (promise = promise._target(), this._bitField = promise._bitField, 
                                this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0) : (this._bitField = 0, 
                                this._settledValueField = void 0);
                            }
                            PromiseInspection.prototype._settledValue = function() {
                                return this._settledValueField;
                            };
                            var value = PromiseInspection.prototype.value = function() {
                                if (!this.isFulfilled()) throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
                                return this._settledValue();
                            }, reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
                                if (!this.isRejected()) throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
                                return this._settledValue();
                            }, isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
                                return 0 != (33554432 & this._bitField);
                            }, isRejected = PromiseInspection.prototype.isRejected = function() {
                                return 0 != (16777216 & this._bitField);
                            }, isPending = PromiseInspection.prototype.isPending = function() {
                                return 0 == (50397184 & this._bitField);
                            }, isResolved = PromiseInspection.prototype.isResolved = function() {
                                return 0 != (50331648 & this._bitField);
                            };
                            PromiseInspection.prototype.isCancelled = function() {
                                return 0 != (8454144 & this._bitField);
                            }, Promise.prototype.__isCancelled = function() {
                                return 65536 == (65536 & this._bitField);
                            }, Promise.prototype._isCancelled = function() {
                                return this._target().__isCancelled();
                            }, Promise.prototype.isCancelled = function() {
                                return 0 != (8454144 & this._target()._bitField);
                            }, Promise.prototype.isPending = function() {
                                return isPending.call(this._target());
                            }, Promise.prototype.isRejected = function() {
                                return isRejected.call(this._target());
                            }, Promise.prototype.isFulfilled = function() {
                                return isFulfilled.call(this._target());
                            }, Promise.prototype.isResolved = function() {
                                return isResolved.call(this._target());
                            }, Promise.prototype.value = function() {
                                return value.call(this._target());
                            }, Promise.prototype.reason = function() {
                                var target = this._target();
                                return target._unsetRejectionIsUnhandled(), reason.call(target);
                            }, Promise.prototype._value = function() {
                                return this._settledValue();
                            }, Promise.prototype._reason = function() {
                                return this._unsetRejectionIsUnhandled(), this._settledValue();
                            }, Promise.PromiseInspection = PromiseInspection;
                        };
                    }, {} ],
                    33: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, INTERNAL) {
                            var util = _dereq_("./util"), errorObj = util.errorObj, isObject = util.isObject;
                            var hasProp = {}.hasOwnProperty;
                            return function(obj, context) {
                                if (isObject(obj)) {
                                    if (obj instanceof Promise) return obj;
                                    var then = function(obj) {
                                        try {
                                            return function(obj) {
                                                return obj.then;
                                            }(obj);
                                        } catch (e) {
                                            return errorObj.e = e, errorObj;
                                        }
                                    }(obj);
                                    if (then === errorObj) {
                                        context && context._pushContext();
                                        var ret = Promise.reject(then.e);
                                        return context && context._popContext(), ret;
                                    }
                                    if ("function" == typeof then) return function(obj) {
                                        try {
                                            return hasProp.call(obj, "_promise0");
                                        } catch (e) {
                                            return !1;
                                        }
                                    }(obj) ? (ret = new Promise(INTERNAL), obj._then(ret._fulfill, ret._reject, void 0, ret, null), 
                                    ret) : function(x, then, context) {
                                        var promise = new Promise(INTERNAL), ret = promise;
                                        context && context._pushContext(), promise._captureStackTrace(), context && context._popContext();
                                        var synchronous = !0, result = util.tryCatch(then).call(x, function(value) {
                                            promise && (promise._resolveCallback(value), promise = null);
                                        }, function(reason) {
                                            promise && (promise._rejectCallback(reason, synchronous, !0), promise = null);
                                        });
                                        return synchronous = !1, promise && result === errorObj && (promise._rejectCallback(result.e, !0, !0), 
                                        promise = null), ret;
                                    }(obj, then, context);
                                }
                                return obj;
                            };
                        };
                    }, {
                        "./util": 36
                    } ],
                    34: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, INTERNAL, debug) {
                            var util = _dereq_("./util"), TimeoutError = Promise.TimeoutError;
                            function HandleWrapper(handle) {
                                this.handle = handle;
                            }
                            HandleWrapper.prototype._resultCancelled = function() {
                                clearTimeout(this.handle);
                            };
                            var afterValue = function(value) {
                                return delay(+this).thenReturn(value);
                            }, delay = Promise.delay = function(ms, value) {
                                var ret, handle;
                                return void 0 !== value ? (ret = Promise.resolve(value)._then(afterValue, null, null, ms, void 0), 
                                debug.cancellation() && value instanceof Promise && ret._setOnCancel(value)) : (ret = new Promise(INTERNAL), 
                                handle = setTimeout(function() {
                                    ret._fulfill();
                                }, +ms), debug.cancellation() && ret._setOnCancel(new HandleWrapper(handle)), ret._captureStackTrace()), 
                                ret._setAsyncGuaranteed(), ret;
                            };
                            Promise.prototype.delay = function(ms) {
                                return delay(ms, this);
                            };
                            function successClear(value) {
                                return clearTimeout(this.handle), value;
                            }
                            function failureClear(reason) {
                                throw clearTimeout(this.handle), reason;
                            }
                            Promise.prototype.timeout = function(ms, message) {
                                var ret, parent;
                                ms = +ms;
                                var handleWrapper = new HandleWrapper(setTimeout(function() {
                                    ret.isPending() && function(promise, message, parent) {
                                        var err;
                                        err = "string" != typeof message ? message instanceof Error ? message : new TimeoutError("operation timed out") : new TimeoutError(message), 
                                        util.markAsOriginatingFromRejection(err), promise._attachExtraTrace(err), promise._reject(err), 
                                        null != parent && parent.cancel();
                                    }(ret, message, parent);
                                }, ms));
                                return debug.cancellation() ? (parent = this.then(), (ret = parent._then(successClear, failureClear, void 0, handleWrapper, void 0))._setOnCancel(handleWrapper)) : ret = this._then(successClear, failureClear, void 0, handleWrapper, void 0), 
                                ret;
                            };
                        };
                    }, {
                        "./util": 36
                    } ],
                    35: [ function(_dereq_, module, exports) {
                        "use strict";
                        module.exports = function(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
                            var util = _dereq_("./util"), TypeError = _dereq_("./errors").TypeError, inherits = _dereq_("./util").inherits, errorObj = util.errorObj, tryCatch = util.tryCatch, NULL = {};
                            function thrower(e) {
                                setTimeout(function() {
                                    throw e;
                                }, 0);
                            }
                            function dispose(resources, inspection) {
                                var i = 0, len = resources.length, ret = new Promise(INTERNAL);
                                return function iterator() {
                                    if (i >= len) return ret._fulfill();
                                    var maybePromise = function(thenable) {
                                        var maybePromise = tryConvertToPromise(thenable);
                                        return maybePromise !== thenable && "function" == typeof thenable._isDisposable && "function" == typeof thenable._getDisposer && thenable._isDisposable() && maybePromise._setDisposable(thenable._getDisposer()), 
                                        maybePromise;
                                    }(resources[i++]);
                                    if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
                                        try {
                                            maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
                                        } catch (e) {
                                            return thrower(e);
                                        }
                                        if (maybePromise instanceof Promise) return maybePromise._then(iterator, thrower, null, null, null);
                                    }
                                    iterator();
                                }(), ret;
                            }
                            function Disposer(data, promise, context) {
                                this._data = data, this._promise = promise, this._context = context;
                            }
                            function FunctionDisposer(fn, promise, context) {
                                this.constructor$(fn, promise, context);
                            }
                            function maybeUnwrapDisposer(value) {
                                return Disposer.isDisposer(value) ? (this.resources[this.index]._setDisposable(value), 
                                value.promise()) : value;
                            }
                            function ResourceList(length) {
                                this.length = length, this.promise = null, this[length - 1] = null;
                            }
                            Disposer.prototype.data = function() {
                                return this._data;
                            }, Disposer.prototype.promise = function() {
                                return this._promise;
                            }, Disposer.prototype.resource = function() {
                                return this.promise().isFulfilled() ? this.promise().value() : NULL;
                            }, Disposer.prototype.tryDispose = function(inspection) {
                                var resource = this.resource(), context = this._context;
                                void 0 !== context && context._pushContext();
                                var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
                                return void 0 !== context && context._popContext(), this._promise._unsetDisposable(), 
                                this._data = null, ret;
                            }, Disposer.isDisposer = function(d) {
                                return null != d && "function" == typeof d.resource && "function" == typeof d.tryDispose;
                            }, inherits(FunctionDisposer, Disposer), FunctionDisposer.prototype.doDispose = function(resource, inspection) {
                                return this.data().call(resource, resource, inspection);
                            }, ResourceList.prototype._resultCancelled = function() {
                                for (var len = this.length, i = 0; i < len; ++i) {
                                    var item = this[i];
                                    item instanceof Promise && item.cancel();
                                }
                            }, Promise.using = function() {
                                var len = arguments.length;
                                if (len < 2) return apiRejection("you must pass at least 2 arguments to Promise.using");
                                var input, fn = arguments[len - 1];
                                if ("function" != typeof fn) return apiRejection("expecting a function but got " + util.classString(fn));
                                var spreadArgs = !0;
                                2 === len && Array.isArray(arguments[0]) ? (len = (input = arguments[0]).length, 
                                spreadArgs = !1) : (input = arguments, len--);
                                for (var resources = new ResourceList(len), i = 0; i < len; ++i) {
                                    var resource = input[i];
                                    if (Disposer.isDisposer(resource)) {
                                        var disposer = resource;
                                        (resource = resource.promise())._setDisposable(disposer);
                                    } else {
                                        var maybePromise = tryConvertToPromise(resource);
                                        maybePromise instanceof Promise && (resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                                            resources: resources,
                                            index: i
                                        }, void 0));
                                    }
                                    resources[i] = resource;
                                }
                                var reflectedResources = new Array(resources.length);
                                for (i = 0; i < reflectedResources.length; ++i) reflectedResources[i] = Promise.resolve(resources[i]).reflect();
                                var resultPromise = Promise.all(reflectedResources).then(function(inspections) {
                                    for (var i = 0; i < inspections.length; ++i) {
                                        var inspection = inspections[i];
                                        if (inspection.isRejected()) return errorObj.e = inspection.error(), errorObj;
                                        if (!inspection.isFulfilled()) return void resultPromise.cancel();
                                        inspections[i] = inspection.value();
                                    }
                                    promise._pushContext(), fn = tryCatch(fn);
                                    var ret = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections), promiseCreated = promise._popContext();
                                    return debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise), 
                                    ret;
                                }), promise = resultPromise.lastly(function() {
                                    var inspection = new Promise.PromiseInspection(resultPromise);
                                    return dispose(resources, inspection);
                                });
                                return resources.promise = promise, promise._setOnCancel(resources), promise;
                            }, Promise.prototype._setDisposable = function(disposer) {
                                this._bitField = 131072 | this._bitField, this._disposer = disposer;
                            }, Promise.prototype._isDisposable = function() {
                                return (131072 & this._bitField) > 0;
                            }, Promise.prototype._getDisposer = function() {
                                return this._disposer;
                            }, Promise.prototype._unsetDisposable = function() {
                                this._bitField = -131073 & this._bitField, this._disposer = void 0;
                            }, Promise.prototype.disposer = function(fn) {
                                if ("function" == typeof fn) return new FunctionDisposer(fn, this, createContext());
                                throw new TypeError();
                            };
                        };
                    }, {
                        "./errors": 12,
                        "./util": 36
                    } ],
                    36: [ function(_dereq_, module, exports) {
                        "use strict";
                        var es5 = _dereq_("./es5"), canEvaluate = "undefined" == typeof navigator, errorObj = {
                            e: {}
                        }, tryCatchTarget, globalObject = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== global ? global : void 0 !== this ? this : null;
                        function tryCatcher() {
                            try {
                                var target = tryCatchTarget;
                                return tryCatchTarget = null, target.apply(this, arguments);
                            } catch (e) {
                                return errorObj.e = e, errorObj;
                            }
                        }
                        function tryCatch(fn) {
                            return tryCatchTarget = fn, tryCatcher;
                        }
                        var inherits = function(Child, Parent) {
                            var hasProp = {}.hasOwnProperty;
                            function T() {
                                for (var propertyName in this.constructor = Child, this.constructor$ = Parent, Parent.prototype) hasProp.call(Parent.prototype, propertyName) && "$" !== propertyName.charAt(propertyName.length - 1) && (this[propertyName + "$"] = Parent.prototype[propertyName]);
                            }
                            return T.prototype = Parent.prototype, Child.prototype = new T(), Child.prototype;
                        };
                        function isPrimitive(val) {
                            return null == val || !0 === val || !1 === val || "string" == typeof val || "number" == typeof val;
                        }
                        function isObject(value) {
                            return "function" == typeof value || "object" == typeof value && null !== value;
                        }
                        function maybeWrapAsError(maybeError) {
                            return isPrimitive(maybeError) ? new Error(safeToString(maybeError)) : maybeError;
                        }
                        function withAppended(target, appendee) {
                            var i, len = target.length, ret = new Array(len + 1);
                            for (i = 0; i < len; ++i) ret[i] = target[i];
                            return ret[i] = appendee, ret;
                        }
                        function getDataPropertyOrDefault(obj, key, defaultValue) {
                            if (!es5.isES5) return {}.hasOwnProperty.call(obj, key) ? obj[key] : void 0;
                            var desc = Object.getOwnPropertyDescriptor(obj, key);
                            return null != desc ? null == desc.get && null == desc.set ? desc.value : defaultValue : void 0;
                        }
                        function notEnumerableProp(obj, name, value) {
                            if (isPrimitive(obj)) return obj;
                            var descriptor = {
                                value: value,
                                configurable: !0,
                                enumerable: !1,
                                writable: !0
                            };
                            return es5.defineProperty(obj, name, descriptor), obj;
                        }
                        function thrower(r) {
                            throw r;
                        }
                        var inheritedDataKeys = function() {
                            var excludedPrototypes = [ Array.prototype, Object.prototype, Function.prototype ], isExcludedProto = function(val) {
                                for (var i = 0; i < excludedPrototypes.length; ++i) if (excludedPrototypes[i] === val) return !0;
                                return !1;
                            };
                            if (es5.isES5) {
                                var getKeys = Object.getOwnPropertyNames;
                                return function(obj) {
                                    for (var ret = [], visitedKeys = Object.create(null); null != obj && !isExcludedProto(obj); ) {
                                        var keys;
                                        try {
                                            keys = getKeys(obj);
                                        } catch (e) {
                                            return ret;
                                        }
                                        for (var i = 0; i < keys.length; ++i) {
                                            var key = keys[i];
                                            if (!visitedKeys[key]) {
                                                visitedKeys[key] = !0;
                                                var desc = Object.getOwnPropertyDescriptor(obj, key);
                                                null != desc && null == desc.get && null == desc.set && ret.push(key);
                                            }
                                        }
                                        obj = es5.getPrototypeOf(obj);
                                    }
                                    return ret;
                                };
                            }
                            var hasProp = {}.hasOwnProperty;
                            return function(obj) {
                                if (isExcludedProto(obj)) return [];
                                var ret = [];
                                /*jshint forin:false */                                enumeration: for (var key in obj) if (hasProp.call(obj, key)) ret.push(key); else {
                                    for (var i = 0; i < excludedPrototypes.length; ++i) if (hasProp.call(excludedPrototypes[i], key)) continue enumeration;
                                    ret.push(key);
                                }
                                return ret;
                            };
                        }(), thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
                        function isClass(fn) {
                            try {
                                if ("function" == typeof fn) {
                                    var keys = es5.names(fn.prototype), hasMethods = es5.isES5 && keys.length > 1, hasMethodsOtherThanConstructor = keys.length > 0 && !(1 === keys.length && "constructor" === keys[0]), hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
                                    if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) return !0;
                                }
                                return !1;
                            } catch (e) {
                                return !1;
                            }
                        }
                        function toFastProperties(obj) {
                            /*jshint -W027,-W055,-W031*/
                            function FakeConstructor() {}
                            FakeConstructor.prototype = obj;
                            for (var l = 8; l--; ) new FakeConstructor();
                            return obj;
                        }
                        var rident = /^[a-z$_][a-z$_0-9]*$/i;
                        function isIdentifier(str) {
                            return rident.test(str);
                        }
                        function filledRange(count, prefix, suffix) {
                            for (var ret = new Array(count), i = 0; i < count; ++i) ret[i] = prefix + i + suffix;
                            return ret;
                        }
                        function safeToString(obj) {
                            try {
                                return obj + "";
                            } catch (e) {
                                return "[no string representation]";
                            }
                        }
                        function isError(obj) {
                            return obj instanceof Error || null !== obj && "object" == typeof obj && "string" == typeof obj.message && "string" == typeof obj.name;
                        }
                        function markAsOriginatingFromRejection(e) {
                            try {
                                notEnumerableProp(e, "isOperational", !0);
                            } catch (ignore) {}
                        }
                        function originatesFromRejection(e) {
                            return null != e && (e instanceof Error.__BluebirdErrorTypes__.OperationalError || !0 === e.isOperational);
                        }
                        function canAttachTrace(obj) {
                            return isError(obj) && es5.propertyIsWritable(obj, "stack");
                        }
                        var ensureErrorObject = "stack" in new Error() ? function(value) {
                            return canAttachTrace(value) ? value : new Error(safeToString(value));
                        } : function(value) {
                            if (canAttachTrace(value)) return value;
                            try {
                                throw new Error(safeToString(value));
                            } catch (err) {
                                return err;
                            }
                        };
                        function classString(obj) {
                            return {}.toString.call(obj);
                        }
                        function copyDescriptors(from, to, filter) {
                            for (var keys = es5.names(from), i = 0; i < keys.length; ++i) {
                                var key = keys[i];
                                if (filter(key)) try {
                                    es5.defineProperty(to, key, es5.getDescriptor(from, key));
                                } catch (ignore) {}
                            }
                        }
                        var asArray = function(v) {
                            return es5.isArray(v) ? v : null;
                        };
                        if ("undefined" != typeof Symbol && Symbol.iterator) {
                            var ArrayFrom = "function" == typeof Array.from ? function(v) {
                                return Array.from(v);
                            } : function(v) {
                                for (var itResult, ret = [], it = v[Symbol.iterator](); !(itResult = it.next()).done; ) ret.push(itResult.value);
                                return ret;
                            };
                            asArray = function(v) {
                                return es5.isArray(v) ? v : null != v && "function" == typeof v[Symbol.iterator] ? ArrayFrom(v) : null;
                            };
                        }
                        var isNode = void 0 !== process && "[object process]" === classString(process).toLowerCase(), hasEnvVariables = void 0 !== process && void 0 !== process.env;
                        function env(key) {
                            return hasEnvVariables ? process.env[key] : void 0;
                        }
                        function getNativePromise() {
                            if ("function" == typeof Promise) try {
                                var promise = new Promise(function() {});
                                if ("[object Promise]" === {}.toString.call(promise)) return Promise;
                            } catch (e) {}
                        }
                        function domainBind(self, cb) {
                            return self.bind(cb);
                        }
                        var ret = {
                            isClass: isClass,
                            isIdentifier: isIdentifier,
                            inheritedDataKeys: inheritedDataKeys,
                            getDataPropertyOrDefault: getDataPropertyOrDefault,
                            thrower: thrower,
                            isArray: es5.isArray,
                            asArray: asArray,
                            notEnumerableProp: notEnumerableProp,
                            isPrimitive: isPrimitive,
                            isObject: isObject,
                            isError: isError,
                            canEvaluate: canEvaluate,
                            errorObj: errorObj,
                            tryCatch: tryCatch,
                            inherits: inherits,
                            withAppended: withAppended,
                            maybeWrapAsError: maybeWrapAsError,
                            toFastProperties: toFastProperties,
                            filledRange: filledRange,
                            toString: safeToString,
                            canAttachTrace: canAttachTrace,
                            ensureErrorObject: ensureErrorObject,
                            originatesFromRejection: originatesFromRejection,
                            markAsOriginatingFromRejection: markAsOriginatingFromRejection,
                            classString: classString,
                            copyDescriptors: copyDescriptors,
                            hasDevTools: "undefined" != typeof chrome && chrome && "function" == typeof chrome.loadTimes,
                            isNode: isNode,
                            hasEnvVariables: hasEnvVariables,
                            env: env,
                            global: globalObject,
                            getNativePromise: getNativePromise,
                            domainBind: domainBind
                        }, version;
                        ret.isRecentNode = ret.isNode && (version = process.versions.node.split(".").map(Number), 
                        0 === version[0] && version[1] > 10 || version[0] > 0), ret.isNode && ret.toFastProperties(process);
                        try {
                            throw new Error();
                        } catch (e) {
                            ret.lastLineError = e;
                        }
                        module.exports = ret;
                    }, {
                        "./es5": 13
                    } ]
                }, {}, [ 4 ])(4);
            }, module.exports = e(), "undefined" != typeof window && null !== window ? window.P = window.Promise : "undefined" != typeof self && null !== self && (self.P = self.Promise)
            /* WEBPACK VAR INJECTION */;
        }).call(exports, __webpack_require__(0), __webpack_require__(1), __webpack_require__(7).setImmediate)
        /***/;
    }, 
    /* 10 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var __WEBPACK_IMPORTED_MODULE_0_js_worker_search__ = __webpack_require__(6), __WEBPACK_IMPORTED_MODULE_0_js_worker_search___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_js_worker_search__), __WEBPACK_IMPORTED_MODULE_1_bluebird__ = __webpack_require__(9), __WEBPACK_IMPORTED_MODULE_2__utils__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_bluebird__), 
        __webpack_require__(2));
        /* harmony import */        
        /* harmony export (immutable) */ __webpack_exports__.a = 
        /* eslint-disable no-underscore-dangle */
        /**
 * Observable that manages communication between vuex-search plugin and the Search utility.
 * This class maps resource names to search indicies and manages subscribers.
 */
        class {
            /**
   * Constructor.
   */
            constructor({indexMode: indexMode, tokenizePattern: tokenizePattern, caseSensitive: caseSensitive} = {}) {
                this._indexMode = indexMode, this._tokenizePattern = tokenizePattern, this._caseSensitive = caseSensitive, 
                this._resourceToSearchMap = {}, this._currentSearchPromiseMap = {}, 
                // Subscribers
                this._onErrorSubscribers = [], this._onNextSubscribers = [];
            }
            /**
   * Subscribe to Search events.
   * Subscribers will be notified each time a Search is performed.
   *
   * Successful searches will call :onNext with the following parameters:
   * >result: An array of uids matching the search
   * >text: Search string
   * >resourceName: Identifies the resource that was searched
   *
   * Failed searches (searches that result in an Error) will call :onError with an Error parameter.
   *
   * This method returns a callback that can be used to unsubscribe from Search events.
   * Just invoke the function without any parameters to unsubscribe.
   */            subscribe(onNext, onError) {
                // Return dispose function
                return onNext && this._onNextSubscribers.push(onNext), onError && this._onErrorSubscribers.push(onError), 
                () => {
                    this._onNextSubscribers = this._onNextSubscribers.filter(subscriber => subscriber !== onNext), 
                    this._onErrorSubscribers = this._onErrorSubscribers.filter(subscriber => subscriber !== onError);
                };
            }
            /**
   * Builds a searchable index of a set of resources.
   *
   * @param fieldNamesOrIndexFunction This value is passed to
   *   vuexSearchPlugin() factory during initialization
   *   It is either an Array of searchable fields (to be auto-indexed)
   *   Or a custom index function to be called with a :resources object
   *   and an :indexDocument callback
   * @param resourceName Uniquely identifies the resource (eg. "databases")
   * @param resources Map of resource uid to resource (Object)
   */            indexResource({fieldNamesOrIndexFunction: fieldNamesOrIndexFunction, resourceName: resourceName, resources: resources}) {
                const search = new __WEBPACK_IMPORTED_MODULE_0_js_worker_search___default.a({
                    indexMode: this._indexMode,
                    tokenizePattern: this._tokenizePattern,
                    caseSensitive: this._caseSensitive
                });
                if (Array.isArray(fieldNamesOrIndexFunction)) resources.forEach instanceof Function ? resources.forEach(resource => {
                    fieldNamesOrIndexFunction.forEach(field => {
                        search.indexDocument(resource.id, resource[field] || "");
                    });
                }) : Object.keys(resources).forEach(key => {
                    const resource = resources[key];
                    fieldNamesOrIndexFunction.forEach(field => {
                        search.indexDocument(resource.id, resource[field] || "");
                    });
                }); else {
                    if (!(fieldNamesOrIndexFunction instanceof Function)) throw Error("Expected resource index to be either an Array of fields or an index function");
                    fieldNamesOrIndexFunction({
                        indexDocument: search.indexDocument,
                        resources: resources
                    });
                }
                this._resourceToSearchMap[resourceName] = search;
            }
            /**
   * Searches a resource and returns a Promise to be resolved with
   * an array of uids that match the search string.
   * Upon completion (or failure) this method also notifies all current subscribers.
   *
   * @param resourceName Uniquely identifies the resource (eg. "databases")
   * @param text Search string
   */            async performSearch(resourceName, text) {
                try {
                    const search = this._resourceToSearchMap[resourceName], searchPromise = Object(__WEBPACK_IMPORTED_MODULE_2__utils__.a)(search.search(text));
                    this._currentSearchPromiseMap[resourceName] = searchPromise;
                    const result = await searchPromise;
                    return delete this._currentSearchPromiseMap[resourceName], this._notifyNext({
                        result: result,
                        text: text,
                        resourceName: resourceName
                    }), result;
                } catch (error) {
                    if (error instanceof __WEBPACK_IMPORTED_MODULE_1_bluebird__.CancellationError) return [];
                    throw this._notifyError(error), error;
                }
            }
            /**
   * Stop search by resourceName if running.
   * Promise of search will be cancelled (rejected with CancellationError)
   */            stopSearch(resourceName) {
                const currentSearch = this._currentSearchPromiseMap[resourceName];
                currentSearch && currentSearch.cancel();
            }
            /** Notify all subscribes of :onError */            _notifyError(error) {
                this._onErrorSubscribers.forEach(subscriber => subscriber(error));
            }
            /** Notify all subscribes of :onNext */            _notifyNext(data) {
                this._onNextSubscribers.forEach(subscriber => subscriber(data));
            }
        };
    }, 
    /* 11 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        Object.defineProperty(__webpack_exports__, "__esModule", {
            value: !0
        });
        /* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_js_worker_search__ = __webpack_require__(6), __WEBPACK_IMPORTED_MODULE_1__plugin__ = (__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_js_worker_search__), 
        __webpack_require__(12)), __WEBPACK_IMPORTED_MODULE_2__SearchApi__ = __webpack_require__(10), __WEBPACK_IMPORTED_MODULE_3__getter_types__ = __webpack_require__(5), __WEBPACK_IMPORTED_MODULE_4__mapActions__ = __webpack_require__(18), __WEBPACK_IMPORTED_MODULE_5__mapGetters__ = __webpack_require__(19), __WEBPACK_IMPORTED_MODULE_6__VuexSearch__ = __webpack_require__(3);
        /* harmony import */        
        /* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "SearchApi", function() {
            return __WEBPACK_IMPORTED_MODULE_2__SearchApi__.a;
        }), 
        /* harmony reexport (binding) */ __webpack_require__.o(__WEBPACK_IMPORTED_MODULE_0_js_worker_search__, "INDEX_MODES") && __webpack_require__.d(__webpack_exports__, "INDEX_MODES", function() {
            return __WEBPACK_IMPORTED_MODULE_0_js_worker_search__.INDEX_MODES;
        })
        /* harmony reexport (binding) */ , __webpack_require__.d(__webpack_exports__, "actionTypes", function() {
            return __WEBPACK_IMPORTED_MODULE_6__VuexSearch__.b;
        }), 
        /* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "getterTypes", function() {
            return __WEBPACK_IMPORTED_MODULE_3__getter_types__.a;
        }), 
        /* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "mapActions", function() {
            return __WEBPACK_IMPORTED_MODULE_4__mapActions__.a;
        }), 
        /* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "mapGetters", function() {
            return __WEBPACK_IMPORTED_MODULE_5__mapGetters__.a;
        }), 
        /* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "VuexSearch", function() {
            return __WEBPACK_IMPORTED_MODULE_6__VuexSearch__.a;
        }), 
        /* harmony default export */ __webpack_exports__.default = __WEBPACK_IMPORTED_MODULE_1__plugin__.a;
    }, 
    /* 12 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (immutable) */        __webpack_exports__.a = 
        /**
 * Vuex binding for client-side search with indexer and Web Workers
 *
 * @param {[resourceName: string]: { getter, indexes, searchApi? }} resources
 *    Resource to watch and index
 * @param {SearchApi} searchApi Optional, can also use custom SearchApi instances
 */
        function({resources: resources = {}, searchApi: searchApi = new __WEBPACK_IMPORTED_MODULE_1__SearchApi__.a()} = {}) {
            return store => {
                /* eslint-disable no-new */
                new __WEBPACK_IMPORTED_MODULE_0__VuexSearch__.a({
                    store: store,
                    resources: resources,
                    searchApi: searchApi
                });
            };
        }
        /***/;
        /* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__VuexSearch__ = __webpack_require__(3), __WEBPACK_IMPORTED_MODULE_1__SearchApi__ = __webpack_require__(10);
        /* harmony import */    }, 
    /* 13 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(14), __WEBPACK_IMPORTED_MODULE_1__mutation_types__ = __webpack_require__(4);
        /* harmony import */        
        /* harmony default export */ __webpack_exports__.a = {
            [__WEBPACK_IMPORTED_MODULE_1__mutation_types__.b]: (state, {resourceName: resourceName}) => {
                __WEBPACK_IMPORTED_MODULE_0_vue__.a.set(state, resourceName, {
                    isSearching: !1,
                    text: "",
                    result: []
                });
            },
            [__WEBPACK_IMPORTED_MODULE_1__mutation_types__.d]: (state, {resourceName: resourceName, result: result, text: text}) => {
                __WEBPACK_IMPORTED_MODULE_0_vue__.a.set(state, resourceName, {
                    isSearching: !1,
                    text: text,
                    result: result
                });
            },
            [__WEBPACK_IMPORTED_MODULE_1__mutation_types__.c]: (state, {resourceName: resourceName, searchString: searchString}) => {
                __WEBPACK_IMPORTED_MODULE_0_vue__.a.set(state[resourceName], "text", searchString), 
                __WEBPACK_IMPORTED_MODULE_0_vue__.a.set(state[resourceName], "isSearching", !0);
            },
            [__WEBPACK_IMPORTED_MODULE_1__mutation_types__.a]: (state, {resourceName: resourceName}) => {
                __WEBPACK_IMPORTED_MODULE_0_vue__.a.delete(state, resourceName);
            }
        };
    }, 
    /* 14 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* WEBPACK VAR INJECTION */        
        /* WEBPACK VAR INJECTION */ (function(process, global, setImmediate) {
            /*!
 * Vue.js v2.5.16
 * (c) 2014-2018 Evan You
 * Released under the MIT License.
 */
            /*  */
            var emptyObject = Object.freeze({});
            // these helpers produces better vm code in JS engines due to their
            // explicitness and function inlining
                        function isUndef(v) {
                return void 0 === v || null === v;
            }
            function isDef(v) {
                return void 0 !== v && null !== v;
            }
            function isTrue(v) {
                return !0 === v;
            }
            /**
 * Check if value is primitive
 */
            function isPrimitive(value) {
                return "string" == typeof value || "number" == typeof value || 
                // $flow-disable-line
                "symbol" == typeof value || "boolean" == typeof value;
            }
            /**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */            function isObject(obj) {
                return null !== obj && "object" == typeof obj;
            }
            /**
 * Get the raw type string of a value e.g. [object Object]
 */            var _toString = Object.prototype.toString;
            function toRawType(value) {
                return _toString.call(value).slice(8, -1);
            }
            /**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */            function isPlainObject(obj) {
                return "[object Object]" === _toString.call(obj);
            }
            function isRegExp(v) {
                return "[object RegExp]" === _toString.call(v);
            }
            /**
 * Check if val is a valid array index.
 */            function isValidArrayIndex(val) {
                var n = parseFloat(String(val));
                return n >= 0 && Math.floor(n) === n && isFinite(val);
            }
            /**
 * Convert a value to a string that is actually rendered.
 */            function toString(val) {
                return null == val ? "" : "object" == typeof val ? JSON.stringify(val, null, 2) : String(val);
            }
            /**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */            function toNumber(val) {
                var n = parseFloat(val);
                return isNaN(n) ? val : n;
            }
            /**
 * Make a map and return a function for checking if a key
 * is in that map.
 */            function makeMap(str, expectsLowerCase) {
                for (var map = Object.create(null), list = str.split(","), i = 0; i < list.length; i++) map[list[i]] = !0;
                return expectsLowerCase ? function(val) {
                    return map[val.toLowerCase()];
                } : function(val) {
                    return map[val];
                };
            }
            /**
 * Check if a tag is a built-in tag.
 */            var isBuiltInTag = makeMap("slot,component", !0), isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
            /**
 * Check if a attribute is a reserved attribute.
 */            
            /**
 * Remove an item from an array
 */
            function remove(arr, item) {
                if (arr.length) {
                    var index = arr.indexOf(item);
                    if (index > -1) return arr.splice(index, 1);
                }
            }
            /**
 * Check whether the object has the property.
 */            var hasOwnProperty = Object.prototype.hasOwnProperty;
            function hasOwn(obj, key) {
                return hasOwnProperty.call(obj, key);
            }
            /**
 * Create a cached version of a pure function.
 */            function cached(fn) {
                var cache = Object.create(null);
                return function(str) {
                    return cache[str] || (cache[str] = fn(str));
                };
            }
            /**
 * Camelize a hyphen-delimited string.
 */            var camelizeRE = /-(\w)/g, camelize = cached(function(str) {
                return str.replace(camelizeRE, function(_, c) {
                    return c ? c.toUpperCase() : "";
                });
            }), capitalize = cached(function(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            }), hyphenateRE = /\B([A-Z])/g, hyphenate = cached(function(str) {
                return str.replace(hyphenateRE, "-$1").toLowerCase();
            });
            var bind = Function.prototype.bind ? function(fn, ctx) {
                return fn.bind(ctx);
            } : 
            /**
 * Simple bind polyfill for environments that do not support it... e.g.
 * PhantomJS 1.x. Technically we don't need this anymore since native bind is
 * now more performant in most browsers, but removing it would be breaking for
 * code that was able to run in PhantomJS 1.x, so this must be kept for
 * backwards compatibility.
 */
            /* istanbul ignore next */
            function(fn, ctx) {
                function boundFn(a) {
                    var l = arguments.length;
                    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
                }
                return boundFn._length = fn.length, boundFn;
            };
            /**
 * Convert an Array-like object to a real Array.
 */            function toArray(list, start) {
                start = start || 0;
                for (var i = list.length - start, ret = new Array(i); i--; ) ret[i] = list[i + start];
                return ret;
            }
            /**
 * Mix properties into target object.
 */            function extend(to, _from) {
                for (var key in _from) to[key] = _from[key];
                return to;
            }
            /**
 * Merge an Array of Objects into a single Object.
 */            function toObject(arr) {
                for (var res = {}, i = 0; i < arr.length; i++) arr[i] && extend(res, arr[i]);
                return res;
            }
            /**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */            function noop(a, b, c) {}
            /**
 * Always return false.
 */            var no = function(a, b, c) {
                return !1;
            }, identity = function(_) {
                return _;
            };
            /**
 * Return same value
 */            
            /**
 * Generate a static keys string from compiler modules.
 */
            /**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
            function looseEqual(a, b) {
                if (a === b) return !0;
                var isObjectA = isObject(a), isObjectB = isObject(b);
                if (!isObjectA || !isObjectB) return !isObjectA && !isObjectB && String(a) === String(b);
                try {
                    var isArrayA = Array.isArray(a), isArrayB = Array.isArray(b);
                    if (isArrayA && isArrayB) return a.length === b.length && a.every(function(e, i) {
                        return looseEqual(e, b[i]);
                    });
                    if (isArrayA || isArrayB) 
                    /* istanbul ignore next */
                    return !1;
                    var keysA = Object.keys(a), keysB = Object.keys(b);
                    return keysA.length === keysB.length && keysA.every(function(key) {
                        return looseEqual(a[key], b[key]);
                    });
                } catch (e) {
                    /* istanbul ignore next */
                    return !1;
                }
            }
            function looseIndexOf(arr, val) {
                for (var i = 0; i < arr.length; i++) if (looseEqual(arr[i], val)) return i;
                return -1;
            }
            /**
 * Ensure a function is called only once.
 */            function once(fn) {
                var called = !1;
                return function() {
                    called || (called = !0, fn.apply(this, arguments));
                };
            }
            var SSR_ATTR = "data-server-rendered", ASSET_TYPES = [ "component", "directive", "filter" ], LIFECYCLE_HOOKS = [ "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured" ], config = {
                /**
   * Option merge strategies (used in core/util/options)
   */
                // $flow-disable-line
                optionMergeStrategies: Object.create(null),
                /**
   * Whether to suppress warnings.
   */
                silent: !1,
                /**
   * Show production mode tip message on boot?
   */
                productionTip: "production" !== process.env.NODE_ENV,
                /**
   * Whether to enable devtools
   */
                devtools: "production" !== process.env.NODE_ENV,
                /**
   * Whether to record perf
   */
                performance: !1,
                /**
   * Error handler for watcher errors
   */
                errorHandler: null,
                /**
   * Warn handler for watcher warns
   */
                warnHandler: null,
                /**
   * Ignore certain custom elements
   */
                ignoredElements: [],
                /**
   * Custom user key aliases for v-on
   */
                // $flow-disable-line
                keyCodes: Object.create(null),
                /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
                isReservedTag: no,
                /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
                isReservedAttr: no,
                /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
                isUnknownElement: no,
                /**
   * Get the namespace of an element
   */
                getTagNamespace: noop,
                /**
   * Parse the real tag name for the specific platform.
   */
                parsePlatformTagName: identity,
                /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
                mustUseProp: no,
                /**
   * Exposed for legacy reasons
   */
                _lifecycleHooks: LIFECYCLE_HOOKS
            }
            /*  */
            /**
 * Check if a string starts with $ or _
 */;
            /*  */
            /**
 * Check if a string starts with $ or _
 */
            function isReserved(str) {
                var c = (str + "").charCodeAt(0);
                return 36 === c || 95 === c;
            }
            /**
 * Define a property.
 */            function def(obj, key, val, enumerable) {
                Object.defineProperty(obj, key, {
                    value: val,
                    enumerable: !!enumerable,
                    writable: !0,
                    configurable: !0
                });
            }
            /**
 * Parse simple path.
 */            var bailRE = /[^\w.$]/;
            /*  */
            // can we use __proto__?
            var _isServer, hasProto = "__proto__" in {}, inBrowser = "undefined" != typeof window, inWeex = "undefined" != typeof WXEnvironment && !!WXEnvironment.platform, weexPlatform = inWeex && WXEnvironment.platform.toLowerCase(), UA = inBrowser && window.navigator.userAgent.toLowerCase(), isIE = UA && /msie|trident/.test(UA), isIE9 = UA && UA.indexOf("msie 9.0") > 0, isEdge = UA && UA.indexOf("edge/") > 0, isIOS = (UA && UA.indexOf("android"), 
            UA && /iphone|ipad|ipod|ios/.test(UA) || "ios" === weexPlatform), isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge, nativeWatch = {}.watch, supportsPassive = !1;
            // Browser environment sniffing
                        if (inBrowser) try {
                var opts = {};
                Object.defineProperty(opts, "passive", {
                    get: function() {
                        /* istanbul ignore next */
                        supportsPassive = !0;
                    }
                }), // https://github.com/facebook/flow/issues/285
                window.addEventListener("test-passive", null, opts);
            } catch (e) {}
            // this needs to be lazy-evaled because vue may be required before
            // vue-server-renderer can set VUE_ENV
                        var isServerRendering = function() {
                return void 0 === _isServer && (
                /* istanbul ignore if */
                _isServer = !inBrowser && !inWeex && void 0 !== global && "server" === global.process.env.VUE_ENV), 
                _isServer;
            }, devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
            // detect devtools
                        /* istanbul ignore next */
            function isNative(Ctor) {
                return "function" == typeof Ctor && /native code/.test(Ctor.toString());
            }
            var _Set, hasSymbol = "undefined" != typeof Symbol && isNative(Symbol) && "undefined" != typeof Reflect && isNative(Reflect.ownKeys);
            /* istanbul ignore if */ // $flow-disable-line
            // use native Set when available.
            _Set = "undefined" != typeof Set && isNative(Set) ? Set : function() {
                function Set() {
                    this.set = Object.create(null);
                }
                return Set.prototype.has = function(key) {
                    return !0 === this.set[key];
                }, Set.prototype.add = function(key) {
                    this.set[key] = !0;
                }, Set.prototype.clear = function() {
                    this.set = Object.create(null);
                }, Set;
            }()
            /*  */;
            var warn = noop, tip = noop, generateComponentTrace = noop, formatComponentName = noop;
            if ("production" !== process.env.NODE_ENV) {
                var hasConsole = "undefined" != typeof console, classifyRE = /(?:^|[-_])(\w)/g;
                warn = function(msg, vm) {
                    var trace = vm ? generateComponentTrace(vm) : "";
                    config.warnHandler ? config.warnHandler.call(null, msg, vm, trace) : hasConsole && !config.silent && console.error("[Vue warn]: " + msg + trace);
                }, tip = function(msg, vm) {
                    hasConsole && !config.silent && console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ""));
                }, formatComponentName = function(vm, includeFile) {
                    if (vm.$root === vm) return "<Root>";
                    var options = "function" == typeof vm && null != vm.cid ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {}, name = options.name || options._componentTag, file = options.__file;
                    if (!name && file) {
                        var match = file.match(/([^/\\]+)\.vue$/);
                        name = match && match[1];
                    }
                    return (name ? "<" + name.replace(classifyRE, function(c) {
                        return c.toUpperCase();
                    }).replace(/[-_]/g, "") + ">" : "<Anonymous>") + (file && !1 !== includeFile ? " at " + file : "");
                };
                generateComponentTrace = function(vm) {
                    if (vm._isVue && vm.$parent) {
                        for (var tree = [], currentRecursiveSequence = 0; vm; ) {
                            if (tree.length > 0) {
                                var last = tree[tree.length - 1];
                                if (last.constructor === vm.constructor) {
                                    currentRecursiveSequence++, vm = vm.$parent;
                                    continue;
                                }
                                currentRecursiveSequence > 0 && (tree[tree.length - 1] = [ last, currentRecursiveSequence ], 
                                currentRecursiveSequence = 0);
                            }
                            tree.push(vm), vm = vm.$parent;
                        }
                        return "\n\nfound in\n\n" + tree.map(function(vm, i) {
                            return "" + (0 === i ? "---\x3e " : function(str, n) {
                                for (var res = ""; n; ) n % 2 == 1 && (res += str), n > 1 && (str += str), n >>= 1;
                                return res;
                            }(" ", 5 + 2 * i)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
                        }).join("\n");
                    }
                    return "\n\n(found in " + formatComponentName(vm) + ")";
                };
            }
            /*  */            var uid = 0, Dep = function() {
                this.id = uid++, this.subs = [];
            };
            /**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */            Dep.prototype.addSub = function(sub) {
                this.subs.push(sub);
            }, Dep.prototype.removeSub = function(sub) {
                remove(this.subs, sub);
            }, Dep.prototype.depend = function() {
                Dep.target && Dep.target.addDep(this);
            }, Dep.prototype.notify = function() {
                for (
                // stabilize the subscriber list first
                var subs = this.subs.slice(), i = 0, l = subs.length; i < l; i++) subs[i].update();
            }, 
            // the current target watcher being evaluated.
            // this is globally unique because there could be only one
            // watcher being evaluated at any time.
            Dep.target = null;
            var targetStack = [];
            function pushTarget(_target) {
                Dep.target && targetStack.push(Dep.target), Dep.target = _target;
            }
            function popTarget() {
                Dep.target = targetStack.pop();
            }
            /*  */            var VNode = function(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
                this.tag = tag, this.data = data, this.children = children, this.text = text, this.elm = elm, 
                this.ns = void 0, this.context = context, this.fnContext = void 0, this.fnOptions = void 0, 
                this.fnScopeId = void 0, this.key = data && data.key, this.componentOptions = componentOptions, 
                this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, 
                this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, 
                this.asyncFactory = asyncFactory, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1;
            }, prototypeAccessors = {
                child: {
                    configurable: !0
                }
            };
            // DEPRECATED: alias for componentInstance for backwards compat.
            /* istanbul ignore next */
            prototypeAccessors.child.get = function() {
                return this.componentInstance;
            }, Object.defineProperties(VNode.prototype, prototypeAccessors);
            var createEmptyVNode = function(text) {
                void 0 === text && (text = "");
                var node = new VNode();
                return node.text = text, node.isComment = !0, node;
            };
            function createTextVNode(val) {
                return new VNode(void 0, void 0, void 0, String(val));
            }
            // optimized shallow clone
            // used for static nodes and slot nodes because they may be reused across
            // multiple renders, cloning them avoids errors when DOM manipulations rely
            // on their elm reference.
                        function cloneVNode(vnode) {
                var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
                return cloned.ns = vnode.ns, cloned.isStatic = vnode.isStatic, cloned.key = vnode.key, 
                cloned.isComment = vnode.isComment, cloned.fnContext = vnode.fnContext, cloned.fnOptions = vnode.fnOptions, 
                cloned.fnScopeId = vnode.fnScopeId, cloned.isCloned = !0, cloned;
            }
            /*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */            var arrayProto = Array.prototype, arrayMethods = Object.create(arrayProto);
            /**
 * Intercept mutating methods and emit events
 */
            [ "push", "pop", "shift", "unshift", "splice", "sort", "reverse" ].forEach(function(method) {
                // cache original method
                var original = arrayProto[method];
                def(arrayMethods, method, function() {
                    for (var args = [], len = arguments.length; len--; ) args[len] = arguments[len];
                    var inserted, result = original.apply(this, args), ob = this.__ob__;
                    switch (method) {
                      case "push":
                      case "unshift":
                        inserted = args;
                        break;

                      case "splice":
                        inserted = args.slice(2);
                    }
                    return inserted && ob.observeArray(inserted), 
                    // notify change
                    ob.dep.notify(), result;
                });
            });
            /*  */
            var arrayKeys = Object.getOwnPropertyNames(arrayMethods), shouldObserve = !0;
            /**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */            function toggleObserving(value) {
                shouldObserve = value;
            }
            /**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */            var Observer = function(value) {
                (this.value = value, this.dep = new Dep(), this.vmCount = 0, def(value, "__ob__", this), 
                Array.isArray(value)) ? ((hasProto ? protoAugment : copyAugment)(value, arrayMethods, arrayKeys), 
                this.observeArray(value)) : this.walk(value);
            };
            /**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */            
            // helpers
            /**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
            function protoAugment(target, src, keys) {
                /* eslint-disable no-proto */
                target.__proto__ = src;
                /* eslint-enable no-proto */            }
            /**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
            /* istanbul ignore next */            function copyAugment(target, src, keys) {
                for (var i = 0, l = keys.length; i < l; i++) {
                    var key = keys[i];
                    def(target, key, src[key]);
                }
            }
            /**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */            function observe(value, asRootData) {
                var ob;
                if (isObject(value) && !(value instanceof VNode)) return hasOwn(value, "__ob__") && value.__ob__ instanceof Observer ? ob = value.__ob__ : shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue && (ob = new Observer(value)), 
                asRootData && ob && ob.vmCount++, ob;
            }
            /**
 * Define a reactive property on an Object.
 */            function defineReactive(obj, key, val, customSetter, shallow) {
                var dep = new Dep(), property = Object.getOwnPropertyDescriptor(obj, key);
                if (!property || !1 !== property.configurable) {
                    // cater for pre-defined getter/setters
                    var getter = property && property.get;
                    getter || 2 !== arguments.length || (val = obj[key]);
                    var setter = property && property.set, childOb = !shallow && observe(val);
                    Object.defineProperty(obj, key, {
                        enumerable: !0,
                        configurable: !0,
                        get: function() {
                            var value = getter ? getter.call(obj) : val;
                            return Dep.target && (dep.depend(), childOb && (childOb.dep.depend(), Array.isArray(value) && 
                            /**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
                            function dependArray(value) {
                                for (var e = void 0, i = 0, l = value.length; i < l; i++) (e = value[i]) && e.__ob__ && e.__ob__.dep.depend(), 
                                Array.isArray(e) && dependArray(e);
                            }
                            /*  */
                            /**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */ (value))), value;
                        },
                        set: function(newVal) {
                            var value = getter ? getter.call(obj) : val;
                            /* eslint-disable no-self-compare */                            newVal === value || newVal != newVal && value != value || (
                            /* eslint-enable no-self-compare */
                            "production" !== process.env.NODE_ENV && customSetter && customSetter(), setter ? setter.call(obj, newVal) : val = newVal, 
                            childOb = !shallow && observe(newVal), dep.notify());
                        }
                    });
                }
            }
            /**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */            function set(target, key, val) {
                if ("production" !== process.env.NODE_ENV && (isUndef(target) || isPrimitive(target)) && warn("Cannot set reactive property on undefined, null, or primitive value: " + target), 
                Array.isArray(target) && isValidArrayIndex(key)) return target.length = Math.max(target.length, key), 
                target.splice(key, 1, val), val;
                if (key in target && !(key in Object.prototype)) return target[key] = val, val;
                var ob = target.__ob__;
                return target._isVue || ob && ob.vmCount ? ("production" !== process.env.NODE_ENV && warn("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option."), 
                val) : ob ? (defineReactive(ob.value, key, val), ob.dep.notify(), val) : (target[key] = val, 
                val);
            }
            /**
 * Delete a property and trigger change if necessary.
 */            function del(target, key) {
                if ("production" !== process.env.NODE_ENV && (isUndef(target) || isPrimitive(target)) && warn("Cannot delete reactive property on undefined, null, or primitive value: " + target), 
                Array.isArray(target) && isValidArrayIndex(key)) target.splice(key, 1); else {
                    var ob = target.__ob__;
                    target._isVue || ob && ob.vmCount ? "production" !== process.env.NODE_ENV && warn("Avoid deleting properties on a Vue instance or its root $data - just set it to null.") : hasOwn(target, key) && (delete target[key], 
                    ob && ob.dep.notify());
                }
            }
            Observer.prototype.walk = function(obj) {
                for (var keys = Object.keys(obj), i = 0; i < keys.length; i++) defineReactive(obj, keys[i]);
            }, 
            /**
 * Observe a list of Array items.
 */
            Observer.prototype.observeArray = function(items) {
                for (var i = 0, l = items.length; i < l; i++) observe(items[i]);
            };
            var strats = config.optionMergeStrategies;
            /**
 * Options with restrictions
 */            
            /**
 * Helper that recursively merges two data objects together.
 */
            function mergeData(to, from) {
                if (!from) return to;
                for (var key, toVal, fromVal, keys = Object.keys(from), i = 0; i < keys.length; i++) toVal = to[key = keys[i]], 
                fromVal = from[key], hasOwn(to, key) ? isPlainObject(toVal) && isPlainObject(fromVal) && mergeData(toVal, fromVal) : set(to, key, fromVal);
                return to;
            }
            /**
 * Data
 */            function mergeDataOrFn(parentVal, childVal, vm) {
                return vm ? function() {
                    // instance merge
                    var instanceData = "function" == typeof childVal ? childVal.call(vm, vm) : childVal, defaultData = "function" == typeof parentVal ? parentVal.call(vm, vm) : parentVal;
                    return instanceData ? mergeData(instanceData, defaultData) : defaultData;
                } : 
                // in a Vue.extend merge, both should be functions
                childVal ? parentVal ? function() {
                    return mergeData("function" == typeof childVal ? childVal.call(this, this) : childVal, "function" == typeof parentVal ? parentVal.call(this, this) : parentVal);
                } : childVal : parentVal;
            }
            /**
 * Hooks and props are merged as arrays.
 */
            function mergeHook(parentVal, childVal) {
                return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [ childVal ] : parentVal;
            }
            /**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
            function mergeAssets(parentVal, childVal, vm, key) {
                var res = Object.create(parentVal || null);
                return childVal ? ("production" !== process.env.NODE_ENV && assertObjectType(key, childVal, vm), 
                extend(res, childVal)) : res;
            }
            "production" !== process.env.NODE_ENV && (strats.el = strats.propsData = function(parent, child, vm, key) {
                return vm || warn('option "' + key + '" can only be used during instance creation with the `new` keyword.'), 
                defaultStrat(parent, child);
            }), strats.data = function(parentVal, childVal, vm) {
                return vm ? mergeDataOrFn(parentVal, childVal, vm) : childVal && "function" != typeof childVal ? ("production" !== process.env.NODE_ENV && warn('The "data" option should be a function that returns a per-instance value in component definitions.', vm), 
                parentVal) : mergeDataOrFn(parentVal, childVal);
            }, LIFECYCLE_HOOKS.forEach(function(hook) {
                strats[hook] = mergeHook;
            }), ASSET_TYPES.forEach(function(type) {
                strats[type + "s"] = mergeAssets;
            }), 
            /**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
            strats.watch = function(parentVal, childVal, vm, key) {
                /* istanbul ignore if */
                if (
                // work around Firefox's Object.prototype.watch...
                parentVal === nativeWatch && (parentVal = void 0), childVal === nativeWatch && (childVal = void 0), 
                !childVal) return Object.create(parentVal || null);
                if ("production" !== process.env.NODE_ENV && assertObjectType(key, childVal, vm), 
                !parentVal) return childVal;
                var ret = {};
                for (var key$1 in extend(ret, parentVal), childVal) {
                    var parent = ret[key$1], child = childVal[key$1];
                    parent && !Array.isArray(parent) && (parent = [ parent ]), ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [ child ];
                }
                return ret;
            }, 
            /**
 * Other object hashes.
 */
            strats.props = strats.methods = strats.inject = strats.computed = function(parentVal, childVal, vm, key) {
                if (childVal && "production" !== process.env.NODE_ENV && assertObjectType(key, childVal, vm), 
                !parentVal) return childVal;
                var ret = Object.create(null);
                return extend(ret, parentVal), childVal && extend(ret, childVal), ret;
            }, strats.provide = mergeDataOrFn;
            /**
 * Default strategy.
 */
            var defaultStrat = function(parentVal, childVal) {
                return void 0 === childVal ? parentVal : childVal;
            };
            /**
 * Validate component names
 */            function validateComponentName(name) {
                /^[a-zA-Z][\w-]*$/.test(name) || warn('Invalid component name: "' + name + '". Component names can only contain alphanumeric characters and the hyphen, and must start with a letter.'), 
                (isBuiltInTag(name) || config.isReservedTag(name)) && warn("Do not use built-in or reserved HTML elements as component id: " + name);
            }
            /**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */            function assertObjectType(name, value, vm) {
                isPlainObject(value) || warn('Invalid value for option "' + name + '": expected an Object, but got ' + toRawType(value) + ".", vm);
            }
            /**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */            function mergeOptions(parent, child, vm) {
                "production" !== process.env.NODE_ENV && function(options) {
                    for (var key in options.components) validateComponentName(key);
                }(child), "function" == typeof child && (child = child.options), function(options, vm) {
                    var props = options.props;
                    if (props) {
                        var i, val, res = {};
                        if (Array.isArray(props)) for (i = props.length; i--; ) "string" == typeof (val = props[i]) ? res[camelize(val)] = {
                            type: null
                        } : "production" !== process.env.NODE_ENV && warn("props must be strings when using array syntax."); else if (isPlainObject(props)) for (var key in props) val = props[key], 
                        res[camelize(key)] = isPlainObject(val) ? val : {
                            type: val
                        }; else "production" !== process.env.NODE_ENV && warn('Invalid value for option "props": expected an Array or an Object, but got ' + toRawType(props) + ".", vm);
                        options.props = res;
                    }
                }
                /**
 * Normalize all injections into Object-based format
 */ (child, vm), function(options, vm) {
                    var inject = options.inject;
                    if (inject) {
                        var normalized = options.inject = {};
                        if (Array.isArray(inject)) for (var i = 0; i < inject.length; i++) normalized[inject[i]] = {
                            from: inject[i]
                        }; else if (isPlainObject(inject)) for (var key in inject) {
                            var val = inject[key];
                            normalized[key] = isPlainObject(val) ? extend({
                                from: key
                            }, val) : {
                                from: val
                            };
                        } else "production" !== process.env.NODE_ENV && warn('Invalid value for option "inject": expected an Array or an Object, but got ' + toRawType(inject) + ".", vm);
                    }
                }
                /**
 * Normalize raw function directives into object format.
 */ (child, vm), function(options) {
                    var dirs = options.directives;
                    if (dirs) for (var key in dirs) {
                        var def = dirs[key];
                        "function" == typeof def && (dirs[key] = {
                            bind: def,
                            update: def
                        });
                    }
                }(child);
                var extendsFrom = child.extends;
                if (extendsFrom && (parent = mergeOptions(parent, extendsFrom, vm)), child.mixins) for (var i = 0, l = child.mixins.length; i < l; i++) parent = mergeOptions(parent, child.mixins[i], vm);
                var key, options = {};
                for (key in parent) mergeField(key);
                for (key in child) hasOwn(parent, key) || mergeField(key);
                function mergeField(key) {
                    var strat = strats[key] || defaultStrat;
                    options[key] = strat(parent[key], child[key], vm, key);
                }
                return options;
            }
            /**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */            function resolveAsset(options, type, id, warnMissing) {
                /* istanbul ignore if */
                if ("string" == typeof id) {
                    var assets = options[type];
                    // check local registration variations first
                                        if (hasOwn(assets, id)) return assets[id];
                    var camelizedId = camelize(id);
                    if (hasOwn(assets, camelizedId)) return assets[camelizedId];
                    var PascalCaseId = capitalize(camelizedId);
                    if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId];
                    // fallback to prototype chain
                                        var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
                    return "production" !== process.env.NODE_ENV && warnMissing && !res && warn("Failed to resolve " + type.slice(0, -1) + ": " + id, options), 
                    res;
                }
            }
            /*  */            function validateProp(key, propOptions, propsData, vm) {
                var prop = propOptions[key], absent = !hasOwn(propsData, key), value = propsData[key], booleanIndex = getTypeIndex(Boolean, prop.type);
                if (booleanIndex > -1) if (absent && !hasOwn(prop, "default")) value = !1; else if ("" === value || value === hyphenate(key)) {
                    // only cast empty string / same name to boolean if
                    // boolean has higher priority
                    var stringIndex = getTypeIndex(String, prop.type);
                    (stringIndex < 0 || booleanIndex < stringIndex) && (value = !0);
                }
                // check default value
                                if (void 0 === value) {
                    value = 
                    /**
 * Get the default value of a prop.
 */
                    function(vm, prop, key) {
                        // no default, return undefined
                        if (!hasOwn(prop, "default")) return;
                        var def = prop.default;
                        // warn against non-factory defaults for Object & Array
                                                "production" !== process.env.NODE_ENV && isObject(def) && warn('Invalid default value for prop "' + key + '": Props with type Object/Array must use a factory function to return the default value.', vm);
                        // the raw prop value was also undefined from previous render,
                        // return previous default value to avoid unnecessary watcher trigger
                                                if (vm && vm.$options.propsData && void 0 === vm.$options.propsData[key] && void 0 !== vm._props[key]) return vm._props[key];
                        // call factory function for non-Function types
                        // a value is Function if its prototype is function even across different execution context
                                                return "function" == typeof def && "Function" !== getType(prop.type) ? def.call(vm) : def;
                    }
                    /**
 * Assert whether a prop is valid.
 */ (vm, prop, key);
                    // since the default value is a fresh copy,
                    // make sure to observe it.
                    var prevShouldObserve = shouldObserve;
                    toggleObserving(!0), observe(value), toggleObserving(prevShouldObserve);
                }
                return "production" !== process.env.NODE_ENV && function(prop, name, value, vm, absent) {
                    if (prop.required && absent) return void warn('Missing required prop: "' + name + '"', vm);
                    if (null == value && !prop.required) return;
                    var type = prop.type, valid = !type || !0 === type, expectedTypes = [];
                    if (type) {
                        Array.isArray(type) || (type = [ type ]);
                        for (var i = 0; i < type.length && !valid; i++) {
                            var assertedType = assertType(value, type[i]);
                            expectedTypes.push(assertedType.expectedType || ""), valid = assertedType.valid;
                        }
                    }
                    if (!valid) return void warn('Invalid prop: type check failed for prop "' + name + '". Expected ' + expectedTypes.map(capitalize).join(", ") + ", got " + toRawType(value) + ".", vm);
                    var validator = prop.validator;
                    validator && (validator(value) || warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm));
                }(prop, key, value, vm, absent), value;
            }
            var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;
            function assertType(value, type) {
                var valid, expectedType = getType(type);
                if (simpleCheckRE.test(expectedType)) {
                    var t = typeof value;
                    // for primitive wrapper objects
                    (valid = t === expectedType.toLowerCase()) || "object" !== t || (valid = value instanceof type);
                } else valid = "Object" === expectedType ? isPlainObject(value) : "Array" === expectedType ? Array.isArray(value) : value instanceof type;
                return {
                    valid: valid,
                    expectedType: expectedType
                };
            }
            /**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */            function getType(fn) {
                var match = fn && fn.toString().match(/^\s*function (\w+)/);
                return match ? match[1] : "";
            }
            function isSameType(a, b) {
                return getType(a) === getType(b);
            }
            function getTypeIndex(type, expectedTypes) {
                if (!Array.isArray(expectedTypes)) return isSameType(expectedTypes, type) ? 0 : -1;
                for (var i = 0, len = expectedTypes.length; i < len; i++) if (isSameType(expectedTypes[i], type)) return i;
                return -1;
            }
            /*  */            function handleError(err, vm, info) {
                if (vm) for (var cur = vm; cur = cur.$parent; ) {
                    var hooks = cur.$options.errorCaptured;
                    if (hooks) for (var i = 0; i < hooks.length; i++) try {
                        if (!1 === hooks[i].call(cur, err, vm, info)) return;
                    } catch (e) {
                        globalHandleError(e, cur, "errorCaptured hook");
                    }
                }
                globalHandleError(err, vm, info);
            }
            function globalHandleError(err, vm, info) {
                if (config.errorHandler) try {
                    return config.errorHandler.call(null, err, vm, info);
                } catch (e) {
                    logError(e, null, "config.errorHandler");
                }
                logError(err, vm, info);
            }
            function logError(err, vm, info) {
                /* istanbul ignore else */
                if ("production" !== process.env.NODE_ENV && warn("Error in " + info + ': "' + err.toString() + '"', vm), 
                !inBrowser && !inWeex || "undefined" == typeof console) throw err;
                console.error(err);
            }
            /*  */
            /* globals MessageChannel */            var microTimerFunc, macroTimerFunc, callbacks = [], pending = !1;
            function flushCallbacks() {
                pending = !1;
                var copies = callbacks.slice(0);
                callbacks.length = 0;
                for (var i = 0; i < copies.length; i++) copies[i]();
            }
            // Here we have async deferring wrappers using both microtasks and (macro) tasks.
            // In < 2.4 we used microtasks everywhere, but there are some scenarios where
            // microtasks have too high a priority and fire in between supposedly
            // sequential events (e.g. #4521, #6690) or even between bubbling of the same
            // event (#6566). However, using (macro) tasks everywhere also has subtle problems
            // when state is changed right before repaint (e.g. #6813, out-in transitions).
            // Here we use microtask by default, but expose a way to force (macro) task when
            // needed (e.g. in event handlers attached by v-on).
                        var initProxy, useMacroTask = !1;
            // Determine (macro) task defer implementation.
            // Technically setImmediate should be the ideal choice, but it's only available
            // in IE. The only polyfill that consistently queues the callback after all DOM
            // events triggered in the same loop is by using MessageChannel.
            /* istanbul ignore if */            if (void 0 !== setImmediate && isNative(setImmediate)) macroTimerFunc = function() {
                setImmediate(flushCallbacks);
            }; else if ("undefined" == typeof MessageChannel || !isNative(MessageChannel) && 
            // PhantomJS
            "[object MessageChannelConstructor]" !== MessageChannel.toString()) 
            /* istanbul ignore next */
            macroTimerFunc = function() {
                setTimeout(flushCallbacks, 0);
            }; else {
                var channel = new MessageChannel(), port = channel.port2;
                channel.port1.onmessage = flushCallbacks, macroTimerFunc = function() {
                    port.postMessage(1);
                };
            }
            // Determine microtask defer implementation.
            /* istanbul ignore next, $flow-disable-line */            if ("undefined" != typeof Promise && isNative(Promise)) {
                var p = Promise.resolve();
                microTimerFunc = function() {
                    p.then(flushCallbacks), 
                    // in problematic UIWebViews, Promise.then doesn't completely break, but
                    // it can get stuck in a weird state where callbacks are pushed into the
                    // microtask queue but the queue isn't being flushed, until the browser
                    // needs to do some other work, e.g. handle a timer. Therefore we can
                    // "force" the microtask queue to be flushed by adding an empty timer.
                    isIOS && setTimeout(noop);
                };
            } else 
            // fallback to macro
            microTimerFunc = macroTimerFunc;
            /**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a (macro) task instead of a microtask.
 */            function nextTick(cb, ctx) {
                var _resolve;
                // $flow-disable-line
                if (callbacks.push(function() {
                    if (cb) try {
                        cb.call(ctx);
                    } catch (e) {
                        handleError(e, ctx, "nextTick");
                    } else _resolve && _resolve(ctx);
                }), pending || (pending = !0, useMacroTask ? macroTimerFunc() : microTimerFunc()), 
                !cb && "undefined" != typeof Promise) return new Promise(function(resolve) {
                    _resolve = resolve;
                });
            }
            /*  */
            /* not type checking this file because flow doesn't play well with Proxy */            if ("production" !== process.env.NODE_ENV) {
                var allowedGlobals = makeMap("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,require"), warnNonPresent = function(target, key) {
                    warn('Property or method "' + key + '" is not defined on the instance but referenced during render. Make sure that this property is reactive, either in the data option, or for class-based components, by initializing the property. See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
                }, hasProxy = "undefined" != typeof Proxy && isNative(Proxy);
                if (hasProxy) {
                    var isBuiltInModifier = makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact");
                    config.keyCodes = new Proxy(config.keyCodes, {
                        set: function(target, key, value) {
                            return isBuiltInModifier(key) ? (warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key), 
                            !1) : (target[key] = value, !0);
                        }
                    });
                }
                var hasHandler = {
                    has: function(target, key) {
                        var has = key in target, isAllowed = allowedGlobals(key) || "_" === key.charAt(0);
                        return has || isAllowed || warnNonPresent(target, key), has || !isAllowed;
                    }
                }, getHandler = {
                    get: function(target, key) {
                        return "string" != typeof key || key in target || warnNonPresent(target, key), target[key];
                    }
                };
                initProxy = function(vm) {
                    if (hasProxy) {
                        // determine which proxy handler to use
                        var options = vm.$options, handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
                        vm._renderProxy = new Proxy(vm, handlers);
                    } else vm._renderProxy = vm;
                };
            }
            /*  */            var mark, measure, seenObjects = new _Set();
            /**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */            function traverse(val) {
                !function _traverse(val, seen) {
                    var i, keys;
                    var isA = Array.isArray(val);
                    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) return;
                    if (val.__ob__) {
                        var depId = val.__ob__.dep.id;
                        if (seen.has(depId)) return;
                        seen.add(depId);
                    }
                    if (isA) for (i = val.length; i--; ) _traverse(val[i], seen); else for (keys = Object.keys(val), 
                    i = keys.length; i--; ) _traverse(val[keys[i]], seen);
                }(val, seenObjects), seenObjects.clear();
            }
            if ("production" !== process.env.NODE_ENV) {
                var perf = inBrowser && window.performance;
                /* istanbul ignore if */                perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures && (mark = function(tag) {
                    return perf.mark(tag);
                }, measure = function(name, startTag, endTag) {
                    perf.measure(name, startTag, endTag), perf.clearMarks(startTag), perf.clearMarks(endTag), 
                    perf.clearMeasures(name);
                });
            }
            /*  */            var target, normalizeEvent = cached(function(name) {
                var passive = "&" === name.charAt(0), once$$1 = "~" === (name = passive ? name.slice(1) : name).charAt(0), capture = "!" === (// Prefixed last, checked first
                name = once$$1 ? name.slice(1) : name).charAt(0);
                return {
                    name: name = capture ? name.slice(1) : name,
                    once: once$$1,
                    capture: capture,
                    passive: passive
                };
            });
            function createFnInvoker(fns) {
                function invoker() {
                    var arguments$1 = arguments, fns = invoker.fns;
                    if (!Array.isArray(fns)) 
                    // return handler return value for single handlers
                    return fns.apply(null, arguments);
                    for (var cloned = fns.slice(), i = 0; i < cloned.length; i++) cloned[i].apply(null, arguments$1);
                }
                return invoker.fns = fns, invoker;
            }
            function updateListeners(on, oldOn, add, remove$$1, vm) {
                var name, cur, old, event;
                for (name in on) cur = on[name], old = oldOn[name], event = normalizeEvent(name), 
                /* istanbul ignore if */
                isUndef(cur) ? "production" !== process.env.NODE_ENV && warn('Invalid handler for event "' + event.name + '": got ' + String(cur), vm) : isUndef(old) ? (isUndef(cur.fns) && (cur = on[name] = createFnInvoker(cur)), 
                add(event.name, cur, event.once, event.capture, event.passive, event.params)) : cur !== old && (old.fns = cur, 
                on[name] = old);
                for (name in oldOn) isUndef(on[name]) && remove$$1((event = normalizeEvent(name)).name, oldOn[name], event.capture);
            }
            /*  */            function mergeVNodeHook(def, hookKey, hook) {
                var invoker;
                def instanceof VNode && (def = def.data.hook || (def.data.hook = {}));
                var oldHook = def[hookKey];
                function wrappedHook() {
                    hook.apply(this, arguments), 
                    // important: remove merged hook to ensure it's called only once
                    // and prevent memory leak
                    remove(invoker.fns, wrappedHook);
                }
                isUndef(oldHook) ? 
                // no existing hook
                invoker = createFnInvoker([ wrappedHook ]) : 
                /* istanbul ignore if */
                isDef(oldHook.fns) && isTrue(oldHook.merged) ? (
                // already a merged invoker
                invoker = oldHook).fns.push(wrappedHook) : 
                // existing plain hook
                invoker = createFnInvoker([ oldHook, wrappedHook ]), invoker.merged = !0, def[hookKey] = invoker;
            }
            /*  */            function checkProp(res, hash, key, altKey, preserve) {
                if (isDef(hash)) {
                    if (hasOwn(hash, key)) return res[key] = hash[key], preserve || delete hash[key], 
                    !0;
                    if (hasOwn(hash, altKey)) return res[key] = hash[altKey], preserve || delete hash[altKey], 
                    !0;
                }
                return !1;
            }
            /*  */
            // The template compiler attempts to minimize the need for normalization by
            // statically analyzing the template at compile time.
            //
            // For plain HTML markup, normalization can be completely skipped because the
            // generated render function is guaranteed to return Array<VNode>. There are
            // two cases where extra normalization is needed:
            // 1. When the children contains components - because a functional component
            // may return an Array instead of a single root. In this case, just a simple
            // normalization is needed - if any child is an Array, we flatten the whole
            // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
            // because functional components already normalize their own children.
                        // 2. When the children contains constructs that always generated nested Arrays,
            // e.g. <template>, <slot>, v-for, or when the children is provided by user
            // with hand-written render functions / JSX. In such cases a full normalization
            // is needed to cater to all possible types of children values.
            function normalizeChildren(children) {
                return isPrimitive(children) ? [ createTextVNode(children) ] : Array.isArray(children) ? function normalizeArrayChildren(children, nestedIndex) {
                    var res = [];
                    var i, c, lastIndex, last;
                    for (i = 0; i < children.length; i++) isUndef(c = children[i]) || "boolean" == typeof c || (lastIndex = res.length - 1, 
                    last = res[lastIndex], 
                    //  nested
                    Array.isArray(c) ? c.length > 0 && (
                    // merge adjacent text nodes
                    isTextNode((c = normalizeArrayChildren(c, (nestedIndex || "") + "_" + i))[0]) && isTextNode(last) && (res[lastIndex] = createTextVNode(last.text + c[0].text), 
                    c.shift()), res.push.apply(res, c)) : isPrimitive(c) ? isTextNode(last) ? 
                    // merge adjacent text nodes
                    // this is necessary for SSR hydration because text nodes are
                    // essentially merged when rendered to HTML strings
                    res[lastIndex] = createTextVNode(last.text + c) : "" !== c && 
                    // convert primitive to vnode
                    res.push(createTextVNode(c)) : isTextNode(c) && isTextNode(last) ? 
                    // merge adjacent text nodes
                    res[lastIndex] = createTextVNode(last.text + c.text) : (
                    // default key for nested array children (likely generated by v-for)
                    isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex) && (c.key = "__vlist" + nestedIndex + "_" + i + "__"), 
                    res.push(c)));
                    return res;
                }
                /*  */ (children) : void 0;
            }
            function isTextNode(node) {
                return isDef(node) && isDef(node.text) && !1 === node.isComment;
            }
            function ensureCtor(comp, base) {
                return (comp.__esModule || hasSymbol && "Module" === comp[Symbol.toStringTag]) && (comp = comp.default), 
                isObject(comp) ? base.extend(comp) : comp;
            }
            /*  */
            function isAsyncPlaceholder(node) {
                return node.isComment && node.asyncFactory;
            }
            /*  */            function getFirstComponentChild(children) {
                if (Array.isArray(children)) for (var i = 0; i < children.length; i++) {
                    var c = children[i];
                    if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) return c;
                }
            }
            /*  */
            /*  */            function add(event, fn, once) {
                once ? target.$once(event, fn) : target.$on(event, fn);
            }
            function remove$1(event, fn) {
                target.$off(event, fn);
            }
            function updateComponentListeners(vm, listeners, oldListeners) {
                target = vm, updateListeners(listeners, oldListeners || {}, add, remove$1, vm), 
                target = void 0;
            }
            /*  */
            /**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
            function resolveSlots(children, context) {
                var slots = {};
                if (!children) return slots;
                for (var i = 0, l = children.length; i < l; i++) {
                    var child = children[i], data = child.data;
                    // named slots should only be respected if the vnode was rendered in the
                    // same context.
                    if (
                    // remove slot attribute if the node is resolved as a Vue slot node
                    data && data.attrs && data.attrs.slot && delete data.attrs.slot, child.context !== context && child.fnContext !== context || !data || null == data.slot) (slots.default || (slots.default = [])).push(child); else {
                        var name = data.slot, slot = slots[name] || (slots[name] = []);
                        "template" === child.tag ? slot.push.apply(slot, child.children || []) : slot.push(child);
                    }
                }
                // ignore slots that contains only whitespace
                                for (var name$1 in slots) slots[name$1].every(isWhitespace) && delete slots[name$1];
                return slots;
            }
            function isWhitespace(node) {
                return node.isComment && !node.asyncFactory || " " === node.text;
            }
            function resolveScopedSlots(fns, // see flow/vnode
            res) {
                res = res || {};
                for (var i = 0; i < fns.length; i++) Array.isArray(fns[i]) ? resolveScopedSlots(fns[i], res) : res[fns[i].key] = fns[i].fn;
                return res;
            }
            /*  */            var activeInstance = null, isUpdatingChildComponent = !1;
            function isInInactiveTree(vm) {
                for (;vm && (vm = vm.$parent); ) if (vm._inactive) return !0;
                return !1;
            }
            function activateChildComponent(vm, direct) {
                if (direct) {
                    if (vm._directInactive = !1, isInInactiveTree(vm)) return;
                } else if (vm._directInactive) return;
                if (vm._inactive || null === vm._inactive) {
                    vm._inactive = !1;
                    for (var i = 0; i < vm.$children.length; i++) activateChildComponent(vm.$children[i]);
                    callHook(vm, "activated");
                }
            }
            function callHook(vm, hook) {
                // #7573 disable dep collection when invoking lifecycle hooks
                pushTarget();
                var handlers = vm.$options[hook];
                if (handlers) for (var i = 0, j = handlers.length; i < j; i++) try {
                    handlers[i].call(vm);
                } catch (e) {
                    handleError(e, vm, hook + " hook");
                }
                vm._hasHookEvent && vm.$emit("hook:" + hook), popTarget();
            }
            /*  */            var MAX_UPDATE_COUNT = 100, queue = [], activatedChildren = [], has = {}, circular = {}, waiting = !1, flushing = !1, index = 0;
            /**
 * Flush both queues and run the watchers.
 */
            function flushSchedulerQueue() {
                var watcher, id;
                // Sort queue before flush.
                // This ensures that:
                // 1. Components are updated from parent to child. (because parent is always
                //    created before the child)
                // 2. A component's user watchers are run before its render watcher (because
                //    user watchers are created before the render watcher)
                // 3. If a component is destroyed during a parent component's watcher run,
                //    its watchers can be skipped.
                                // do not cache length because more watchers might be pushed
                // as we run existing watchers
                for (flushing = !0, queue.sort(function(a, b) {
                    return a.id - b.id;
                }), index = 0; index < queue.length; index++) 
                // in dev build, check and stop circular updates.
                if (id = (watcher = queue[index]).id, has[id] = null, watcher.run(), "production" !== process.env.NODE_ENV && null != has[id] && (circular[id] = (circular[id] || 0) + 1, 
                circular[id] > MAX_UPDATE_COUNT)) {
                    warn("You may have an infinite update loop " + (watcher.user ? 'in watcher with expression "' + watcher.expression + '"' : "in a component render function."), watcher.vm);
                    break;
                }
                // keep copies of post queues before resetting state
                                var activatedQueue = activatedChildren.slice(), updatedQueue = queue.slice();
                index = queue.length = activatedChildren.length = 0, has = {}, "production" !== process.env.NODE_ENV && (circular = {}), 
                waiting = flushing = !1, 
                // call component updated and activated hooks
                function(queue) {
                    for (var i = 0; i < queue.length; i++) queue[i]._inactive = !0, activateChildComponent(queue[i], !0 /* true */);
                }
                /**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */ (activatedQueue), function(queue) {
                    var i = queue.length;
                    for (;i--; ) {
                        var watcher = queue[i], vm = watcher.vm;
                        vm._watcher === watcher && vm._isMounted && callHook(vm, "updated");
                    }
                }
                /**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */ (updatedQueue), 
                // devtool hook
                /* istanbul ignore if */
                devtools && config.devtools && devtools.emit("flush");
            }
            /*  */
            var uid$1 = 0, Watcher = function(vm, expOrFn, cb, options, isRenderWatcher) {
                this.vm = vm, isRenderWatcher && (vm._watcher = this), vm._watchers.push(this), 
                // options
                options ? (this.deep = !!options.deep, this.user = !!options.user, this.lazy = !!options.lazy, 
                this.sync = !!options.sync) : this.deep = this.user = this.lazy = this.sync = !1, 
                this.cb = cb, this.id = ++uid$1, // uid for batching
                this.active = !0, this.dirty = this.lazy, // for lazy watchers
                this.deps = [], this.newDeps = [], this.depIds = new _Set(), this.newDepIds = new _Set(), 
                this.expression = "production" !== process.env.NODE_ENV ? expOrFn.toString() : "", 
                // parse expression for getter
                "function" == typeof expOrFn ? this.getter = expOrFn : (this.getter = function(path) {
                    if (!bailRE.test(path)) {
                        var segments = path.split(".");
                        return function(obj) {
                            for (var i = 0; i < segments.length; i++) {
                                if (!obj) return;
                                obj = obj[segments[i]];
                            }
                            return obj;
                        };
                    }
                }(expOrFn), this.getter || (this.getter = function() {}, "production" !== process.env.NODE_ENV && warn('Failed watching path: "' + expOrFn + '" Watcher only accepts simple dot-delimited paths. For full control, use a function instead.', vm))), 
                this.value = this.lazy ? void 0 : this.get();
            };
            /**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */            
            /**
 * Evaluate the getter, and re-collect dependencies.
 */
            Watcher.prototype.get = function() {
                var value;
                pushTarget(this);
                var vm = this.vm;
                try {
                    value = this.getter.call(vm, vm);
                } catch (e) {
                    if (!this.user) throw e;
                    handleError(e, vm, 'getter for watcher "' + this.expression + '"');
                } finally {
                    // "touch" every property so they are all tracked as
                    // dependencies for deep watching
                    this.deep && traverse(value), popTarget(), this.cleanupDeps();
                }
                return value;
            }, 
            /**
 * Add a dependency to this directive.
 */
            Watcher.prototype.addDep = function(dep) {
                var id = dep.id;
                this.newDepIds.has(id) || (this.newDepIds.add(id), this.newDeps.push(dep), this.depIds.has(id) || dep.addSub(this));
            }, 
            /**
 * Clean up for dependency collection.
 */
            Watcher.prototype.cleanupDeps = function() {
                for (var i = this.deps.length; i--; ) {
                    var dep = this.deps[i];
                    this.newDepIds.has(dep.id) || dep.removeSub(this);
                }
                var tmp = this.depIds;
                this.depIds = this.newDepIds, this.newDepIds = tmp, this.newDepIds.clear(), tmp = this.deps, 
                this.deps = this.newDeps, this.newDeps = tmp, this.newDeps.length = 0;
            }, 
            /**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
            Watcher.prototype.update = function() {
                /* istanbul ignore else */
                this.lazy ? this.dirty = !0 : this.sync ? this.run() : function(watcher) {
                    var id = watcher.id;
                    if (null == has[id]) {
                        if (has[id] = !0, flushing) {
                            for (
                            // if already flushing, splice the watcher based on its id
                            // if already past its id, it will be run next immediately.
                            var i = queue.length - 1; i > index && queue[i].id > watcher.id; ) i--;
                            queue.splice(i + 1, 0, watcher);
                        }
                        // queue the flush
                         else queue.push(watcher);
                        waiting || (waiting = !0, nextTick(flushSchedulerQueue));
                    }
                }(this);
            }, 
            /**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
            Watcher.prototype.run = function() {
                if (this.active) {
                    var value = this.get();
                    if (value !== this.value || 
                    // Deep watchers and watchers on Object/Arrays should fire even
                    // when the value is the same, because the value may
                    // have mutated.
                    isObject(value) || this.deep) {
                        // set new value
                        var oldValue = this.value;
                        if (this.value = value, this.user) try {
                            this.cb.call(this.vm, value, oldValue);
                        } catch (e) {
                            handleError(e, this.vm, 'callback for watcher "' + this.expression + '"');
                        } else this.cb.call(this.vm, value, oldValue);
                    }
                }
            }, 
            /**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
            Watcher.prototype.evaluate = function() {
                this.value = this.get(), this.dirty = !1;
            }, 
            /**
 * Depend on all deps collected by this watcher.
 */
            Watcher.prototype.depend = function() {
                for (var i = this.deps.length; i--; ) this.deps[i].depend();
            }, 
            /**
 * Remove self from all dependencies' subscriber list.
 */
            Watcher.prototype.teardown = function() {
                if (this.active) {
                    // remove self from vm's watcher list
                    // this is a somewhat expensive operation so we skip it
                    // if the vm is being destroyed.
                    this.vm._isBeingDestroyed || remove(this.vm._watchers, this);
                    for (var i = this.deps.length; i--; ) this.deps[i].removeSub(this);
                    this.active = !1;
                }
            };
            /*  */
            var sharedPropertyDefinition = {
                enumerable: !0,
                configurable: !0,
                get: noop,
                set: noop
            };
            function proxy(target, sourceKey, key) {
                sharedPropertyDefinition.get = function() {
                    return this[sourceKey][key];
                }, sharedPropertyDefinition.set = function(val) {
                    this[sourceKey][key] = val;
                }, Object.defineProperty(target, key, sharedPropertyDefinition);
            }
            function initState(vm) {
                vm._watchers = [];
                var opts = vm.$options;
                opts.props && function(vm, propsOptions) {
                    var propsData = vm.$options.propsData || {}, props = vm._props = {}, keys = vm.$options._propKeys = [];
                    // root instance props should be converted
                    vm.$parent && toggleObserving(!1);
                    var loop = function(key) {
                        keys.push(key);
                        var value = validateProp(key, propsOptions, propsData, vm);
                        /* istanbul ignore else */                        if ("production" !== process.env.NODE_ENV) {
                            var hyphenatedKey = hyphenate(key);
                            (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) && warn('"' + hyphenatedKey + '" is a reserved attribute and cannot be used as component prop.', vm), 
                            defineReactive(props, key, value, function() {
                                vm.$parent && !isUpdatingChildComponent && warn("Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: \"" + key + '"', vm);
                            });
                        } else defineReactive(props, key, value);
                        // static props are already proxied on the component's prototype
                        // during Vue.extend(). We only need to proxy props defined at
                        // instantiation here.
                                                key in vm || proxy(vm, "_props", key);
                    };
                    for (var key in propsOptions) loop(key);
                    toggleObserving(!0);
                }(vm, opts.props), opts.methods && function(vm, methods) {
                    var props = vm.$options.props;
                    for (var key in methods) "production" !== process.env.NODE_ENV && (null == methods[key] && warn('Method "' + key + '" has an undefined value in the component definition. Did you reference the function correctly?', vm), 
                    props && hasOwn(props, key) && warn('Method "' + key + '" has already been defined as a prop.', vm), 
                    key in vm && isReserved(key) && warn('Method "' + key + '" conflicts with an existing Vue instance method. Avoid defining component methods that start with _ or $.')), 
                    vm[key] = null == methods[key] ? noop : bind(methods[key], vm);
                }(vm, opts.methods), opts.data ? function(vm) {
                    var data = vm.$options.data;
                    isPlainObject(data = vm._data = "function" == typeof data ? function(data, vm) {
                        // #7573 disable dep collection when invoking data getters
                        pushTarget();
                        try {
                            return data.call(vm, vm);
                        } catch (e) {
                            return handleError(e, vm, "data()"), {};
                        } finally {
                            popTarget();
                        }
                    }(data, vm) : data || {}) || (data = {}, "production" !== process.env.NODE_ENV && warn("data functions should return an object:\nhttps://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function", vm));
                    // proxy data on instance
                                        var keys = Object.keys(data), props = vm.$options.props, methods = vm.$options.methods, i = keys.length;
                    for (;i--; ) {
                        var key = keys[i];
                        "production" !== process.env.NODE_ENV && methods && hasOwn(methods, key) && warn('Method "' + key + '" has already been defined as a data property.', vm), 
                        props && hasOwn(props, key) ? "production" !== process.env.NODE_ENV && warn('The data property "' + key + '" is already declared as a prop. Use prop default value instead.', vm) : isReserved(key) || proxy(vm, "_data", key);
                    }
                    // observe data
                                        observe(data, !0 /* asRootData */);
                }(vm) : observe(vm._data = {}, !0 /* asRootData */), opts.computed && function(vm, computed) {
                    // $flow-disable-line
                    var watchers = vm._computedWatchers = Object.create(null), isSSR = isServerRendering();
                    // computed properties are just getters during SSR
                                        for (var key in computed) {
                        var userDef = computed[key], getter = "function" == typeof userDef ? userDef : userDef.get;
                        "production" !== process.env.NODE_ENV && null == getter && warn('Getter is missing for computed property "' + key + '".', vm), 
                        isSSR || (
                        // create internal watcher for the computed property.
                        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions)), 
                        // component-defined computed properties are already defined on the
                        // component prototype. We only need to define computed properties defined
                        // at instantiation here.
                        key in vm ? "production" !== process.env.NODE_ENV && (key in vm.$data ? warn('The computed property "' + key + '" is already defined in data.', vm) : vm.$options.props && key in vm.$options.props && warn('The computed property "' + key + '" is already defined as a prop.', vm)) : defineComputed(vm, key, userDef);
                    }
                }(vm, opts.computed), opts.watch && opts.watch !== nativeWatch && function(vm, watch) {
                    for (var key in watch) {
                        var handler = watch[key];
                        if (Array.isArray(handler)) for (var i = 0; i < handler.length; i++) createWatcher(vm, key, handler[i]); else createWatcher(vm, key, handler);
                    }
                }(vm, opts.watch);
            }
            var computedWatcherOptions = {
                lazy: !0
            };
            function defineComputed(target, key, userDef) {
                var shouldCache = !isServerRendering();
                "function" == typeof userDef ? (sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef, 
                sharedPropertyDefinition.set = noop) : (sharedPropertyDefinition.get = userDef.get ? shouldCache && !1 !== userDef.cache ? createComputedGetter(key) : userDef.get : noop, 
                sharedPropertyDefinition.set = userDef.set ? userDef.set : noop), "production" !== process.env.NODE_ENV && sharedPropertyDefinition.set === noop && (sharedPropertyDefinition.set = function() {
                    warn('Computed property "' + key + '" was assigned to but it has no setter.', this);
                }), Object.defineProperty(target, key, sharedPropertyDefinition);
            }
            function createComputedGetter(key) {
                return function() {
                    var watcher = this._computedWatchers && this._computedWatchers[key];
                    if (watcher) return watcher.dirty && watcher.evaluate(), Dep.target && watcher.depend(), 
                    watcher.value;
                };
            }
            function createWatcher(vm, expOrFn, handler, options) {
                return isPlainObject(handler) && (options = handler, handler = handler.handler), 
                "string" == typeof handler && (handler = vm[handler]), vm.$watch(expOrFn, handler, options);
            }
            function resolveInject(inject, vm) {
                if (inject) {
                    for (
                    // inject is :any because flow is not smart enough to figure out cached
                    var result = Object.create(null), keys = hasSymbol ? Reflect.ownKeys(inject).filter(function(key) {
                        /* istanbul ignore next */
                        return Object.getOwnPropertyDescriptor(inject, key).enumerable;
                    }) : Object.keys(inject), i = 0; i < keys.length; i++) {
                        for (var key = keys[i], provideKey = inject[key].from, source = vm; source; ) {
                            if (source._provided && hasOwn(source._provided, provideKey)) {
                                result[key] = source._provided[provideKey];
                                break;
                            }
                            source = source.$parent;
                        }
                        if (!source) if ("default" in inject[key]) {
                            var provideDefault = inject[key].default;
                            result[key] = "function" == typeof provideDefault ? provideDefault.call(vm) : provideDefault;
                        } else "production" !== process.env.NODE_ENV && warn('Injection "' + key + '" not found', vm);
                    }
                    return result;
                }
            }
            /*  */
            /**
 * Runtime helper for rendering v-for lists.
 */            function renderList(val, render) {
                var ret, i, l, keys, key;
                if (Array.isArray(val) || "string" == typeof val) for (ret = new Array(val.length), 
                i = 0, l = val.length; i < l; i++) ret[i] = render(val[i], i); else if ("number" == typeof val) for (ret = new Array(val), 
                i = 0; i < val; i++) ret[i] = render(i + 1, i); else if (isObject(val)) for (keys = Object.keys(val), 
                ret = new Array(keys.length), i = 0, l = keys.length; i < l; i++) key = keys[i], 
                ret[i] = render(val[key], key, i);
                return isDef(ret) && (ret._isVList = !0), ret;
            }
            /*  */
            /**
 * Runtime helper for rendering <slot>
 */            function renderSlot(name, fallback, props, bindObject) {
                var nodes, scopedSlotFn = this.$scopedSlots[name];
                if (scopedSlotFn) // scoped slot
                props = props || {}, bindObject && ("production" === process.env.NODE_ENV || isObject(bindObject) || warn("slot v-bind without argument expects an Object", this), 
                props = extend(extend({}, bindObject), props)), nodes = scopedSlotFn(props) || fallback; else {
                    var slotNodes = this.$slots[name];
                    // warn duplicate slot usage
                                        slotNodes && ("production" !== process.env.NODE_ENV && slotNodes._rendered && warn('Duplicate presence of slot "' + name + '" found in the same render tree - this will likely cause render errors.', this), 
                    slotNodes._rendered = !0), nodes = slotNodes || fallback;
                }
                var target = props && props.slot;
                return target ? this.$createElement("template", {
                    slot: target
                }, nodes) : nodes;
            }
            /*  */
            /**
 * Runtime helper for resolving filters
 */            function resolveFilter(id) {
                return resolveAsset(this.$options, "filters", id, !0) || identity;
            }
            /*  */            function isKeyNotMatch(expect, actual) {
                return Array.isArray(expect) ? -1 === expect.indexOf(actual) : expect !== actual;
            }
            /**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */            function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
                var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
                return builtInKeyName && eventKeyName && !config.keyCodes[key] ? isKeyNotMatch(builtInKeyName, eventKeyName) : mappedKeyCode ? isKeyNotMatch(mappedKeyCode, eventKeyCode) : eventKeyName ? hyphenate(eventKeyName) !== key : void 0;
            }
            /*  */
            /**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */            function bindObjectProps(data, tag, value, asProp, isSync) {
                if (value) if (isObject(value)) {
                    var hash;
                    Array.isArray(value) && (value = toObject(value));
                    var loop = function(key) {
                        if ("class" === key || "style" === key || isReservedAttribute(key)) hash = data; else {
                            var type = data.attrs && data.attrs.type;
                            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
                        }
                        key in hash || (hash[key] = value[key], isSync && ((data.on || (data.on = {}))["update:" + key] = function($event) {
                            value[key] = $event;
                        }));
                    };
                    for (var key in value) loop(key);
                } else "production" !== process.env.NODE_ENV && warn("v-bind without argument expects an Object or Array value", this);
                return data;
            }
            /*  */
            /**
 * Runtime helper for rendering static trees.
 */            function renderStatic(index, isInFor) {
                var cached = this._staticTrees || (this._staticTrees = []), tree = cached[index];
                // if has already-rendered static tree and not inside v-for,
                // we can reuse the same tree.
                return tree && !isInFor ? tree : (
                // otherwise, render a fresh tree.
                markStatic(tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this), "__static__" + index, !1), 
                tree);
            }
            /**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */            function markOnce(tree, index, key) {
                return markStatic(tree, "__once__" + index + (key ? "_" + key : ""), !0), tree;
            }
            function markStatic(tree, key, isOnce) {
                if (Array.isArray(tree)) for (var i = 0; i < tree.length; i++) tree[i] && "string" != typeof tree[i] && markStaticNode(tree[i], key + "_" + i, isOnce); else markStaticNode(tree, key, isOnce);
            }
            function markStaticNode(node, key, isOnce) {
                node.isStatic = !0, node.key = key, node.isOnce = isOnce;
            }
            /*  */            function bindObjectListeners(data, value) {
                if (value) if (isPlainObject(value)) {
                    var on = data.on = data.on ? extend({}, data.on) : {};
                    for (var key in value) {
                        var existing = on[key], ours = value[key];
                        on[key] = existing ? [].concat(existing, ours) : ours;
                    }
                } else "production" !== process.env.NODE_ENV && warn("v-on without argument expects an Object value", this);
                return data;
            }
            /*  */            function installRenderHelpers(target) {
                target._o = markOnce, target._n = toNumber, target._s = toString, target._l = renderList, 
                target._t = renderSlot, target._q = looseEqual, target._i = looseIndexOf, target._m = renderStatic, 
                target._f = resolveFilter, target._k = checkKeyCodes, target._b = bindObjectProps, 
                target._v = createTextVNode, target._e = createEmptyVNode, target._u = resolveScopedSlots, 
                target._g = bindObjectListeners;
            }
            /*  */            function FunctionalRenderContext(data, props, children, parent, Ctor) {
                var contextVm, options = Ctor.options;
                // ensure the createElement function in functional components
                // gets a unique context - this is necessary for correct named slot check
                                hasOwn(parent, "_uid") ? 
                // $flow-disable-line
                (contextVm = Object.create(parent))._original = parent : (
                // the context vm passed in is a functional context as well.
                // in this case we want to make sure we are able to get a hold to the
                // real context instance.
                contextVm = parent, 
                // $flow-disable-line
                parent = parent._original);
                var isCompiled = isTrue(options._compiled), needNormalization = !isCompiled;
                this.data = data, this.props = props, this.children = children, this.parent = parent, 
                this.listeners = data.on || emptyObject, this.injections = resolveInject(options.inject, parent), 
                this.slots = function() {
                    return resolveSlots(children, parent);
                }, 
                // support for compiled functional template
                isCompiled && (
                // exposing $options for renderStatic()
                this.$options = options, 
                // pre-resolve slots for renderSlot()
                this.$slots = this.slots(), this.$scopedSlots = data.scopedSlots || emptyObject), 
                options._scopeId ? this._c = function(a, b, c, d) {
                    var vnode = createElement(contextVm, a, b, c, d, needNormalization);
                    return vnode && !Array.isArray(vnode) && (vnode.fnScopeId = options._scopeId, vnode.fnContext = parent), 
                    vnode;
                } : this._c = function(a, b, c, d) {
                    return createElement(contextVm, a, b, c, d, needNormalization);
                };
            }
            function cloneAndMarkFunctionalResult(vnode, data, contextVm, options) {
                // #7817 clone node before setting fnContext, otherwise if the node is reused
                // (e.g. it was from a cached normal slot) the fnContext causes named slots
                // that should not be matched to match.
                var clone = cloneVNode(vnode);
                return clone.fnContext = contextVm, clone.fnOptions = options, data.slot && ((clone.data || (clone.data = {})).slot = data.slot), 
                clone;
            }
            function mergeProps(to, from) {
                for (var key in from) to[camelize(key)] = from[key];
            }
            /*  */
            // Register the component hook to weex native render engine.
            // The hook will be triggered by native, not javascript.
            // Updates the state of the component to weex native render engine.
            /*  */
            // https://github.com/Hanks10100/weex-native-directive/tree/master/component
            // listening on native callback
            /*  */
            /*  */
            // inline hooks to be invoked on component VNodes during patch
                        installRenderHelpers(FunctionalRenderContext.prototype);
            var componentVNodeHooks = {
                init: function(vnode, hydrating, parentElm, refElm) {
                    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
                        // kept-alive components, treat as a patch
                        var mountedNode = vnode;
 // work around flow
                                                componentVNodeHooks.prepatch(mountedNode, mountedNode);
                    } else {
                        (vnode.componentInstance = function(vnode, // we know it's MountedComponentVNode but flow doesn't
                        parent, // activeInstance in lifecycle state
                        parentElm, refElm) {
                            var options = {
                                _isComponent: !0,
                                parent: parent,
                                _parentVnode: vnode,
                                _parentElm: parentElm || null,
                                _refElm: refElm || null
                            }, inlineTemplate = vnode.data.inlineTemplate;
                            // check inline-template render functions
                                                        isDef(inlineTemplate) && (options.render = inlineTemplate.render, 
                            options.staticRenderFns = inlineTemplate.staticRenderFns);
                            return new vnode.componentOptions.Ctor(options);
                        }(vnode, activeInstance, parentElm, refElm)).$mount(hydrating ? vnode.elm : void 0, hydrating);
                    }
                },
                prepatch: function(oldVnode, vnode) {
                    var options = vnode.componentOptions;
                    !function(vm, propsData, listeners, parentVnode, renderChildren) {
                        "production" !== process.env.NODE_ENV && (isUpdatingChildComponent = !0);
                        // determine whether component has slot children
                        // we need to do this before overwriting $options._renderChildren
                                                var hasChildren = !!(renderChildren || // has new static slots
                        vm.$options._renderChildren || // has old static slots
                        parentVnode.data.scopedSlots || // has new scoped slots
                        vm.$scopedSlots !== emptyObject);
                        // update props
                        if (vm.$options._parentVnode = parentVnode, vm.$vnode = parentVnode, // update vm's placeholder node without re-render
                        vm._vnode && (// update child tree's parent
                        vm._vnode.parent = parentVnode), vm.$options._renderChildren = renderChildren, 
                        // update $attrs and $listeners hash
                        // these are also reactive so they may trigger child update if the child
                        // used them during render
                        vm.$attrs = parentVnode.data.attrs || emptyObject, vm.$listeners = listeners || emptyObject, 
                        propsData && vm.$options.props) {
                            toggleObserving(!1);
                            for (var props = vm._props, propKeys = vm.$options._propKeys || [], i = 0; i < propKeys.length; i++) {
                                var key = propKeys[i], propOptions = vm.$options.props;
                                // wtf flow?
                                props[key] = validateProp(key, propOptions, propsData, vm);
                            }
                            toggleObserving(!0), 
                            // keep a copy of raw propsData
                            vm.$options.propsData = propsData;
                        }
                        // update listeners
                                                listeners = listeners || emptyObject;
                        var oldListeners = vm.$options._parentListeners;
                        vm.$options._parentListeners = listeners, updateComponentListeners(vm, listeners, oldListeners), 
                        // resolve slots + force update if has children
                        hasChildren && (vm.$slots = resolveSlots(renderChildren, parentVnode.context), vm.$forceUpdate()), 
                        "production" !== process.env.NODE_ENV && (isUpdatingChildComponent = !1);
                    }(vnode.componentInstance = oldVnode.componentInstance, options.propsData, // updated props
                    options.listeners, // updated listeners
                    vnode, // new parent vnode
                    options.children);
                },
                insert: function(vnode) {
                    var vm, context = vnode.context, componentInstance = vnode.componentInstance;
                    componentInstance._isMounted || (componentInstance._isMounted = !0, callHook(componentInstance, "mounted")), 
                    vnode.data.keepAlive && (context._isMounted ? (
                    // vue-router#1212
                    // During updates, a kept-alive component's child components may
                    // change, so directly walking the tree here may call activated hooks
                    // on incorrect children. Instead we push them into a queue which will
                    // be processed after the whole patch process ended.
                    // setting _inactive to false here so that a render function can
                    // rely on checking whether it's in an inactive tree (e.g. router-view)
                    (vm = componentInstance)._inactive = !1, activatedChildren.push(vm)) : activateChildComponent(componentInstance, !0 /* direct */));
                },
                destroy: function(vnode) {
                    var componentInstance = vnode.componentInstance;
                    componentInstance._isDestroyed || (vnode.data.keepAlive ? function deactivateChildComponent(vm, direct) {
                        if (!(direct && (vm._directInactive = !0, isInInactiveTree(vm)) || vm._inactive)) {
                            vm._inactive = !0;
                            for (var i = 0; i < vm.$children.length; i++) deactivateChildComponent(vm.$children[i]);
                            callHook(vm, "deactivated");
                        }
                    }(componentInstance, !0 /* direct */) : componentInstance.$destroy());
                }
            }, hooksToMerge = Object.keys(componentVNodeHooks);
            function createComponent(Ctor, data, context, children, tag) {
                if (!isUndef(Ctor)) {
                    var baseCtor = context.$options._base;
                    // plain options object: turn it into a constructor
                                        // if at this stage it's not a constructor or an async component factory,
                    // reject.
                    if (isObject(Ctor) && (Ctor = baseCtor.extend(Ctor)), "function" == typeof Ctor) {
                        // async component
                        var asyncFactory;
                        if (isUndef(Ctor.cid) && void 0 === (Ctor = function(factory, baseCtor, context) {
                            if (isTrue(factory.error) && isDef(factory.errorComp)) return factory.errorComp;
                            if (isDef(factory.resolved)) return factory.resolved;
                            if (isTrue(factory.loading) && isDef(factory.loadingComp)) return factory.loadingComp;
                            if (!isDef(factory.contexts)) {
                                var contexts = factory.contexts = [ context ], sync = !0, forceRender = function() {
                                    for (var i = 0, l = contexts.length; i < l; i++) contexts[i].$forceUpdate();
                                }, resolve = once(function(res) {
                                    // cache resolved
                                    factory.resolved = ensureCtor(res, baseCtor), 
                                    // invoke callbacks only if this is not a synchronous resolve
                                    // (async resolves are shimmed as synchronous during SSR)
                                    sync || forceRender();
                                }), reject = once(function(reason) {
                                    "production" !== process.env.NODE_ENV && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : "")), 
                                    isDef(factory.errorComp) && (factory.error = !0, forceRender());
                                }), res = factory(resolve, reject);
                                // return in case resolved synchronously
                                return isObject(res) && ("function" == typeof res.then ? 
                                // () => Promise
                                isUndef(factory.resolved) && res.then(resolve, reject) : isDef(res.component) && "function" == typeof res.component.then && (res.component.then(resolve, reject), 
                                isDef(res.error) && (factory.errorComp = ensureCtor(res.error, baseCtor)), isDef(res.loading) && (factory.loadingComp = ensureCtor(res.loading, baseCtor), 
                                0 === res.delay ? factory.loading = !0 : setTimeout(function() {
                                    isUndef(factory.resolved) && isUndef(factory.error) && (factory.loading = !0, forceRender());
                                }, res.delay || 200)), isDef(res.timeout) && setTimeout(function() {
                                    isUndef(factory.resolved) && reject("production" !== process.env.NODE_ENV ? "timeout (" + res.timeout + "ms)" : null);
                                }, res.timeout))), sync = !1, factory.loading ? factory.loadingComp : factory.resolved;
                            }
                            // already pending
                            factory.contexts.push(context);
                        }(asyncFactory = Ctor, baseCtor, context))) 
                        // return a placeholder node for async component, which is rendered
                        // as a comment node but preserves all the raw information for the node.
                        // the information will be used for async server-rendering and hydration.
                        return function(factory, data, context, children, tag) {
                            var node = createEmptyVNode();
                            return node.asyncFactory = factory, node.asyncMeta = {
                                data: data,
                                context: context,
                                children: children,
                                tag: tag
                            }, node;
                        }(asyncFactory, data, context, children, tag);
                        data = data || {}, 
                        // resolve constructor options in case global mixins are applied after
                        // component constructor creation
                        resolveConstructorOptions(Ctor), 
                        // transform component v-model data into props & events
                        isDef(data.model) && 
                        // transform component v-model info (value and callback) into
                        // prop and event handler respectively.
                        function(options, data) {
                            var prop = options.model && options.model.prop || "value", event = options.model && options.model.event || "input";
                            (data.props || (data.props = {}))[prop] = data.model.value;
                            var on = data.on || (data.on = {});
                            isDef(on[event]) ? on[event] = [ data.model.callback ].concat(on[event]) : on[event] = data.model.callback;
                        }
                        /*  */ (Ctor.options, data);
                        // extract props
                        var propsData = function(data, Ctor, tag) {
                            // we are only extracting raw values here.
                            // validation and default values are handled in the child
                            // component itself.
                            var propOptions = Ctor.options.props;
                            if (!isUndef(propOptions)) {
                                var res = {}, attrs = data.attrs, props = data.props;
                                if (isDef(attrs) || isDef(props)) for (var key in propOptions) {
                                    var altKey = hyphenate(key);
                                    if ("production" !== process.env.NODE_ENV) {
                                        var keyInLowerCase = key.toLowerCase();
                                        key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase) && tip('Prop "' + keyInLowerCase + '" is passed to component ' + formatComponentName(tag || Ctor) + ', but the declared prop name is "' + key + '". Note that HTML attributes are case-insensitive and camelCased props need to use their kebab-case equivalents when using in-DOM templates. You should probably use "' + altKey + '" instead of "' + key + '".');
                                    }
                                    checkProp(res, props, key, altKey, !0) || checkProp(res, attrs, key, altKey, !1);
                                }
                                return res;
                            }
                        }(data, Ctor, tag);
                        // functional component
                                                if (isTrue(Ctor.options.functional)) return function(Ctor, propsData, data, contextVm, children) {
                            var options = Ctor.options, props = {}, propOptions = options.props;
                            if (isDef(propOptions)) for (var key in propOptions) props[key] = validateProp(key, propOptions, propsData || emptyObject); else isDef(data.attrs) && mergeProps(props, data.attrs), 
                            isDef(data.props) && mergeProps(props, data.props);
                            var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor), vnode = options.render.call(null, renderContext._c, renderContext);
                            if (vnode instanceof VNode) return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options);
                            if (Array.isArray(vnode)) {
                                for (var vnodes = normalizeChildren(vnode) || [], res = new Array(vnodes.length), i = 0; i < vnodes.length; i++) res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
                                return res;
                            }
                        }(Ctor, propsData, data, context, children);
                        // extract listeners, since these needs to be treated as
                        // child component listeners instead of DOM listeners
                                                var listeners = data.on;
                        // replace with listeners with .native modifier
                        // so it gets processed during parent component patch.
                                                if (data.on = data.nativeOn, isTrue(Ctor.options.abstract)) {
                            // abstract components do not keep anything
                            // other than props & listeners & slot
                            // work around flow
                            var slot = data.slot;
                            data = {}, slot && (data.slot = slot);
                        }
                        // install component management hooks onto the placeholder node
                                                !function(data) {
                            for (var hooks = data.hook || (data.hook = {}), i = 0; i < hooksToMerge.length; i++) {
                                var key = hooksToMerge[i];
                                hooks[key] = componentVNodeHooks[key];
                            }
                        }(data);
                        // return a placeholder vnode
                        var name = Ctor.options.name || tag;
                        // Weex specific: invoke recycle-list optimized @render function for
                        // extracting cell-slot template.
                        // https://github.com/Hanks10100/weex-native-directive/tree/master/component
                        /* istanbul ignore if */
                        return new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ""), data, void 0, void 0, void 0, context, {
                            Ctor: Ctor,
                            propsData: propsData,
                            listeners: listeners,
                            tag: tag,
                            children: children
                        }, asyncFactory);
                    }
                    "production" !== process.env.NODE_ENV && warn("Invalid Component definition: " + String(Ctor), context);
                }
            }
            var SIMPLE_NORMALIZE = 1, ALWAYS_NORMALIZE = 2;
            // wrapper function for providing a more flexible interface
            // without getting yelled at by flow
            function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
                return (Array.isArray(data) || isPrimitive(data)) && (normalizationType = children, 
                children = data, data = void 0), isTrue(alwaysNormalize) && (normalizationType = ALWAYS_NORMALIZE), 
                function(context, tag, data, children, normalizationType) {
                    if (isDef(data) && isDef(data.__ob__)) return "production" !== process.env.NODE_ENV && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\nAlways create fresh vnode data objects in each render!", context), 
                    createEmptyVNode();
                    // object syntax in v-bind
                                        isDef(data) && isDef(data.is) && (tag = data.is);
                    if (!tag) 
                    // in case of component :is set to falsy value
                    return createEmptyVNode();
                    // warn against non-primitive key
                                        "production" !== process.env.NODE_ENV && isDef(data) && isDef(data.key) && !isPrimitive(data.key) && warn("Avoid using non-primitive value as key, use string/number value instead.", context);
                    // support single function children as default scoped slot
                                        Array.isArray(children) && "function" == typeof children[0] && ((data = data || {}).scopedSlots = {
                        default: children[0]
                    }, children.length = 0);
                    normalizationType === ALWAYS_NORMALIZE ? children = normalizeChildren(children) : normalizationType === SIMPLE_NORMALIZE && (children = function(children) {
                        for (var i = 0; i < children.length; i++) if (Array.isArray(children[i])) return Array.prototype.concat.apply([], children);
                        return children;
                    }(children));
                    var vnode, ns;
                    if ("string" == typeof tag) {
                        var Ctor;
                        ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag), 
                        // platform built-in elements
                        vnode = config.isReservedTag(tag) ? new VNode(config.parsePlatformTagName(tag), data, children, void 0, void 0, context) : isDef(Ctor = resolveAsset(context.$options, "components", tag)) ? createComponent(Ctor, data, context, children, tag) : new VNode(tag, data, children, void 0, void 0, context);
                    } else 
                    // direct component options / constructor
                    vnode = createComponent(tag, data, context, children);
                    return Array.isArray(vnode) ? vnode : isDef(vnode) ? (isDef(ns) && function applyNS(vnode, ns, force) {
                        vnode.ns = ns;
                        "foreignObject" === vnode.tag && (
                        // use default namespace inside foreignObject
                        ns = void 0, force = !0);
                        if (isDef(vnode.children)) for (var i = 0, l = vnode.children.length; i < l; i++) {
                            var child = vnode.children[i];
                            isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && "svg" !== child.tag) && applyNS(child, ns, force);
                        }
                    }
                    // ref #5318
                    // necessary to ensure parent re-render when deep bindings like :style and
                    // :class are used on slot nodes
                    (vnode, ns), isDef(data) && function(data) {
                        isObject(data.style) && traverse(data.style);
                        isObject(data.class) && traverse(data.class);
                    }
                    /*  */ (data), vnode) : createEmptyVNode();
                }(context, tag, data, children, normalizationType);
            }
            /*  */
            var uid$3 = 0;
            function resolveConstructorOptions(Ctor) {
                var options = Ctor.options;
                if (Ctor.super) {
                    var superOptions = resolveConstructorOptions(Ctor.super);
                    if (superOptions !== Ctor.superOptions) {
                        // super option changed,
                        // need to resolve new options.
                        Ctor.superOptions = superOptions;
                        // check if there are any late-modified/attached options (#4976)
                        var modifiedOptions = function(Ctor) {
                            var modified, latest = Ctor.options, extended = Ctor.extendOptions, sealed = Ctor.sealedOptions;
                            for (var key in latest) latest[key] !== sealed[key] && (modified || (modified = {}), 
                            modified[key] = dedupe(latest[key], extended[key], sealed[key]));
                            return modified;
                        }(Ctor);
                        // update base extend options
                                                modifiedOptions && extend(Ctor.extendOptions, modifiedOptions), 
                        (options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)).name && (options.components[options.name] = Ctor);
                    }
                }
                return options;
            }
            function dedupe(latest, extended, sealed) {
                // compare latest and sealed to ensure lifecycle hooks won't be duplicated
                // between merges
                if (Array.isArray(latest)) {
                    var res = [];
                    sealed = Array.isArray(sealed) ? sealed : [ sealed ], extended = Array.isArray(extended) ? extended : [ extended ];
                    for (var i = 0; i < latest.length; i++) 
                    // push original options and not sealed options to exclude duplicated options
                    (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) && res.push(latest[i]);
                    return res;
                }
                return latest;
            }
            function Vue(options) {
                "production" === process.env.NODE_ENV || this instanceof Vue || warn("Vue is a constructor and should be called with the `new` keyword"), 
                this._init(options);
            }
            /*  */
            function initExtend(Vue) {
                /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
                Vue.cid = 0;
                var cid = 1;
                /**
   * Class inheritance
   */                Vue.extend = function(extendOptions) {
                    extendOptions = extendOptions || {};
                    var Super = this, SuperId = Super.cid, cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
                    if (cachedCtors[SuperId]) return cachedCtors[SuperId];
                    var name = extendOptions.name || Super.options.name;
                    "production" !== process.env.NODE_ENV && name && validateComponentName(name);
                    var Sub = function(options) {
                        this._init(options);
                    };
                    return (Sub.prototype = Object.create(Super.prototype)).constructor = Sub, Sub.cid = cid++, 
                    Sub.options = mergeOptions(Super.options, extendOptions), Sub.super = Super, 
                    // For props and computed properties, we define the proxy getters on
                    // the Vue instances at extension time, on the extended prototype. This
                    // avoids Object.defineProperty calls for each instance created.
                    Sub.options.props && function(Comp) {
                        var props = Comp.options.props;
                        for (var key in props) proxy(Comp.prototype, "_props", key);
                    }(Sub), Sub.options.computed && function(Comp) {
                        var computed = Comp.options.computed;
                        for (var key in computed) defineComputed(Comp.prototype, key, computed[key]);
                    }
                    /*  */ (Sub), 
                    // allow further extension/mixin/plugin usage
                    Sub.extend = Super.extend, Sub.mixin = Super.mixin, Sub.use = Super.use, 
                    // create asset registers, so extended classes
                    // can have their private assets too.
                    ASSET_TYPES.forEach(function(type) {
                        Sub[type] = Super[type];
                    }), 
                    // enable recursive self-lookup
                    name && (Sub.options.components[name] = Sub), 
                    // keep a reference to the super options at extension time.
                    // later at instantiation we can check if Super's options have
                    // been updated.
                    Sub.superOptions = Super.options, Sub.extendOptions = extendOptions, Sub.sealedOptions = extend({}, Sub.options), 
                    // cache constructor
                    cachedCtors[SuperId] = Sub, Sub;
                };
            }
            /*  */
            function getComponentName(opts) {
                return opts && (opts.Ctor.options.name || opts.tag);
            }
            function matches(pattern, name) {
                return Array.isArray(pattern) ? pattern.indexOf(name) > -1 : "string" == typeof pattern ? pattern.split(",").indexOf(name) > -1 : !!isRegExp(pattern) && pattern.test(name)
                /* istanbul ignore next */;
            }
            function pruneCache(keepAliveInstance, filter) {
                var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode;
                for (var key in cache) {
                    var cachedNode = cache[key];
                    if (cachedNode) {
                        var name = getComponentName(cachedNode.componentOptions);
                        name && !filter(name) && pruneCacheEntry(cache, key, keys, _vnode);
                    }
                }
            }
            function pruneCacheEntry(cache, key, keys, current) {
                var cached$$1 = cache[key];
                !cached$$1 || current && cached$$1.tag === current.tag || cached$$1.componentInstance.$destroy(), 
                cache[key] = null, remove(keys, key);
            }
            !function(Vue) {
                Vue.prototype._init = function(options) {
                    var startTag, endTag, vm = this;
                    // a uid
                                        vm._uid = uid$3++, 
                    /* istanbul ignore if */
                    "production" !== process.env.NODE_ENV && config.performance && mark && (startTag = "vue-perf-start:" + vm._uid, 
                    endTag = "vue-perf-end:" + vm._uid, mark(startTag)), 
                    // a flag to avoid this being observed
                    vm._isVue = !0, 
                    // merge options
                    options && options._isComponent ? 
                    // optimize internal component instantiation
                    // since dynamic options merging is pretty slow, and none of the
                    // internal component options needs special treatment.
                    function(vm, options) {
                        var opts = vm.$options = Object.create(vm.constructor.options), parentVnode = options._parentVnode;
                        // doing this because it's faster than dynamic enumeration.
                                                opts.parent = options.parent, opts._parentVnode = parentVnode, 
                        opts._parentElm = options._parentElm, opts._refElm = options._refElm;
                        var vnodeComponentOptions = parentVnode.componentOptions;
                        opts.propsData = vnodeComponentOptions.propsData, opts._parentListeners = vnodeComponentOptions.listeners, 
                        opts._renderChildren = vnodeComponentOptions.children, opts._componentTag = vnodeComponentOptions.tag, 
                        options.render && (opts.render = options.render, opts.staticRenderFns = options.staticRenderFns);
                    }(vm, options) : vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm)
                    /* istanbul ignore else */ , "production" !== process.env.NODE_ENV ? initProxy(vm) : vm._renderProxy = vm, 
                    // expose real self
                    vm._self = vm, function(vm) {
                        var options = vm.$options, parent = options.parent;
                        // locate first non-abstract parent
                                                if (parent && !options.abstract) {
                            for (;parent.$options.abstract && parent.$parent; ) parent = parent.$parent;
                            parent.$children.push(vm);
                        }
                        vm.$parent = parent, vm.$root = parent ? parent.$root : vm, vm.$children = [], vm.$refs = {}, 
                        vm._watcher = null, vm._inactive = null, vm._directInactive = !1, vm._isMounted = !1, 
                        vm._isDestroyed = !1, vm._isBeingDestroyed = !1;
                    }(vm), function(vm) {
                        vm._events = Object.create(null), vm._hasHookEvent = !1;
                        // init parent attached events
                        var listeners = vm.$options._parentListeners;
                        listeners && updateComponentListeners(vm, listeners);
                    }(vm), function(vm) {
                        vm._vnode = null, // the root of the child tree
                        vm._staticTrees = null;
                        // v-once cached trees
                        var options = vm.$options, parentVnode = vm.$vnode = options._parentVnode, renderContext = parentVnode && parentVnode.context;
                        vm.$slots = resolveSlots(options._renderChildren, renderContext), vm.$scopedSlots = emptyObject, 
                        // bind the createElement fn to this instance
                        // so that we get proper render context inside it.
                        // args order: tag, data, children, normalizationType, alwaysNormalize
                        // internal version is used by render functions compiled from templates
                        vm._c = function(a, b, c, d) {
                            return createElement(vm, a, b, c, d, !1);
                        }, 
                        // normalization is always applied for the public version, used in
                        // user-written render functions.
                        vm.$createElement = function(a, b, c, d) {
                            return createElement(vm, a, b, c, d, !0);
                        };
                        // $attrs & $listeners are exposed for easier HOC creation.
                        // they need to be reactive so that HOCs using them are always updated
                        var parentData = parentVnode && parentVnode.data;
                        /* istanbul ignore else */                        "production" !== process.env.NODE_ENV ? (defineReactive(vm, "$attrs", parentData && parentData.attrs || emptyObject, function() {
                            !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
                        }, !0), defineReactive(vm, "$listeners", options._parentListeners || emptyObject, function() {
                            !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
                        }, !0)) : (defineReactive(vm, "$attrs", parentData && parentData.attrs || emptyObject, null, !0), 
                        defineReactive(vm, "$listeners", options._parentListeners || emptyObject, null, !0));
                    }(vm), callHook(vm, "beforeCreate"), function(vm) {
                        var result = resolveInject(vm.$options.inject, vm);
                        result && (toggleObserving(!1), Object.keys(result).forEach(function(key) {
                            /* istanbul ignore else */
                            "production" !== process.env.NODE_ENV ? defineReactive(vm, key, result[key], function() {
                                warn('Avoid mutating an injected value directly since the changes will be overwritten whenever the provided component re-renders. injection being mutated: "' + key + '"', vm);
                            }) : defineReactive(vm, key, result[key]);
                        }), toggleObserving(!0));
                    }(vm), // resolve injections before data/props
                    initState(vm), 
                    /*  */
                    function(vm) {
                        var provide = vm.$options.provide;
                        provide && (vm._provided = "function" == typeof provide ? provide.call(vm) : provide);
                    }(vm), // resolve provide after data/props
                    callHook(vm, "created"), 
                    /* istanbul ignore if */
                    "production" !== process.env.NODE_ENV && config.performance && mark && (vm._name = formatComponentName(vm, !1), 
                    mark(endTag), measure("vue " + vm._name + " init", startTag, endTag)), vm.$options.el && vm.$mount(vm.$options.el);
                };
            }(Vue), function(Vue) {
                // flow somehow has problems with directly declared definition object
                // when using Object.defineProperty, so we have to procedurally build up
                // the object here.
                var dataDef = {
                    get: function() {
                        return this._data;
                    }
                }, propsDef = {
                    get: function() {
                        return this._props;
                    }
                };
                "production" !== process.env.NODE_ENV && (dataDef.set = function(newData) {
                    warn("Avoid replacing instance root $data. Use nested data properties instead.", this);
                }, propsDef.set = function() {
                    warn("$props is readonly.", this);
                }), Object.defineProperty(Vue.prototype, "$data", dataDef), Object.defineProperty(Vue.prototype, "$props", propsDef), 
                Vue.prototype.$set = set, Vue.prototype.$delete = del, Vue.prototype.$watch = function(expOrFn, cb, options) {
                    if (isPlainObject(cb)) return createWatcher(this, expOrFn, cb, options);
                    (options = options || {}).user = !0;
                    var watcher = new Watcher(this, expOrFn, cb, options);
                    return options.immediate && cb.call(this, watcher.value), function() {
                        watcher.teardown();
                    };
                };
            }(Vue), function(Vue) {
                var hookRE = /^hook:/;
                Vue.prototype.$on = function(event, fn) {
                    if (Array.isArray(event)) for (var i = 0, l = event.length; i < l; i++) this.$on(event[i], fn); else (this._events[event] || (this._events[event] = [])).push(fn), 
                    // optimize hook:event cost by using a boolean flag marked at registration
                    // instead of a hash lookup
                    hookRE.test(event) && (this._hasHookEvent = !0);
                    return this;
                }, Vue.prototype.$once = function(event, fn) {
                    var vm = this;
                    function on() {
                        vm.$off(event, on), fn.apply(vm, arguments);
                    }
                    return on.fn = fn, vm.$on(event, on), vm;
                }, Vue.prototype.$off = function(event, fn) {
                    var vm = this;
                    // all
                    if (!arguments.length) return vm._events = Object.create(null), vm;
                    // array of events
                                        if (Array.isArray(event)) {
                        for (var i = 0, l = event.length; i < l; i++) this.$off(event[i], fn);
                        return vm;
                    }
                    // specific event
                                        var cbs = vm._events[event];
                    if (!cbs) return vm;
                    if (!fn) return vm._events[event] = null, vm;
                    if (fn) for (
                    // specific handler
                    var cb, i$1 = cbs.length; i$1--; ) if ((cb = cbs[i$1]) === fn || cb.fn === fn) {
                        cbs.splice(i$1, 1);
                        break;
                    }
                    return vm;
                }, Vue.prototype.$emit = function(event) {
                    var vm = this;
                    if ("production" !== process.env.NODE_ENV) {
                        var lowerCaseEvent = event.toLowerCase();
                        lowerCaseEvent !== event && vm._events[lowerCaseEvent] && tip('Event "' + lowerCaseEvent + '" is emitted in component ' + formatComponentName(vm) + ' but the handler is registered for "' + event + '". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "' + hyphenate(event) + '" instead of "' + event + '".');
                    }
                    var cbs = vm._events[event];
                    if (cbs) {
                        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
                        for (var args = toArray(arguments, 1), i = 0, l = cbs.length; i < l; i++) try {
                            cbs[i].apply(vm, args);
                        } catch (e) {
                            handleError(e, vm, 'event handler for "' + event + '"');
                        }
                    }
                    return vm;
                };
            }(Vue), function(Vue) {
                Vue.prototype._update = function(vnode, hydrating) {
                    var vm = this;
                    vm._isMounted && callHook(vm, "beforeUpdate");
                    var prevEl = vm.$el, prevVnode = vm._vnode, prevActiveInstance = activeInstance;
                    activeInstance = vm, vm._vnode = vnode, 
                    // Vue.prototype.__patch__ is injected in entry points
                    // based on the rendering backend used.
                    prevVnode ? 
                    // updates
                    vm.$el = vm.__patch__(prevVnode, vnode) : (
                    // initial render
                    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, !1 /* removeOnly */ , vm.$options._parentElm, vm.$options._refElm), 
                    // no need for the ref nodes after initial patch
                    // this prevents keeping a detached DOM tree in memory (#5851)
                    vm.$options._parentElm = vm.$options._refElm = null), activeInstance = prevActiveInstance, 
                    // update __vue__ reference
                    prevEl && (prevEl.__vue__ = null), vm.$el && (vm.$el.__vue__ = vm), 
                    // if parent is an HOC, update its $el as well
                    vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode && (vm.$parent.$el = vm.$el);
                }, Vue.prototype.$forceUpdate = function() {
                    this._watcher && this._watcher.update();
                }, Vue.prototype.$destroy = function() {
                    var vm = this;
                    if (!vm._isBeingDestroyed) {
                        callHook(vm, "beforeDestroy"), vm._isBeingDestroyed = !0;
                        // remove self from parent
                        var parent = vm.$parent;
                        !parent || parent._isBeingDestroyed || vm.$options.abstract || remove(parent.$children, vm), 
                        // teardown watchers
                        vm._watcher && vm._watcher.teardown();
                        for (var i = vm._watchers.length; i--; ) vm._watchers[i].teardown();
                        // remove reference from data ob
                        // frozen object may not have observer.
                                                vm._data.__ob__ && vm._data.__ob__.vmCount--, 
                        // call the last hook...
                        vm._isDestroyed = !0, 
                        // invoke destroy hooks on current rendered tree
                        vm.__patch__(vm._vnode, null), 
                        // fire destroyed hook
                        callHook(vm, "destroyed"), 
                        // turn off all instance listeners.
                        vm.$off(), 
                        // remove __vue__ reference
                        vm.$el && (vm.$el.__vue__ = null), 
                        // release circular reference (#6759)
                        vm.$vnode && (vm.$vnode.parent = null);
                    }
                };
            }(Vue), function(Vue) {
                // install runtime convenience helpers
                installRenderHelpers(Vue.prototype), Vue.prototype.$nextTick = function(fn) {
                    return nextTick(fn, this);
                }, Vue.prototype._render = function() {
                    var vnode, vm = this, ref = vm.$options, render = ref.render, _parentVnode = ref._parentVnode;
                    // reset _rendered flag on slots for duplicate slot check
                    if ("production" !== process.env.NODE_ENV) for (var key in vm.$slots) 
                    // $flow-disable-line
                    vm.$slots[key]._rendered = !1;
                    _parentVnode && (vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject), 
                    // set parent vnode. this allows render functions to have access
                    // to the data on the placeholder node.
                    vm.$vnode = _parentVnode;
                    try {
                        vnode = render.call(vm._renderProxy, vm.$createElement);
                    } catch (e) {
                        // return error render result,
                        // or previous vnode to prevent render error causing blank component
                        /* istanbul ignore else */
                        if (handleError(e, vm, "render"), "production" !== process.env.NODE_ENV) if (vm.$options.renderError) try {
                            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
                        } catch (e) {
                            handleError(e, vm, "renderError"), vnode = vm._vnode;
                        } else vnode = vm._vnode; else vnode = vm._vnode;
                    }
                    // return empty vnode in case the render function errored out
                                        return vnode instanceof VNode || ("production" !== process.env.NODE_ENV && Array.isArray(vnode) && warn("Multiple root nodes returned from render function. Render function should return a single root node.", vm), 
                    vnode = createEmptyVNode()), 
                    // set parent
                    vnode.parent = _parentVnode, vnode;
                };
            }(Vue);
            var patternTypes = [ String, RegExp, Array ], builtInComponents = {
                KeepAlive: {
                    name: "keep-alive",
                    abstract: !0,
                    props: {
                        include: patternTypes,
                        exclude: patternTypes,
                        max: [ String, Number ]
                    },
                    created: function() {
                        this.cache = Object.create(null), this.keys = [];
                    },
                    destroyed: function() {
                        for (var key in this.cache) pruneCacheEntry(this.cache, key, this.keys);
                    },
                    mounted: function() {
                        var this$1 = this;
                        this.$watch("include", function(val) {
                            pruneCache(this$1, function(name) {
                                return matches(val, name);
                            });
                        }), this.$watch("exclude", function(val) {
                            pruneCache(this$1, function(name) {
                                return !matches(val, name);
                            });
                        });
                    },
                    render: function() {
                        var slot = this.$slots.default, vnode = getFirstComponentChild(slot), componentOptions = vnode && vnode.componentOptions;
                        if (componentOptions) {
                            // check pattern
                            var name = getComponentName(componentOptions), include = this.include, exclude = this.exclude;
                            if (
                            // not included
                            include && (!name || !matches(include, name)) || 
                            // excluded
                            exclude && name && matches(exclude, name)) return vnode;
                            var cache = this.cache, keys = this.keys, key = null == vnode.key ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : "") : vnode.key;
                            cache[key] ? (vnode.componentInstance = cache[key].componentInstance, 
                            // make current key freshest
                            remove(keys, key), keys.push(key)) : (cache[key] = vnode, keys.push(key), 
                            // prune oldest entry
                            this.max && keys.length > parseInt(this.max) && pruneCacheEntry(cache, keys[0], keys, this._vnode)), 
                            vnode.data.keepAlive = !0;
                        }
                        return vnode || slot && slot[0];
                    }
                }
            }
            /*  */;
            !function(Vue) {
                // config
                var configDef = {
                    get: function() {
                        return config;
                    }
                };
                "production" !== process.env.NODE_ENV && (configDef.set = function() {
                    warn("Do not replace the Vue.config object, set individual fields instead.");
                }), Object.defineProperty(Vue, "config", configDef), 
                // exposed util methods.
                // NOTE: these are not considered part of the public API - avoid relying on
                // them unless you are aware of the risk.
                Vue.util = {
                    warn: warn,
                    extend: extend,
                    mergeOptions: mergeOptions,
                    defineReactive: defineReactive
                }, Vue.set = set, Vue.delete = del, Vue.nextTick = nextTick, Vue.options = Object.create(null), 
                ASSET_TYPES.forEach(function(type) {
                    Vue.options[type + "s"] = Object.create(null);
                }), 
                // this is used to identify the "base" constructor to extend all plain-object
                // components with in Weex's multi-instance scenarios.
                Vue.options._base = Vue, extend(Vue.options.components, builtInComponents), 
                /*  */
                function(Vue) {
                    Vue.use = function(plugin) {
                        var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
                        if (installedPlugins.indexOf(plugin) > -1) return this;
                        // additional parameters
                                                var args = toArray(arguments, 1);
                        return args.unshift(this), "function" == typeof plugin.install ? plugin.install.apply(plugin, args) : "function" == typeof plugin && plugin.apply(null, args), 
                        installedPlugins.push(plugin), this;
                    };
                }
                /*  */ (Vue), function(Vue) {
                    Vue.mixin = function(mixin) {
                        return this.options = mergeOptions(this.options, mixin), this;
                    };
                }(Vue), initExtend(Vue), function(Vue) {
                    /**
   * Create asset registration methods.
   */
                    ASSET_TYPES.forEach(function(type) {
                        Vue[type] = function(id, definition) {
                            return definition ? (
                            /* istanbul ignore if */
                            "production" !== process.env.NODE_ENV && "component" === type && validateComponentName(id), 
                            "component" === type && isPlainObject(definition) && (definition.name = definition.name || id, 
                            definition = this.options._base.extend(definition)), "directive" === type && "function" == typeof definition && (definition = {
                                bind: definition,
                                update: definition
                            }), this.options[type + "s"][id] = definition, definition) : this.options[type + "s"][id];
                        };
                    });
                }(Vue);
            }(Vue), Object.defineProperty(Vue.prototype, "$isServer", {
                get: isServerRendering
            }), Object.defineProperty(Vue.prototype, "$ssrContext", {
                get: function() {
                    /* istanbul ignore next */
                    return this.$vnode && this.$vnode.ssrContext;
                }
            }), 
            // expose FunctionalRenderContext for ssr runtime helper installation
            Object.defineProperty(Vue, "FunctionalRenderContext", {
                value: FunctionalRenderContext
            }), Vue.version = "2.5.16";
            /*  */
            // these are reserved for web because they are directly compiled away
            // during template compilation
            var isReservedAttr = makeMap("style,class"), acceptValue = makeMap("input,textarea,option,select,progress"), isEnumeratedAttr = makeMap("contenteditable,draggable,spellcheck"), isBooleanAttr = makeMap("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"), xlinkNS = "http://www.w3.org/1999/xlink", isXlink = function(name) {
                return ":" === name.charAt(5) && "xlink" === name.slice(0, 5);
            }, getXlinkProp = function(name) {
                return isXlink(name) ? name.slice(6, name.length) : "";
            }, isFalsyAttrValue = function(val) {
                return null == val || !1 === val;
            };
            // attributes that should be using props for binding
                        /*  */
            function genClassForVnode(vnode) {
                for (var data = vnode.data, parentNode = vnode, childNode = vnode; isDef(childNode.componentInstance); ) (childNode = childNode.componentInstance._vnode) && childNode.data && (data = mergeClassData(childNode.data, data));
                for (;isDef(parentNode = parentNode.parent); ) parentNode && parentNode.data && (data = mergeClassData(data, parentNode.data));
                return function(staticClass, dynamicClass) {
                    if (isDef(staticClass) || isDef(dynamicClass)) return concat(staticClass, stringifyClass(dynamicClass));
                    /* istanbul ignore next */                    return "";
                }(data.staticClass, data.class);
            }
            function mergeClassData(child, parent) {
                return {
                    staticClass: concat(child.staticClass, parent.staticClass),
                    class: isDef(child.class) ? [ child.class, parent.class ] : parent.class
                };
            }
            function concat(a, b) {
                return a ? b ? a + " " + b : a : b || "";
            }
            function stringifyClass(value) {
                return Array.isArray(value) ? function(value) {
                    for (var stringified, res = "", i = 0, l = value.length; i < l; i++) isDef(stringified = stringifyClass(value[i])) && "" !== stringified && (res && (res += " "), 
                    res += stringified);
                    return res;
                }(value) : isObject(value) ? function(value) {
                    var res = "";
                    for (var key in value) value[key] && (res && (res += " "), res += key);
                    return res;
                }
                /*  */ (value) : "string" == typeof value ? value : ""
                /* istanbul ignore next */;
            }
            var namespaceMap = {
                svg: "http://www.w3.org/2000/svg",
                math: "http://www.w3.org/1998/Math/MathML"
            }, isHTMLTag = makeMap("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"), isSVG = makeMap("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0), isReservedTag = function(tag) {
                return isHTMLTag(tag) || isSVG(tag);
            };
            var unknownElementCache = Object.create(null);
            var isTextInputType = makeMap("text,number,password,search,email,tel,url");
            /*  */
            /**
 * Query an element selector if it's not an element already.
 */            var nodeOps = Object.freeze({
                createElement: 
                /*  */
                function(tagName, vnode) {
                    var elm = document.createElement(tagName);
                    return "select" !== tagName ? elm : (
                    // false or null will remove the attribute but undefined will not
                    vnode.data && vnode.data.attrs && void 0 !== vnode.data.attrs.multiple && elm.setAttribute("multiple", "multiple"), 
                    elm);
                },
                createElementNS: function(namespace, tagName) {
                    return document.createElementNS(namespaceMap[namespace], tagName);
                },
                createTextNode: function(text) {
                    return document.createTextNode(text);
                },
                createComment: function(text) {
                    return document.createComment(text);
                },
                insertBefore: function(parentNode, newNode, referenceNode) {
                    parentNode.insertBefore(newNode, referenceNode);
                },
                removeChild: function(node, child) {
                    node.removeChild(child);
                },
                appendChild: function(node, child) {
                    node.appendChild(child);
                },
                parentNode: function(node) {
                    return node.parentNode;
                },
                nextSibling: function(node) {
                    return node.nextSibling;
                },
                tagName: function(node) {
                    return node.tagName;
                },
                setTextContent: function(node, text) {
                    node.textContent = text;
                },
                setStyleScope: function(node, scopeId) {
                    node.setAttribute(scopeId, "");
                }
            }), ref = {
                create: function(_, vnode) {
                    registerRef(vnode);
                },
                update: function(oldVnode, vnode) {
                    oldVnode.data.ref !== vnode.data.ref && (registerRef(oldVnode, !0), registerRef(vnode));
                },
                destroy: function(vnode) {
                    registerRef(vnode, !0);
                }
            };
            /*  */            function registerRef(vnode, isRemoval) {
                var key = vnode.data.ref;
                if (isDef(key)) {
                    var vm = vnode.context, ref = vnode.componentInstance || vnode.elm, refs = vm.$refs;
                    isRemoval ? Array.isArray(refs[key]) ? remove(refs[key], ref) : refs[key] === ref && (refs[key] = void 0) : vnode.data.refInFor ? Array.isArray(refs[key]) ? refs[key].indexOf(ref) < 0 && 
                    // $flow-disable-line
                    refs[key].push(ref) : refs[key] = [ ref ] : refs[key] = ref;
                }
            }
            /**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */            var emptyNode = new VNode("", {}, []), hooks = [ "create", "activate", "update", "remove", "destroy" ];
            function sameVnode(a, b) {
                return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && function(a, b) {
                    if ("input" !== a.tag) return !0;
                    var i, typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type, typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
                    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
                }(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
            }
            function createKeyToOldIdx(children, beginIdx, endIdx) {
                var i, key, map = {};
                for (i = beginIdx; i <= endIdx; ++i) isDef(key = children[i].key) && (map[key] = i);
                return map;
            }
            /*  */
            var directives = {
                create: updateDirectives,
                update: updateDirectives,
                destroy: function(vnode) {
                    updateDirectives(vnode, emptyNode);
                }
            };
            function updateDirectives(oldVnode, vnode) {
                (oldVnode.data.directives || vnode.data.directives) && function(oldVnode, vnode) {
                    var key, oldDir, dir, isCreate = oldVnode === emptyNode, isDestroy = vnode === emptyNode, oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context), newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context), dirsWithInsert = [], dirsWithPostpatch = [];
                    for (key in newDirs) oldDir = oldDirs[key], dir = newDirs[key], oldDir ? (
                    // existing directive, update
                    dir.oldValue = oldDir.value, callHook$1(dir, "update", vnode, oldVnode), dir.def && dir.def.componentUpdated && dirsWithPostpatch.push(dir)) : (
                    // new directive, bind
                    callHook$1(dir, "bind", vnode, oldVnode), dir.def && dir.def.inserted && dirsWithInsert.push(dir));
                    if (dirsWithInsert.length) {
                        var callInsert = function() {
                            for (var i = 0; i < dirsWithInsert.length; i++) callHook$1(dirsWithInsert[i], "inserted", vnode, oldVnode);
                        };
                        isCreate ? mergeVNodeHook(vnode, "insert", callInsert) : callInsert();
                    }
                    dirsWithPostpatch.length && mergeVNodeHook(vnode, "postpatch", function() {
                        for (var i = 0; i < dirsWithPostpatch.length; i++) callHook$1(dirsWithPostpatch[i], "componentUpdated", vnode, oldVnode);
                    });
                    if (!isCreate) for (key in oldDirs) newDirs[key] || 
                    // no longer present, unbind
                    callHook$1(oldDirs[key], "unbind", oldVnode, oldVnode, isDestroy);
                }(oldVnode, vnode);
            }
            var emptyModifiers = Object.create(null);
            function normalizeDirectives$1(dirs, vm) {
                var i, dir, res = Object.create(null);
                if (!dirs) 
                // $flow-disable-line
                return res;
                for (i = 0; i < dirs.length; i++) (dir = dirs[i]).modifiers || (
                // $flow-disable-line
                dir.modifiers = emptyModifiers), res[getRawDirName(dir)] = dir, dir.def = resolveAsset(vm.$options, "directives", dir.name, !0);
                // $flow-disable-line
                                return res;
            }
            function getRawDirName(dir) {
                return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join(".");
            }
            function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
                var fn = dir.def && dir.def[hook];
                if (fn) try {
                    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
                } catch (e) {
                    handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
                }
            }
            var baseModules = [ ref, directives ]
            /*  */;
            function updateAttrs(oldVnode, vnode) {
                var opts = vnode.componentOptions;
                if (!(isDef(opts) && !1 === opts.Ctor.options.inheritAttrs || isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs))) {
                    var key, cur, elm = vnode.elm, oldAttrs = oldVnode.data.attrs || {}, attrs = vnode.data.attrs || {};
                    for (key in 
                    // clone observed objects, as the user probably wants to mutate it
                    isDef(attrs.__ob__) && (attrs = vnode.data.attrs = extend({}, attrs)), attrs) cur = attrs[key], 
                    oldAttrs[key] !== cur && setAttr(elm, key, cur);
                    // #4391: in IE9, setting type can reset value for input[type=radio]
                    // #6666: IE/Edge forces progress value down to 1 before setting a max
                    /* istanbul ignore if */                    for (key in (isIE || isEdge) && attrs.value !== oldAttrs.value && setAttr(elm, "value", attrs.value), 
                    oldAttrs) isUndef(attrs[key]) && (isXlink(key) ? elm.removeAttributeNS(xlinkNS, getXlinkProp(key)) : isEnumeratedAttr(key) || elm.removeAttribute(key));
                }
            }
            function setAttr(el, key, value) {
                el.tagName.indexOf("-") > -1 ? baseSetAttr(el, key, value) : isBooleanAttr(key) ? 
                // set attribute for blank value
                // e.g. <option disabled>Select one</option>
                isFalsyAttrValue(value) ? el.removeAttribute(key) : (
                // technically allowfullscreen is a boolean attribute for <iframe>,
                // but Flash expects a value of "true" when used on <embed> tag
                value = "allowfullscreen" === key && "EMBED" === el.tagName ? "true" : key, el.setAttribute(key, value)) : isEnumeratedAttr(key) ? el.setAttribute(key, isFalsyAttrValue(value) || "false" === value ? "false" : "true") : isXlink(key) ? isFalsyAttrValue(value) ? el.removeAttributeNS(xlinkNS, getXlinkProp(key)) : el.setAttributeNS(xlinkNS, key, value) : baseSetAttr(el, key, value);
            }
            function baseSetAttr(el, key, value) {
                if (isFalsyAttrValue(value)) el.removeAttribute(key); else {
                    // #7138: IE10 & 11 fires input event when setting placeholder on
                    // <textarea>... block the first input event and remove the blocker
                    // immediately.
                    /* istanbul ignore if */
                    if (isIE && !isIE9 && "TEXTAREA" === el.tagName && "placeholder" === key && !el.__ieph) {
                        var blocker = function(e) {
                            e.stopImmediatePropagation(), el.removeEventListener("input", blocker);
                        };
                        el.addEventListener("input", blocker), 
                        // $flow-disable-line
                        el.__ieph = !0;
                    }
                    el.setAttribute(key, value);
                }
            }
            var attrs = {
                create: updateAttrs,
                update: updateAttrs
            }
            /*  */;
            function updateClass(oldVnode, vnode) {
                var el = vnode.elm, data = vnode.data, oldData = oldVnode.data;
                if (!(isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class)))) {
                    var cls = genClassForVnode(vnode), transitionClass = el._transitionClasses;
                    // handle transition classes
                                        isDef(transitionClass) && (cls = concat(cls, stringifyClass(transitionClass))), 
                    // set the class
                    cls !== el._prevClass && (el.setAttribute("class", cls), el._prevClass = cls);
                }
            }
            var target$1, klass = {
                create: updateClass,
                update: updateClass
            }, RANGE_TOKEN = "__r", CHECKBOX_RADIO_TOKEN = "__c";
            /*  */
            /*  */
            // add a raw attr (use this in preTransforms)
            // note: this only removes the attr from the Array (attrsList) so that it
            // doesn't get processed by processAttrs.
            // By default it does NOT remove it from the map (attrsMap) because the map is
            // needed during codegen.
            /*  */
            /**
 * Cross-platform code generation for component v-model
 */
            /**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
            /*  */
            // in some cases, the event used has to be determined at runtime
            // so we used some reserved tokens during compile.
                        function add$1(event, handler, once$$1, capture, passive) {
                var fn;
                handler = (fn = handler)._withTask || (fn._withTask = function() {
                    useMacroTask = !0;
                    var res = fn.apply(null, arguments);
                    return useMacroTask = !1, res;
                }), once$$1 && (handler = function(handler, event, capture) {
                    var _target = target$1;
 // save current target element in closure
                                        return function onceHandler() {
                        null !== handler.apply(null, arguments) && remove$2(event, onceHandler, capture, _target);
                    };
                }(handler, event, capture)), target$1.addEventListener(event, handler, supportsPassive ? {
                    capture: capture,
                    passive: passive
                } : capture);
            }
            function remove$2(event, handler, capture, _target) {
                (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);
            }
            function updateDOMListeners(oldVnode, vnode) {
                if (!isUndef(oldVnode.data.on) || !isUndef(vnode.data.on)) {
                    var on = vnode.data.on || {}, oldOn = oldVnode.data.on || {};
                    target$1 = vnode.elm, 
                    /*  */
                    // normalize v-model event tokens that can only be determined at runtime.
                    // it's important to place the event as the first in the array because
                    // the whole point is ensuring the v-model callback gets called before
                    // user-attached handlers.
                    function(on) {
                        /* istanbul ignore if */
                        if (isDef(on[RANGE_TOKEN])) {
                            // IE input[type=range] only supports `change` event
                            var event = isIE ? "change" : "input";
                            on[event] = [].concat(on[RANGE_TOKEN], on[event] || []), delete on[RANGE_TOKEN];
                        }
                        // This was originally intended to fix #4521 but no longer necessary
                        // after 2.5. Keeping it for backwards compat with generated code from < 2.4
                        /* istanbul ignore if */                        isDef(on[CHECKBOX_RADIO_TOKEN]) && (on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []), 
                        delete on[CHECKBOX_RADIO_TOKEN]);
                    }(on), updateListeners(on, oldOn, add$1, remove$2, vnode.context), target$1 = void 0;
                }
            }
            var events = {
                create: updateDOMListeners,
                update: updateDOMListeners
            }
            /*  */;
            function updateDOMProps(oldVnode, vnode) {
                if (!isUndef(oldVnode.data.domProps) || !isUndef(vnode.data.domProps)) {
                    var key, cur, elm = vnode.elm, oldProps = oldVnode.data.domProps || {}, props = vnode.data.domProps || {};
                    for (key in 
                    // clone observed objects, as the user probably wants to mutate it
                    isDef(props.__ob__) && (props = vnode.data.domProps = extend({}, props)), oldProps) isUndef(props[key]) && (elm[key] = "");
                    for (key in props) {
                        // ignore children if the node has textContent or innerHTML,
                        // as these will throw away existing DOM nodes and cause removal errors
                        // on subsequent patches (#3360)
                        if (cur = props[key], "textContent" === key || "innerHTML" === key) {
                            if (vnode.children && (vnode.children.length = 0), cur === oldProps[key]) continue;
                            // #6601 work around Chrome version <= 55 bug where single textNode
                            // replaced by innerHTML/textContent retains its parentNode property
                                                        1 === elm.childNodes.length && elm.removeChild(elm.childNodes[0]);
                        }
                        if ("value" === key) {
                            // store value as _value as well since
                            // non-string values will be stringified
                            elm._value = cur;
                            // avoid resetting cursor position when value is the same
                            var strCur = isUndef(cur) ? "" : String(cur);
                            shouldUpdateValue(elm, strCur) && (elm.value = strCur);
                        } else elm[key] = cur;
                    }
                }
            }
            // check platforms/web/util/attrs.js acceptValue
                        function shouldUpdateValue(elm, checkVal) {
                return !elm.composing && ("OPTION" === elm.tagName || function(elm, checkVal) {
                    // return true when textbox (.number and .trim) loses focus and its value is
                    // not equal to the updated value
                    var notInFocus = !0;
                    // #6157
                    // work around IE bug when accessing document.activeElement in an iframe
                                        try {
                        notInFocus = document.activeElement !== elm;
                    } catch (e) {}
                    return notInFocus && elm.value !== checkVal;
                }(elm, checkVal) || function(elm, newVal) {
                    var value = elm.value, modifiers = elm._vModifiers;
                    // injected by v-model runtime
                    if (isDef(modifiers)) {
                        if (modifiers.lazy) 
                        // inputs with lazy should only be updated when not in focus
                        return !1;
                        if (modifiers.number) return toNumber(value) !== toNumber(newVal);
                        if (modifiers.trim) return value.trim() !== newVal.trim();
                    }
                    return value !== newVal;
                }(elm, checkVal));
            }
            var domProps = {
                create: updateDOMProps,
                update: updateDOMProps
            }
            /*  */ , parseStyleText = cached(function(cssText) {
                var res = {}, propertyDelimiter = /:(.+)/;
                return cssText.split(/;(?![^(]*\))/g).forEach(function(item) {
                    if (item) {
                        var tmp = item.split(propertyDelimiter);
                        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
                    }
                }), res;
            });
            // merge static and dynamic style data on the same vnode
            function normalizeStyleData(data) {
                var style = normalizeStyleBinding(data.style);
                // static style is pre-processed into an object during compilation
                // and is always a fresh object, so it's safe to merge into it
                                return data.staticStyle ? extend(data.staticStyle, style) : style;
            }
            // normalize possible array / string values into Object
                        function normalizeStyleBinding(bindingStyle) {
                return Array.isArray(bindingStyle) ? toObject(bindingStyle) : "string" == typeof bindingStyle ? parseStyleText(bindingStyle) : bindingStyle;
            }
            /**
 * parent component style should be after child's
 * so that parent component's style could override it
 */            
            /*  */
            var emptyStyle, cssVarRE = /^--/, importantRE = /\s*!important$/, setProp = function(el, name, val) {
                /* istanbul ignore if */
                if (cssVarRE.test(name)) el.style.setProperty(name, val); else if (importantRE.test(val)) el.style.setProperty(name, val.replace(importantRE, ""), "important"); else {
                    var normalizedName = normalize(name);
                    if (Array.isArray(val)) 
                    // Support values array created by autoprefixer, e.g.
                    // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
                    // Set them one by one, and the browser will only set those it can recognize
                    for (var i = 0, len = val.length; i < len; i++) el.style[normalizedName] = val[i]; else el.style[normalizedName] = val;
                }
            }, vendorNames = [ "Webkit", "Moz", "ms" ], normalize = cached(function(prop) {
                if (emptyStyle = emptyStyle || document.createElement("div").style, "filter" !== (prop = camelize(prop)) && prop in emptyStyle) return prop;
                for (var capName = prop.charAt(0).toUpperCase() + prop.slice(1), i = 0; i < vendorNames.length; i++) {
                    var name = vendorNames[i] + capName;
                    if (name in emptyStyle) return name;
                }
            });
            function updateStyle(oldVnode, vnode) {
                var data = vnode.data, oldData = oldVnode.data;
                if (!(isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style))) {
                    var cur, name, el = vnode.elm, oldStaticStyle = oldData.staticStyle, oldStyleBinding = oldData.normalizedStyle || oldData.style || {}, oldStyle = oldStaticStyle || oldStyleBinding, style = normalizeStyleBinding(vnode.data.style) || {};
                    // store normalized style under a different key for next diff
                    // make sure to clone it if it's reactive, since the user likely wants
                    // to mutate it.
                    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
                    var newStyle = function(vnode, checkChild) {
                        var styleData, res = {};
                        if (checkChild) for (var childNode = vnode; childNode.componentInstance; ) (childNode = childNode.componentInstance._vnode) && childNode.data && (styleData = normalizeStyleData(childNode.data)) && extend(res, styleData);
                        (styleData = normalizeStyleData(vnode.data)) && extend(res, styleData);
                        for (var parentNode = vnode; parentNode = parentNode.parent; ) parentNode.data && (styleData = normalizeStyleData(parentNode.data)) && extend(res, styleData);
                        return res;
                    }(vnode, !0);
                    for (name in oldStyle) isUndef(newStyle[name]) && setProp(el, name, "");
                    for (name in newStyle) (cur = newStyle[name]) !== oldStyle[name] && 
                    // ie9 setting to null has no effect, must use empty string
                    setProp(el, name, null == cur ? "" : cur);
                }
            }
            var style = {
                create: updateStyle,
                update: updateStyle
            }
            /*  */
            /**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */;
            function addClass(el, cls) {
                /* istanbul ignore if */
                if (cls && (cls = cls.trim())) 
                /* istanbul ignore else */
                if (el.classList) cls.indexOf(" ") > -1 ? cls.split(/\s+/).forEach(function(c) {
                    return el.classList.add(c);
                }) : el.classList.add(cls); else {
                    var cur = " " + (el.getAttribute("class") || "") + " ";
                    cur.indexOf(" " + cls + " ") < 0 && el.setAttribute("class", (cur + cls).trim());
                }
            }
            /**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */            function removeClass(el, cls) {
                /* istanbul ignore if */
                if (cls && (cls = cls.trim())) 
                /* istanbul ignore else */
                if (el.classList) cls.indexOf(" ") > -1 ? cls.split(/\s+/).forEach(function(c) {
                    return el.classList.remove(c);
                }) : el.classList.remove(cls), el.classList.length || el.removeAttribute("class"); else {
                    for (var cur = " " + (el.getAttribute("class") || "") + " ", tar = " " + cls + " "; cur.indexOf(tar) >= 0; ) cur = cur.replace(tar, " ");
                    (cur = cur.trim()) ? el.setAttribute("class", cur) : el.removeAttribute("class");
                }
            }
            /*  */            function resolveTransition(def) {
                if (def) {
                    /* istanbul ignore else */
                    if ("object" == typeof def) {
                        var res = {};
                        return !1 !== def.css && extend(res, autoCssTransition(def.name || "v")), extend(res, def), 
                        res;
                    }
                    return "string" == typeof def ? autoCssTransition(def) : void 0;
                }
            }
            var autoCssTransition = cached(function(name) {
                return {
                    enterClass: name + "-enter",
                    enterToClass: name + "-enter-to",
                    enterActiveClass: name + "-enter-active",
                    leaveClass: name + "-leave",
                    leaveToClass: name + "-leave-to",
                    leaveActiveClass: name + "-leave-active"
                };
            }), hasTransition = inBrowser && !isIE9, TRANSITION = "transition", ANIMATION = "animation", transitionProp = "transition", transitionEndEvent = "transitionend", animationProp = "animation", animationEndEvent = "animationend";
            hasTransition && (
            /* istanbul ignore if */
            void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (transitionProp = "WebkitTransition", 
            transitionEndEvent = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (animationProp = "WebkitAnimation", 
            animationEndEvent = "webkitAnimationEnd"));
            // binding to window is necessary to make hot reload work in IE in strict mode
                        var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */ function(fn) {
                return fn();
            };
            function nextFrame(fn) {
                raf(function() {
                    raf(fn);
                });
            }
            function addTransitionClass(el, cls) {
                var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
                transitionClasses.indexOf(cls) < 0 && (transitionClasses.push(cls), addClass(el, cls));
            }
            function removeTransitionClass(el, cls) {
                el._transitionClasses && remove(el._transitionClasses, cls), removeClass(el, cls);
            }
            function whenTransitionEnds(el, expectedType, cb) {
                var ref = getTransitionInfo(el, expectedType), type = ref.type, timeout = ref.timeout, propCount = ref.propCount;
                if (!type) return cb();
                var event = type === TRANSITION ? transitionEndEvent : animationEndEvent, ended = 0, end = function() {
                    el.removeEventListener(event, onEnd), cb();
                }, onEnd = function(e) {
                    e.target === el && ++ended >= propCount && end();
                };
                setTimeout(function() {
                    ended < propCount && end();
                }, timeout + 1), el.addEventListener(event, onEnd);
            }
            var transformRE = /\b(transform|all)(,|$)/;
            function getTransitionInfo(el, expectedType) {
                var type, styles = window.getComputedStyle(el), transitionDelays = styles[transitionProp + "Delay"].split(", "), transitionDurations = styles[transitionProp + "Duration"].split(", "), transitionTimeout = getTimeout(transitionDelays, transitionDurations), animationDelays = styles[animationProp + "Delay"].split(", "), animationDurations = styles[animationProp + "Duration"].split(", "), animationTimeout = getTimeout(animationDelays, animationDurations), timeout = 0, propCount = 0;
                /* istanbul ignore if */
                return expectedType === TRANSITION ? transitionTimeout > 0 && (type = TRANSITION, 
                timeout = transitionTimeout, propCount = transitionDurations.length) : expectedType === ANIMATION ? animationTimeout > 0 && (type = ANIMATION, 
                timeout = animationTimeout, propCount = animationDurations.length) : propCount = (type = (timeout = Math.max(transitionTimeout, animationTimeout)) > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null) ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0, 
                {
                    type: type,
                    timeout: timeout,
                    propCount: propCount,
                    hasTransform: type === TRANSITION && transformRE.test(styles[transitionProp + "Property"])
                };
            }
            function getTimeout(delays, durations) {
                /* istanbul ignore next */
                for (;delays.length < durations.length; ) delays = delays.concat(delays);
                return Math.max.apply(null, durations.map(function(d, i) {
                    return toMs(d) + toMs(delays[i]);
                }));
            }
            function toMs(s) {
                return 1e3 * Number(s.slice(0, -1));
            }
            /*  */            function enter(vnode, toggleDisplay) {
                var el = vnode.elm;
                // call leave callback now
                                isDef(el._leaveCb) && (el._leaveCb.cancelled = !0, el._leaveCb());
                var data = resolveTransition(vnode.data.transition);
                if (!isUndef(data) && !isDef(el._enterCb) && 1 === el.nodeType) 
                /* istanbul ignore if */
                {
                    for (var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration, context = activeInstance, transitionNode = activeInstance.$vnode; transitionNode && transitionNode.parent; ) context = (transitionNode = transitionNode.parent).context;
                    var isAppear = !context._isMounted || !vnode.isRootInsert;
                    if (!isAppear || appear || "" === appear) {
                        var startClass = isAppear && appearClass ? appearClass : enterClass, activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass, toClass = isAppear && appearToClass ? appearToClass : enterToClass, beforeEnterHook = isAppear && beforeAppear || beforeEnter, enterHook = isAppear && "function" == typeof appear ? appear : enter, afterEnterHook = isAppear && afterAppear || afterEnter, enterCancelledHook = isAppear && appearCancelled || enterCancelled, explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
                        "production" !== process.env.NODE_ENV && null != explicitEnterDuration && checkDuration(explicitEnterDuration, "enter", vnode);
                        var expectsCSS = !1 !== css && !isIE9, userWantsControl = getHookArgumentsLength(enterHook), cb = el._enterCb = once(function() {
                            expectsCSS && (removeTransitionClass(el, toClass), removeTransitionClass(el, activeClass)), 
                            cb.cancelled ? (expectsCSS && removeTransitionClass(el, startClass), enterCancelledHook && enterCancelledHook(el)) : afterEnterHook && afterEnterHook(el), 
                            el._enterCb = null;
                        });
                        vnode.data.show || 
                        // remove pending leave element on enter by injecting an insert hook
                        mergeVNodeHook(vnode, "insert", function() {
                            var parent = el.parentNode, pendingNode = parent && parent._pending && parent._pending[vnode.key];
                            pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb && pendingNode.elm._leaveCb(), 
                            enterHook && enterHook(el, cb);
                        }), 
                        // start enter transition
                        beforeEnterHook && beforeEnterHook(el), expectsCSS && (addTransitionClass(el, startClass), 
                        addTransitionClass(el, activeClass), nextFrame(function() {
                            removeTransitionClass(el, startClass), cb.cancelled || (addTransitionClass(el, toClass), 
                            userWantsControl || (isValidDuration(explicitEnterDuration) ? setTimeout(cb, explicitEnterDuration) : whenTransitionEnds(el, type, cb)));
                        })), vnode.data.show && (toggleDisplay && toggleDisplay(), enterHook && enterHook(el, cb)), 
                        expectsCSS || userWantsControl || cb();
                    }
                }
            }
            function leave(vnode, rm) {
                var el = vnode.elm;
                // call enter callback now
                                isDef(el._enterCb) && (el._enterCb.cancelled = !0, el._enterCb());
                var data = resolveTransition(vnode.data.transition);
                if (isUndef(data) || 1 !== el.nodeType) return rm();
                /* istanbul ignore if */                if (!isDef(el._leaveCb)) {
                    var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration, expectsCSS = !1 !== css && !isIE9, userWantsControl = getHookArgumentsLength(leave), explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
                    "production" !== process.env.NODE_ENV && isDef(explicitLeaveDuration) && checkDuration(explicitLeaveDuration, "leave", vnode);
                    var cb = el._leaveCb = once(function() {
                        el.parentNode && el.parentNode._pending && (el.parentNode._pending[vnode.key] = null), 
                        expectsCSS && (removeTransitionClass(el, leaveToClass), removeTransitionClass(el, leaveActiveClass)), 
                        cb.cancelled ? (expectsCSS && removeTransitionClass(el, leaveClass), leaveCancelled && leaveCancelled(el)) : (rm(), 
                        afterLeave && afterLeave(el)), el._leaveCb = null;
                    });
                    delayLeave ? delayLeave(performLeave) : performLeave();
                }
                function performLeave() {
                    // the delayed leave may have already been cancelled
                    cb.cancelled || (
                    // record leaving element
                    vnode.data.show || ((el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode), 
                    beforeLeave && beforeLeave(el), expectsCSS && (addTransitionClass(el, leaveClass), 
                    addTransitionClass(el, leaveActiveClass), nextFrame(function() {
                        removeTransitionClass(el, leaveClass), cb.cancelled || (addTransitionClass(el, leaveToClass), 
                        userWantsControl || (isValidDuration(explicitLeaveDuration) ? setTimeout(cb, explicitLeaveDuration) : whenTransitionEnds(el, type, cb)));
                    })), leave && leave(el, cb), expectsCSS || userWantsControl || cb());
                }
            }
            // only used in dev mode
                        function checkDuration(val, name, vnode) {
                "number" != typeof val ? warn("<transition> explicit " + name + " duration is not a valid number - got " + JSON.stringify(val) + ".", vnode.context) : isNaN(val) && warn("<transition> explicit " + name + " duration is NaN - the duration expression might be incorrect.", vnode.context);
            }
            function isValidDuration(val) {
                return "number" == typeof val && !isNaN(val);
            }
            /**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */            function getHookArgumentsLength(fn) {
                if (isUndef(fn)) return !1;
                var invokerFns = fn.fns;
                return isDef(invokerFns) ? getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns) : (fn._length || fn.length) > 1;
            }
            function _enter(_, vnode) {
                !0 !== vnode.data.show && enter(vnode);
            }
            var patch = function(backend) {
                var i, j, cbs = {}, modules = backend.modules, nodeOps = backend.nodeOps;
                for (i = 0; i < hooks.length; ++i) for (cbs[hooks[i]] = [], j = 0; j < modules.length; ++j) isDef(modules[j][hooks[i]]) && cbs[hooks[i]].push(modules[j][hooks[i]]);
                function removeNode(el) {
                    var parent = nodeOps.parentNode(el);
                    // element may have already been removed due to v-html / v-text
                                        isDef(parent) && nodeOps.removeChild(parent, el);
                }
                function isUnknownElement$$1(vnode, inVPre) {
                    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function(ignore) {
                        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
                    })) && config.isUnknownElement(vnode.tag);
                }
                var creatingElmInVPre = 0;
                function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
                    // for transition enter check
                    if (isDef(vnode.elm) && isDef(ownerArray) && (
                    // This vnode was used in a previous render!
                    // now it's used as a new node, overwriting its elm would cause
                    // potential patch errors down the road when it's used as an insertion
                    // reference node. Instead, we clone the node on-demand before creating
                    // associated DOM element for it.
                    vnode = ownerArray[index] = cloneVNode(vnode)), vnode.isRootInsert = !nested, !function(vnode, insertedVnodeQueue, parentElm, refElm) {
                        var i = vnode.data;
                        if (isDef(i)) {
                            var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
                            // after calling the init hook, if the vnode is a child component
                            // it should've created a child instance and mounted it. the child
                            // component also has set the placeholder vnode's elm.
                            // in that case we can just return the element and be done.
                            if (isDef(i = i.hook) && isDef(i = i.init) && i(vnode, !1 /* hydrating */ , parentElm, refElm), 
                            isDef(vnode.componentInstance)) return initComponent(vnode, insertedVnodeQueue), 
                            isTrue(isReactivated) && function(vnode, insertedVnodeQueue, parentElm, refElm) {
                                for (var i, innerNode = vnode
                                // hack for #4339: a reactivated component with inner transition
                                // does not trigger because the inner node's created hooks are not called
                                // again. It's not ideal to involve module-specific logic in here but
                                // there doesn't seem to be a better way to do it.
                                ; innerNode.componentInstance; ) if (innerNode = innerNode.componentInstance._vnode, 
                                isDef(i = innerNode.data) && isDef(i = i.transition)) {
                                    for (i = 0; i < cbs.activate.length; ++i) cbs.activate[i](emptyNode, innerNode);
                                    insertedVnodeQueue.push(innerNode);
                                    break;
                                }
                                // unlike a newly created component,
                                // a reactivated keep-alive component doesn't insert itself
                                                                insert(parentElm, vnode.elm, refElm);
                            }(vnode, insertedVnodeQueue, parentElm, refElm), !0;
                        }
                    }(vnode, insertedVnodeQueue, parentElm, refElm)) {
                        var data = vnode.data, children = vnode.children, tag = vnode.tag;
                        isDef(tag) ? ("production" !== process.env.NODE_ENV && (data && data.pre && creatingElmInVPre++, 
                        isUnknownElement$$1(vnode, creatingElmInVPre) && warn("Unknown custom element: <" + tag + '> - did you register the component correctly? For recursive components, make sure to provide the "name" option.', vnode.context)), 
                        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode), 
                        setScope(vnode), createChildren(vnode, children, insertedVnodeQueue), isDef(data) && invokeCreateHooks(vnode, insertedVnodeQueue), 
                        insert(parentElm, vnode.elm, refElm), "production" !== process.env.NODE_ENV && data && data.pre && creatingElmInVPre--) : isTrue(vnode.isComment) ? (vnode.elm = nodeOps.createComment(vnode.text), 
                        insert(parentElm, vnode.elm, refElm)) : (vnode.elm = nodeOps.createTextNode(vnode.text), 
                        insert(parentElm, vnode.elm, refElm));
                    }
                }
                function initComponent(vnode, insertedVnodeQueue) {
                    isDef(vnode.data.pendingInsert) && (insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert), 
                    vnode.data.pendingInsert = null), vnode.elm = vnode.componentInstance.$el, isPatchable(vnode) ? (invokeCreateHooks(vnode, insertedVnodeQueue), 
                    setScope(vnode)) : (
                    // empty component root.
                    // skip all element-related modules except for ref (#3455)
                    registerRef(vnode), 
                    // make sure to invoke the insert hook
                    insertedVnodeQueue.push(vnode));
                }
                function insert(parent, elm, ref$$1) {
                    isDef(parent) && (isDef(ref$$1) ? ref$$1.parentNode === parent && nodeOps.insertBefore(parent, elm, ref$$1) : nodeOps.appendChild(parent, elm));
                }
                function createChildren(vnode, children, insertedVnodeQueue) {
                    if (Array.isArray(children)) {
                        "production" !== process.env.NODE_ENV && checkDuplicateKeys(children);
                        for (var i = 0; i < children.length; ++i) createElm(children[i], insertedVnodeQueue, vnode.elm, null, !0, children, i);
                    } else isPrimitive(vnode.text) && nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
                }
                function isPatchable(vnode) {
                    for (;vnode.componentInstance; ) vnode = vnode.componentInstance._vnode;
                    return isDef(vnode.tag);
                }
                function invokeCreateHooks(vnode, insertedVnodeQueue) {
                    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) cbs.create[i$1](emptyNode, vnode);
                    // Reuse variable
                    isDef(i = vnode.data.hook) && (isDef(i.create) && i.create(emptyNode, vnode), isDef(i.insert) && insertedVnodeQueue.push(vnode));
                }
                // set scope id attribute for scoped CSS.
                // this is implemented as a special case to avoid the overhead
                // of going through the normal attribute patching process.
                                function setScope(vnode) {
                    var i;
                    if (isDef(i = vnode.fnScopeId)) nodeOps.setStyleScope(vnode.elm, i); else for (var ancestor = vnode; ancestor; ) isDef(i = ancestor.context) && isDef(i = i.$options._scopeId) && nodeOps.setStyleScope(vnode.elm, i), 
                    ancestor = ancestor.parent;
                    // for slot content they should also get the scopeId from the host instance.
                                        isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId) && nodeOps.setStyleScope(vnode.elm, i);
                }
                function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
                    for (;startIdx <= endIdx; ++startIdx) createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, !1, vnodes, startIdx);
                }
                function invokeDestroyHook(vnode) {
                    var i, j, data = vnode.data;
                    if (isDef(data)) for (isDef(i = data.hook) && isDef(i = i.destroy) && i(vnode), 
                    i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);
                    if (isDef(i = vnode.children)) for (j = 0; j < vnode.children.length; ++j) invokeDestroyHook(vnode.children[j]);
                }
                function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
                    for (;startIdx <= endIdx; ++startIdx) {
                        var ch = vnodes[startIdx];
                        isDef(ch) && (isDef(ch.tag) ? (removeAndInvokeRemoveHook(ch), invokeDestroyHook(ch)) : // Text node
                        removeNode(ch.elm));
                    }
                }
                function removeAndInvokeRemoveHook(vnode, rm) {
                    if (isDef(rm) || isDef(vnode.data)) {
                        var i, listeners = cbs.remove.length + 1;
                        for (isDef(rm) ? 
                        // we have a recursively passed down rm callback
                        // increase the listeners count
                        rm.listeners += listeners : 
                        // directly removing
                        rm = function(childElm, listeners) {
                            function remove() {
                                0 == --remove.listeners && removeNode(childElm);
                            }
                            return remove.listeners = listeners, remove;
                        }(vnode.elm, listeners), 
                        // recursively invoke hooks on child component root node
                        isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data) && removeAndInvokeRemoveHook(i, rm), 
                        i = 0; i < cbs.remove.length; ++i) cbs.remove[i](vnode, rm);
                        isDef(i = vnode.data.hook) && isDef(i = i.remove) ? i(vnode, rm) : rm();
                    } else removeNode(vnode.elm);
                }
                function checkDuplicateKeys(children) {
                    for (var seenKeys = {}, i = 0; i < children.length; i++) {
                        var vnode = children[i], key = vnode.key;
                        isDef(key) && (seenKeys[key] ? warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context) : seenKeys[key] = !0);
                    }
                }
                function findIdxInOld(node, oldCh, start, end) {
                    for (var i = start; i < end; i++) {
                        var c = oldCh[i];
                        if (isDef(c) && sameVnode(node, c)) return i;
                    }
                }
                function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
                    if (oldVnode !== vnode) {
                        var elm = vnode.elm = oldVnode.elm;
                        if (isTrue(oldVnode.isAsyncPlaceholder)) isDef(vnode.asyncFactory.resolved) ? hydrate(oldVnode.elm, vnode, insertedVnodeQueue) : vnode.isAsyncPlaceholder = !0; else 
                        // reuse element for static trees.
                        // note we only do this if the vnode is cloned -
                        // if the new node is not cloned it means the render functions have been
                        // reset by the hot-reload-api and we need to do a proper re-render.
                        if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) vnode.componentInstance = oldVnode.componentInstance; else {
                            var i, data = vnode.data;
                            isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch) && i(oldVnode, vnode);
                            var oldCh = oldVnode.children, ch = vnode.children;
                            if (isDef(data) && isPatchable(vnode)) {
                                for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
                                isDef(i = data.hook) && isDef(i = i.update) && i(oldVnode, vnode);
                            }
                            isUndef(vnode.text) ? isDef(oldCh) && isDef(ch) ? oldCh !== ch && function(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
                                var oldKeyToIdx, idxInOld, vnodeToMove, oldStartIdx = 0, newStartIdx = 0, oldEndIdx = oldCh.length - 1, oldStartVnode = oldCh[0], oldEndVnode = oldCh[oldEndIdx], newEndIdx = newCh.length - 1, newStartVnode = newCh[0], newEndVnode = newCh[newEndIdx], canMove = !removeOnly;
                                for ("production" !== process.env.NODE_ENV && checkDuplicateKeys(newCh); oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx; ) isUndef(oldStartVnode) ? oldStartVnode = oldCh[++oldStartIdx] : isUndef(oldEndVnode) ? oldEndVnode = oldCh[--oldEndIdx] : sameVnode(oldStartVnode, newStartVnode) ? (patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue), 
                                oldStartVnode = oldCh[++oldStartIdx], newStartVnode = newCh[++newStartIdx]) : sameVnode(oldEndVnode, newEndVnode) ? (patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue), 
                                oldEndVnode = oldCh[--oldEndIdx], newEndVnode = newCh[--newEndIdx]) : sameVnode(oldStartVnode, newEndVnode) ? (// Vnode moved right
                                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue), canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)), 
                                oldStartVnode = oldCh[++oldStartIdx], newEndVnode = newCh[--newEndIdx]) : sameVnode(oldEndVnode, newStartVnode) ? (// Vnode moved left
                                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue), canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm), 
                                oldEndVnode = oldCh[--oldEndIdx], newStartVnode = newCh[++newStartIdx]) : (isUndef(oldKeyToIdx) && (oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)), 
                                isUndef(idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)) ? // New element
                                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, !1, newCh, newStartIdx) : sameVnode(vnodeToMove = oldCh[idxInOld], newStartVnode) ? (patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue), 
                                oldCh[idxInOld] = void 0, canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)) : 
                                // same key but different element. treat as new element
                                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, !1, newCh, newStartIdx), 
                                newStartVnode = newCh[++newStartIdx]);
                                oldStartIdx > oldEndIdx ? addVnodes(parentElm, isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) : newStartIdx > newEndIdx && removeVnodes(0, oldCh, oldStartIdx, oldEndIdx);
                            }(elm, oldCh, ch, insertedVnodeQueue, removeOnly) : isDef(ch) ? (isDef(oldVnode.text) && nodeOps.setTextContent(elm, ""), 
                            addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)) : isDef(oldCh) ? removeVnodes(0, oldCh, 0, oldCh.length - 1) : isDef(oldVnode.text) && nodeOps.setTextContent(elm, "") : oldVnode.text !== vnode.text && nodeOps.setTextContent(elm, vnode.text), 
                            isDef(data) && isDef(i = data.hook) && isDef(i = i.postpatch) && i(oldVnode, vnode);
                        }
                    }
                }
                function invokeInsertHook(vnode, queue, initial) {
                    // delay insert hooks for component root nodes, invoke them after the
                    // element is really inserted
                    if (isTrue(initial) && isDef(vnode.parent)) vnode.parent.data.pendingInsert = queue; else for (var i = 0; i < queue.length; ++i) queue[i].data.hook.insert(queue[i]);
                }
                var hydrationBailed = !1, isRenderedModule = makeMap("attrs,class,staticClass,staticStyle,key");
                // list of modules that can skip create hook during hydration because they
                // are already rendered on the client or has no need for initialization
                // Note: style is excluded because it relies on initial clone for future
                // deep updates (#7063).
                                // Note: this is a browser-only function so we can assume elms are DOM nodes.
                function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
                    var i, tag = vnode.tag, data = vnode.data, children = vnode.children;
                    if (inVPre = inVPre || data && data.pre, vnode.elm = elm, isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) return vnode.isAsyncPlaceholder = !0, 
                    !0;
                    // assert node match
                                        if ("production" !== process.env.NODE_ENV && !function(node, vnode, inVPre) {
                        return isDef(vnode.tag) ? 0 === vnode.tag.indexOf("vue-component") || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase()) : node.nodeType === (vnode.isComment ? 8 : 3);
                    }(elm, vnode, inVPre)) return !1;
                    if (isDef(data) && (isDef(i = data.hook) && isDef(i = i.init) && i(vnode, !0 /* hydrating */), 
                    isDef(i = vnode.componentInstance))) 
                    // child component. it should have hydrated its own tree.
                    return initComponent(vnode, insertedVnodeQueue), !0;
                    if (isDef(tag)) {
                        if (isDef(children)) 
                        // empty element, allow client to pick up and populate children
                        if (elm.hasChildNodes()) 
                        // v-html and domProps: innerHTML
                        if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
                            if (i !== elm.innerHTML) 
                            /* istanbul ignore if */
                            return "production" === process.env.NODE_ENV || "undefined" == typeof console || hydrationBailed || (hydrationBailed = !0, 
                            console.warn("Parent: ", elm), console.warn("server innerHTML: ", i), console.warn("client innerHTML: ", elm.innerHTML)), 
                            !1;
                        } else {
                            for (
                            // iterate and compare children lists
                            var childrenMatch = !0, childNode = elm.firstChild, i$1 = 0; i$1 < children.length; i$1++) {
                                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                                    childrenMatch = !1;
                                    break;
                                }
                                childNode = childNode.nextSibling;
                            }
                            // if childNode is not null, it means the actual childNodes list is
                            // longer than the virtual children list.
                                                        if (!childrenMatch || childNode) 
                            /* istanbul ignore if */
                            return "production" === process.env.NODE_ENV || "undefined" == typeof console || hydrationBailed || (hydrationBailed = !0, 
                            console.warn("Parent: ", elm), console.warn("Mismatching childNodes vs. VNodes: ", elm.childNodes, children)), 
                            !1;
                        } else createChildren(vnode, children, insertedVnodeQueue);
                        if (isDef(data)) {
                            var fullInvoke = !1;
                            for (var key in data) if (!isRenderedModule(key)) {
                                fullInvoke = !0, invokeCreateHooks(vnode, insertedVnodeQueue);
                                break;
                            }
                            !fullInvoke && data.class && 
                            // ensure collecting deps for deep class bindings for future updates
                            traverse(data.class);
                        }
                    } else elm.data !== vnode.text && (elm.data = vnode.text);
                    return !0;
                }
                return function(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
                    if (!isUndef(vnode)) {
                        var elm, isInitialPatch = !1, insertedVnodeQueue = [];
                        if (isUndef(oldVnode)) 
                        // empty mount (likely as component), create new root element
                        isInitialPatch = !0, createElm(vnode, insertedVnodeQueue, parentElm, refElm); else {
                            var isRealElement = isDef(oldVnode.nodeType);
                            if (!isRealElement && sameVnode(oldVnode, vnode)) 
                            // patch existing root node
                            patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly); else {
                                if (isRealElement) {
                                    if (
                                    // mounting to a real element
                                    // check if this is server-rendered content and if we can perform
                                    // a successful hydration.
                                    1 === oldVnode.nodeType && oldVnode.hasAttribute(SSR_ATTR) && (oldVnode.removeAttribute(SSR_ATTR), 
                                    hydrating = !0), isTrue(hydrating)) {
                                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) return invokeInsertHook(vnode, insertedVnodeQueue, !0), 
                                        oldVnode;
                                        "production" !== process.env.NODE_ENV && warn("The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside <p>, or missing <tbody>. Bailing hydration and performing full client-side render.");
                                    }
                                    // either not server-rendered, or hydration failed.
                                    // create an empty node and replace it
                                                                        elm = oldVnode, oldVnode = new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], void 0, elm);
                                }
                                // replacing existing element
                                                                var oldElm = oldVnode.elm, parentElm$1 = nodeOps.parentNode(oldElm);
                                // update parent placeholder node element, recursively
                                if (
                                // create new node
                                createElm(vnode, insertedVnodeQueue, 
                                // extremely rare edge case: do not insert if old element is in a
                                // leaving transition. Only happens when combining transition +
                                // keep-alive + HOCs. (#4590)
                                oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm)), isDef(vnode.parent)) for (var ancestor = vnode.parent, patchable = isPatchable(vnode); ancestor; ) {
                                    for (var i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](ancestor);
                                    if (ancestor.elm = vnode.elm, patchable) {
                                        for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) cbs.create[i$1](emptyNode, ancestor);
                                        // #6513
                                        // invoke insert hooks that may have been merged by create hooks.
                                        // e.g. for directives that uses the "inserted" hook.
                                                                                var insert = ancestor.data.hook.insert;
                                        if (insert.merged) 
                                        // start at index 1 to avoid re-invoking component mounted hook
                                        for (var i$2 = 1; i$2 < insert.fns.length; i$2++) insert.fns[i$2]();
                                    } else registerRef(ancestor);
                                    ancestor = ancestor.parent;
                                }
                                // destroy old node
                                                                isDef(parentElm$1) ? removeVnodes(0, [ oldVnode ], 0, 0) : isDef(oldVnode.tag) && invokeDestroyHook(oldVnode);
                            }
                        }
                        return invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch), vnode.elm;
                    }
                    isDef(oldVnode) && invokeDestroyHook(oldVnode);
                };
            }({
                nodeOps: nodeOps,
                modules: [ attrs, klass, events, domProps, style, inBrowser ? {
                    create: _enter,
                    activate: _enter,
                    remove: function(vnode, rm) {
                        /* istanbul ignore else */
                        !0 !== vnode.data.show ? leave(vnode, rm) : rm();
                    }
                } : {} ].concat(baseModules)
            });
            /**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */
            /* istanbul ignore if */
            isIE9 && 
            // http://www.matts411.com/post/internet-explorer-9-oninput/
            document.addEventListener("selectionchange", function() {
                var el = document.activeElement;
                el && el.vmodel && trigger(el, "input");
            });
            var directive = {
                inserted: function(el, binding, vnode, oldVnode) {
                    "select" === vnode.tag ? (
                    // #6903
                    oldVnode.elm && !oldVnode.elm._vOptions ? mergeVNodeHook(vnode, "postpatch", function() {
                        directive.componentUpdated(el, binding, vnode);
                    }) : setSelected(el, binding, vnode.context), el._vOptions = [].map.call(el.options, getValue)) : ("textarea" === vnode.tag || isTextInputType(el.type)) && (el._vModifiers = binding.modifiers, 
                    binding.modifiers.lazy || (el.addEventListener("compositionstart", onCompositionStart), 
                    el.addEventListener("compositionend", onCompositionEnd), 
                    // Safari < 10.2 & UIWebView doesn't fire compositionend when
                    // switching focus before confirming composition choice
                    // this also fixes the issue where some browsers e.g. iOS Chrome
                    // fires "change" instead of "input" on autocomplete.
                    el.addEventListener("change", onCompositionEnd), 
                    /* istanbul ignore if */
                    isIE9 && (el.vmodel = !0)));
                },
                componentUpdated: function(el, binding, vnode) {
                    if ("select" === vnode.tag) {
                        setSelected(el, binding, vnode.context);
                        // in case the options rendered by v-for have changed,
                        // it's possible that the value is out-of-sync with the rendered options.
                        // detect such cases and filter out values that no longer has a matching
                        // option in the DOM.
                        var prevOptions = el._vOptions, curOptions = el._vOptions = [].map.call(el.options, getValue);
                        if (curOptions.some(function(o, i) {
                            return !looseEqual(o, prevOptions[i]);
                        })) (el.multiple ? binding.value.some(function(v) {
                            return hasNoMatchingOption(v, curOptions);
                        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions)) && trigger(el, "change");
                    }
                }
            };
            function setSelected(el, binding, vm) {
                actuallySetSelected(el, binding, vm), 
                /* istanbul ignore if */
                (isIE || isEdge) && setTimeout(function() {
                    actuallySetSelected(el, binding, vm);
                }, 0);
            }
            function actuallySetSelected(el, binding, vm) {
                var value = binding.value, isMultiple = el.multiple;
                if (!isMultiple || Array.isArray(value)) {
                    for (var selected, option, i = 0, l = el.options.length; i < l; i++) if (option = el.options[i], 
                    isMultiple) selected = looseIndexOf(value, getValue(option)) > -1, option.selected !== selected && (option.selected = selected); else if (looseEqual(getValue(option), value)) return void (el.selectedIndex !== i && (el.selectedIndex = i));
                    isMultiple || (el.selectedIndex = -1);
                } else "production" !== process.env.NODE_ENV && warn('<select multiple v-model="' + binding.expression + '"> expects an Array value for its binding, but got ' + Object.prototype.toString.call(value).slice(8, -1), vm);
            }
            function hasNoMatchingOption(value, options) {
                return options.every(function(o) {
                    return !looseEqual(o, value);
                });
            }
            function getValue(option) {
                return "_value" in option ? option._value : option.value;
            }
            function onCompositionStart(e) {
                e.target.composing = !0;
            }
            function onCompositionEnd(e) {
                // prevent triggering an input event for no reason
                e.target.composing && (e.target.composing = !1, trigger(e.target, "input"));
            }
            function trigger(el, type) {
                var e = document.createEvent("HTMLEvents");
                e.initEvent(type, !0, !0), el.dispatchEvent(e);
            }
            /*  */
            // recursively search for possible transition defined inside the component root
                        function locateNode(vnode) {
                return !vnode.componentInstance || vnode.data && vnode.data.transition ? vnode : locateNode(vnode.componentInstance._vnode);
            }
            var platformDirectives = {
                model: directive,
                show: {
                    bind: function(el, ref, vnode) {
                        var value = ref.value, transition$$1 = (vnode = locateNode(vnode)).data && vnode.data.transition, originalDisplay = el.__vOriginalDisplay = "none" === el.style.display ? "" : el.style.display;
                        value && transition$$1 ? (vnode.data.show = !0, enter(vnode, function() {
                            el.style.display = originalDisplay;
                        })) : el.style.display = value ? originalDisplay : "none";
                    },
                    update: function(el, ref, vnode) {
                        var value = ref.value;
                        /* istanbul ignore if */
                        !value != !ref.oldValue && ((vnode = locateNode(vnode)).data && vnode.data.transition ? (vnode.data.show = !0, 
                        value ? enter(vnode, function() {
                            el.style.display = el.__vOriginalDisplay;
                        }) : leave(vnode, function() {
                            el.style.display = "none";
                        })) : el.style.display = value ? el.__vOriginalDisplay : "none");
                    },
                    unbind: function(el, binding, vnode, oldVnode, isDestroy) {
                        isDestroy || (el.style.display = el.__vOriginalDisplay);
                    }
                }
            }, transitionProps = {
                name: String,
                appear: Boolean,
                css: Boolean,
                mode: String,
                type: String,
                enterClass: String,
                leaveClass: String,
                enterToClass: String,
                leaveToClass: String,
                enterActiveClass: String,
                leaveActiveClass: String,
                appearClass: String,
                appearActiveClass: String,
                appearToClass: String,
                duration: [ Number, String, Object ]
            };
            // in case the child is also an abstract component, e.g. <keep-alive>
            // we want to recursively retrieve the real component to be rendered
            function getRealChild(vnode) {
                var compOptions = vnode && vnode.componentOptions;
                return compOptions && compOptions.Ctor.options.abstract ? getRealChild(getFirstComponentChild(compOptions.children)) : vnode;
            }
            function extractTransitionData(comp) {
                var data = {}, options = comp.$options;
                // props
                for (var key in options.propsData) data[key] = comp[key];
                // events.
                // extract listeners and pass them directly to the transition methods
                                var listeners = options._parentListeners;
                for (var key$1 in listeners) data[camelize(key$1)] = listeners[key$1];
                return data;
            }
            function placeholder(h, rawChild) {
                if (/\d-keep-alive$/.test(rawChild.tag)) return h("keep-alive", {
                    props: rawChild.componentOptions.propsData
                });
            }
            var Transition = {
                name: "transition",
                props: transitionProps,
                abstract: !0,
                render: function(h) {
                    var this$1 = this, children = this.$slots.default;
                    if (children && (
                    // filter out text nodes (possible whitespaces)
                    children = children.filter(function(c) {
                        return c.tag || isAsyncPlaceholder(c);
                    })).length) 
                    /* istanbul ignore if */
                    {
                        // warn multiple elements
                        "production" !== process.env.NODE_ENV && children.length > 1 && warn("<transition> can only be used on a single element. Use <transition-group> for lists.", this.$parent);
                        var mode = this.mode;
                        // warn invalid mode
                                                "production" !== process.env.NODE_ENV && mode && "in-out" !== mode && "out-in" !== mode && warn("invalid <transition> mode: " + mode, this.$parent);
                        var rawChild = children[0];
                        // if this is a component root node and the component's
                        // parent container node also has transition, skip.
                                                if (function(vnode) {
                            for (;vnode = vnode.parent; ) if (vnode.data.transition) return !0;
                        }(this.$vnode)) return rawChild;
                        // apply transition data to child
                        // use getRealChild() to ignore abstract components e.g. keep-alive
                                                var child = getRealChild(rawChild);
                        /* istanbul ignore if */                        if (!child) return rawChild;
                        if (this._leaving) return placeholder(h, rawChild);
                        // ensure a key that is unique to the vnode type and to this transition
                        // component instance. This key will be used to remove pending leaving nodes
                        // during entering.
                                                var id = "__transition-" + this._uid + "-";
                        child.key = null == child.key ? child.isComment ? id + "comment" : id + child.tag : isPrimitive(child.key) ? 0 === String(child.key).indexOf(id) ? child.key : id + child.key : child.key;
                        var data = (child.data || (child.data = {})).transition = extractTransitionData(this), oldRawChild = this._vnode, oldChild = getRealChild(oldRawChild);
                        if (
                        // mark v-show
                        // so that the transition module can hand over the control to the directive
                        child.data.directives && child.data.directives.some(function(d) {
                            return "show" === d.name;
                        }) && (child.data.show = !0), oldChild && oldChild.data && !function(child, oldChild) {
                            return oldChild.key === child.key && oldChild.tag === child.tag;
                        }(child, oldChild) && !isAsyncPlaceholder(oldChild) && (!oldChild.componentInstance || !oldChild.componentInstance._vnode.isComment)) {
                            // replace old child transition data with fresh one
                            // important for dynamic transitions!
                            var oldData = oldChild.data.transition = extend({}, data);
                            // handle transition mode
                                                        if ("out-in" === mode) 
                            // return placeholder node and queue update when leave finishes
                            return this._leaving = !0, mergeVNodeHook(oldData, "afterLeave", function() {
                                this$1._leaving = !1, this$1.$forceUpdate();
                            }), placeholder(h, rawChild);
                            if ("in-out" === mode) {
                                if (isAsyncPlaceholder(child)) return oldRawChild;
                                var delayedLeave, performLeave = function() {
                                    delayedLeave();
                                };
                                mergeVNodeHook(data, "afterEnter", performLeave), mergeVNodeHook(data, "enterCancelled", performLeave), 
                                mergeVNodeHook(oldData, "delayLeave", function(leave) {
                                    delayedLeave = leave;
                                });
                            }
                        }
                        return rawChild;
                    }
                }
            }, props = extend({
                tag: String,
                moveClass: String
            }, transitionProps);
            /*  */
            // Provides transition support for list items.
            // supports move transitions using the FLIP technique.
            // Because the vdom's children update algorithm is "unstable" - i.e.
            // it doesn't guarantee the relative positioning of removed elements,
            // we force transition-group to update its children into two passes:
            // in the first pass, we remove all nodes that need to be removed,
            // triggering their leaving transition; in the second pass, we insert/move
            // into the final desired state. This way in the second pass removed
            // nodes will remain where they should be.
                        function callPendingCbs(c) {
                /* istanbul ignore if */
                c.elm._moveCb && c.elm._moveCb()
                /* istanbul ignore if */ , c.elm._enterCb && c.elm._enterCb();
            }
            function recordPosition(c) {
                c.data.newPos = c.elm.getBoundingClientRect();
            }
            function applyTranslation(c) {
                var oldPos = c.data.pos, newPos = c.data.newPos, dx = oldPos.left - newPos.left, dy = oldPos.top - newPos.top;
                if (dx || dy) {
                    c.data.moved = !0;
                    var s = c.elm.style;
                    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)", s.transitionDuration = "0s";
                }
            }
            delete props.mode;
            var platformComponents = {
                Transition: Transition,
                TransitionGroup: {
                    props: props,
                    render: function(h) {
                        for (var tag = this.tag || this.$vnode.data.tag || "span", map = Object.create(null), prevChildren = this.prevChildren = this.children, rawChildren = this.$slots.default || [], children = this.children = [], transitionData = extractTransitionData(this), i = 0; i < rawChildren.length; i++) {
                            var c = rawChildren[i];
                            if (c.tag) if (null != c.key && 0 !== String(c.key).indexOf("__vlist")) children.push(c), 
                            map[c.key] = c, (c.data || (c.data = {})).transition = transitionData; else if ("production" !== process.env.NODE_ENV) {
                                var opts = c.componentOptions, name = opts ? opts.Ctor.options.name || opts.tag || "" : c.tag;
                                warn("<transition-group> children must be keyed: <" + name + ">");
                            }
                        }
                        if (prevChildren) {
                            for (var kept = [], removed = [], i$1 = 0; i$1 < prevChildren.length; i$1++) {
                                var c$1 = prevChildren[i$1];
                                c$1.data.transition = transitionData, c$1.data.pos = c$1.elm.getBoundingClientRect(), 
                                map[c$1.key] ? kept.push(c$1) : removed.push(c$1);
                            }
                            this.kept = h(tag, null, kept), this.removed = removed;
                        }
                        return h(tag, null, children);
                    },
                    beforeUpdate: function() {
                        // force removing pass
                        this.__patch__(this._vnode, this.kept, !1, // hydrating
                        !0), this._vnode = this.kept;
                    },
                    updated: function() {
                        var children = this.prevChildren, moveClass = this.moveClass || (this.name || "v") + "-move";
                        children.length && this.hasMove(children[0].elm, moveClass) && (
                        // we divide the work into three loops to avoid mixing DOM reads and writes
                        // in each iteration - which helps prevent layout thrashing.
                        children.forEach(callPendingCbs), children.forEach(recordPosition), children.forEach(applyTranslation), 
                        // force reflow to put everything in position
                        // assign to this to avoid being removed in tree-shaking
                        // $flow-disable-line
                        this._reflow = document.body.offsetHeight, children.forEach(function(c) {
                            if (c.data.moved) {
                                var el = c.elm, s = el.style;
                                addTransitionClass(el, moveClass), s.transform = s.WebkitTransform = s.transitionDuration = "", 
                                el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
                                    e && !/transform$/.test(e.propertyName) || (el.removeEventListener(transitionEndEvent, cb), 
                                    el._moveCb = null, removeTransitionClass(el, moveClass));
                                });
                            }
                        }));
                    },
                    methods: {
                        hasMove: function(el, moveClass) {
                            /* istanbul ignore if */
                            if (!hasTransition) return !1;
                            /* istanbul ignore if */                            if (this._hasMove) return this._hasMove;
                            // Detect whether an element with the move class applied has
                            // CSS transitions. Since the element may be inside an entering
                            // transition at this very moment, we make a clone of it and remove
                            // all other transition classes applied to ensure only the move class
                            // is applied.
                                                        var clone = el.cloneNode();
                            el._transitionClasses && el._transitionClasses.forEach(function(cls) {
                                removeClass(clone, cls);
                            }), addClass(clone, moveClass), clone.style.display = "none", this.$el.appendChild(clone);
                            var info = getTransitionInfo(clone);
                            return this.$el.removeChild(clone), this._hasMove = info.hasTransform;
                        }
                    }
                }
            };
            /*  */
            // install platform specific utils
                        Vue.config.mustUseProp = function(tag, type, attr) {
                return "value" === attr && acceptValue(tag) && "button" !== type || "selected" === attr && "option" === tag || "checked" === attr && "input" === tag || "muted" === attr && "video" === tag;
            }, Vue.config.isReservedTag = isReservedTag, Vue.config.isReservedAttr = isReservedAttr, 
            Vue.config.getTagNamespace = function(tag) {
                return isSVG(tag) ? "svg" : 
                // basic support for MathML
                // note it doesn't support other MathML elements being component roots
                "math" === tag ? "math" : void 0;
            }, Vue.config.isUnknownElement = function(tag) {
                /* istanbul ignore if */
                if (!inBrowser) return !0;
                if (isReservedTag(tag)) return !1;
                /* istanbul ignore if */
                if (tag = tag.toLowerCase(), null != unknownElementCache[tag]) return unknownElementCache[tag];
                var el = document.createElement(tag);
                return tag.indexOf("-") > -1 ? unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement : unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
            }, 
            // install platform runtime directives & components
            extend(Vue.options.directives, platformDirectives), extend(Vue.options.components, platformComponents), 
            // install platform patch function
            Vue.prototype.__patch__ = inBrowser ? patch : noop, 
            // public mount method
            Vue.prototype.$mount = function(el, hydrating) {
                return function(vm, el, hydrating) {
                    var updateComponent;
                    /* istanbul ignore if */                    return vm.$el = el, vm.$options.render || (vm.$options.render = createEmptyVNode, 
                    "production" !== process.env.NODE_ENV && (
                    /* istanbul ignore if */
                    vm.$options.template && "#" !== vm.$options.template.charAt(0) || vm.$options.el || el ? warn("You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.", vm) : warn("Failed to mount component: template or render function not defined.", vm))), 
                    callHook(vm, "beforeMount"), updateComponent = "production" !== process.env.NODE_ENV && config.performance && mark ? function() {
                        var name = vm._name, id = vm._uid, startTag = "vue-perf-start:" + id, endTag = "vue-perf-end:" + id;
                        mark(startTag);
                        var vnode = vm._render();
                        mark(endTag), measure("vue " + name + " render", startTag, endTag), mark(startTag), 
                        vm._update(vnode, hydrating), mark(endTag), measure("vue " + name + " patch", startTag, endTag);
                    } : function() {
                        vm._update(vm._render(), hydrating);
                    }, 
                    // we set this to vm._watcher inside the watcher's constructor
                    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
                    // component's mounted hook), which relies on vm._watcher being already defined
                    new Watcher(vm, updateComponent, noop, null, !0 /* isRenderWatcher */), hydrating = !1, 
                    // manually mounted instance, call mounted on self
                    // mounted is called for render-created child components in its inserted hook
                    null == vm.$vnode && (vm._isMounted = !0, callHook(vm, "mounted")), vm;
                }(this, el = el && inBrowser ? function(el) {
                    if ("string" == typeof el) {
                        var selected = document.querySelector(el);
                        return selected || ("production" !== process.env.NODE_ENV && warn("Cannot find element: " + el), 
                        document.createElement("div"));
                    }
                    return el;
                }(el) : void 0, hydrating);
            }, 
            // devtools global hook
            /* istanbul ignore next */
            inBrowser && setTimeout(function() {
                config.devtools && (devtools ? devtools.emit("init", Vue) : "production" !== process.env.NODE_ENV && "test" !== process.env.NODE_ENV && isChrome && console[console.info ? "info" : "log"]("Download the Vue Devtools extension for a better development experience:\nhttps://github.com/vuejs/vue-devtools")), 
                "production" !== process.env.NODE_ENV && "test" !== process.env.NODE_ENV && !1 !== config.productionTip && "undefined" != typeof console && console[console.info ? "info" : "log"]("You are running Vue in development mode.\nMake sure to turn on production mode when deploying for production.\nSee more tips at https://vuejs.org/guide/deployment.html");
            }, 0)
            /*  */
            /* harmony default export */ , __webpack_exports__.a = Vue;
        }).call(__webpack_exports__, __webpack_require__(0), __webpack_require__(1), __webpack_require__(7).setImmediate)
        /***/;
    }, 
    /* 15 */
    /***/ function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function(global, process) {
            !function(global, undefined) {
                "use strict";
                if (!global.setImmediate) {
                    var registerImmediate, html, channel, messagePrefix, onGlobalMessage, nextHandle = 1, tasksByHandle = {}, currentlyRunningATask = !1, doc = global.document, attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
 // Spec says greater than zero
                                        attachTo = attachTo && attachTo.setTimeout ? attachTo : global, 
                    // Don't get fooled by e.g. browserify environments.
                    "[object process]" === {}.toString.call(global.process) ? registerImmediate = function(handle) {
                        process.nextTick(function() {
                            runIfPresent(handle);
                        });
                    } : !function() {
                        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
                        // where `global.postMessage` means something completely different and can't be used for this purpose.
                        if (global.postMessage && !global.importScripts) {
                            var postMessageIsAsynchronous = !0, oldOnMessage = global.onmessage;
                            return global.onmessage = function() {
                                postMessageIsAsynchronous = !1;
                            }, global.postMessage("", "*"), global.onmessage = oldOnMessage, postMessageIsAsynchronous;
                        }
                    }() ? global.MessageChannel ? (
                    // For web workers, where supported
                    (channel = new MessageChannel()).port1.onmessage = function(event) {
                        runIfPresent(event.data);
                    }, registerImmediate = function(handle) {
                        channel.port2.postMessage(handle);
                    }) : doc && "onreadystatechange" in doc.createElement("script") ? (
                    // For IE 68
                    html = doc.documentElement, registerImmediate = function(handle) {
                        // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                        // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                        var script = doc.createElement("script");
                        script.onreadystatechange = function() {
                            runIfPresent(handle), script.onreadystatechange = null, html.removeChild(script), 
                            script = null;
                        }, html.appendChild(script);
                    }) : registerImmediate = function(handle) {
                        setTimeout(runIfPresent, 0, handle);
                    } : (
                    // For non-IE10 modern browsers
                    messagePrefix = "setImmediate$" + Math.random() + "$", onGlobalMessage = function(event) {
                        event.source === global && "string" == typeof event.data && 0 === event.data.indexOf(messagePrefix) && runIfPresent(+event.data.slice(messagePrefix.length));
                    }, global.addEventListener ? global.addEventListener("message", onGlobalMessage, !1) : global.attachEvent("onmessage", onGlobalMessage), 
                    registerImmediate = function(handle) {
                        global.postMessage(messagePrefix + handle, "*");
                    }), attachTo.setImmediate = function(callback) {
                        // Callback can either be a function or a string
                        "function" != typeof callback && (callback = new Function("" + callback));
                        // Copy function arguments
                                                for (var args = new Array(arguments.length - 1), i = 0; i < args.length; i++) args[i] = arguments[i + 1];
                        // Store and register the task
                                                var task = {
                            callback: callback,
                            args: args
                        };
                        return tasksByHandle[nextHandle] = task, registerImmediate(nextHandle), nextHandle++;
                    }, attachTo.clearImmediate = clearImmediate;
                }
                function clearImmediate(handle) {
                    delete tasksByHandle[handle];
                }
                function runIfPresent(handle) {
                    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
                    // So if we're currently running a task, we'll need to delay this invocation.
                    if (currentlyRunningATask) 
                    // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
                    // "too much recursion" error.
                    setTimeout(runIfPresent, 0, handle); else {
                        var task = tasksByHandle[handle];
                        if (task) {
                            currentlyRunningATask = !0;
                            try {
                                !function(task) {
                                    var callback = task.callback, args = task.args;
                                    switch (args.length) {
                                      case 0:
                                        callback();
                                        break;

                                      case 1:
                                        callback(args[0]);
                                        break;

                                      case 2:
                                        callback(args[0], args[1]);
                                        break;

                                      case 3:
                                        callback(args[0], args[1], args[2]);
                                        break;

                                      default:
                                        callback.apply(undefined, args);
                                    }
                                }(task);
                            } finally {
                                clearImmediate(handle), currentlyRunningATask = !1;
                            }
                        }
                    }
                }
            }("undefined" == typeof self ? void 0 === global ? this : global : self);
            /* WEBPACK VAR INJECTION */        }).call(exports, __webpack_require__(1), __webpack_require__(0))
        /***/;
    }, 
    /* 16 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var __WEBPACK_IMPORTED_MODULE_0__getter_types__ = __webpack_require__(5);
        /* harmony default export */        __webpack_exports__.a = {
            [__WEBPACK_IMPORTED_MODULE_0__getter_types__.c]: state => resourceName => state[resourceName],
            [__WEBPACK_IMPORTED_MODULE_0__getter_types__.b]: state => resourceName => state[resourceName].isSearching,
            [__WEBPACK_IMPORTED_MODULE_0__getter_types__.d]: state => resourceName => state[resourceName].result
        };
    }, 
    /* 17 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (immutable) */        __webpack_exports__.a = 
        /**
 * Actions with injected search API mapper.
 *
 * @param {{ [resourceName: string]: Search }} searchMap mapper of each resources searchApi
 */
        function(searchMap) {
            return {
                [__WEBPACK_IMPORTED_MODULE_1__action_types__.a]({commit: commit}, {resourceName: resourceName, result: result, text: text}) {
                    commit(__WEBPACK_IMPORTED_MODULE_0__mutation_types__.d, {
                        resourceName: resourceName,
                        result: result,
                        text: text
                    });
                },
                [__WEBPACK_IMPORTED_MODULE_1__action_types__.c.INDEX_RESOURCE](_, params) {
                    const {resourceName: resourceName} = params;
                    searchMap[resourceName].indexResource(params);
                },
                [__WEBPACK_IMPORTED_MODULE_1__action_types__.c.PERFORM_SEARCH](_, {resourceName: resourceName, searchString: searchString}) {
                    searchMap[resourceName].stopSearch(resourceName), searchMap[resourceName].performSearch(resourceName, searchString);
                },
                [__WEBPACK_IMPORTED_MODULE_1__action_types__.b]({commit: commit, dispatch: dispatch}, {resourceName: resourceName, searchString: searchString}) {
                    commit(__WEBPACK_IMPORTED_MODULE_0__mutation_types__.c, {
                        resourceName: resourceName,
                        searchString: searchString
                    }), dispatch(__WEBPACK_IMPORTED_MODULE_1__action_types__.c.PERFORM_SEARCH, {
                        resourceName: resourceName,
                        searchString: searchString
                    });
                }
            };
        }
        /***/;
        /* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mutation_types__ = __webpack_require__(4), __WEBPACK_IMPORTED_MODULE_1__action_types__ = __webpack_require__(8);
        /* harmony import */    }, 
    /* 18 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* WEBPACK VAR INJECTION */        
        /* WEBPACK VAR INJECTION */ (function(process) {
            /* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(2), __WEBPACK_IMPORTED_MODULE_1__VuexSearch__ = __webpack_require__(3);
            /* harmony import */            
            /**
 * Generate actions with transformed payload for simpler api.
 *
 * @param {String} resourceName Unique resource identifier defined in the plugin.
 * @param {Object|Array} actions Object mapping from intented method name to actionType;
 *    or an array of actionTypes.
 * @return {Object}
 */
            /* harmony default export */ __webpack_exports__.a = ((resourceName, actions) => {
                const res = {}, publicApiTypes = Object.values(__WEBPACK_IMPORTED_MODULE_1__VuexSearch__.b);
                return Object(__WEBPACK_IMPORTED_MODULE_0__utils__.c)(actions).forEach(({key: key, val: val}) => {
                    if (!publicApiTypes.includes(val) && "production" !== process.env.NODE_ENV) throw new Error(`unknown actionType '${val}' is passed to mapActions`);
                    res[key] = function(...args) {
                        return this.$store.search[val](resourceName, ...args);
                    };
                }), res;
            });
        }).call(__webpack_exports__, __webpack_require__(0))
        /***/;
    }, 
    /* 19 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(2);
        /**
 * Generate getters with injected resourceName for simpler api.
 *
 * @param {String} [resourceName] Unique resource identifier defined in the plugin.
 * @param {Object|Array} actions Object mapping from intented method name to getterType;
 *    or an array of getterTypes.
 * @return {Object}
 */
        /* harmony default export */        __webpack_exports__.a = ((resourceName, getters) => {
            const res = {};
            return Object(__WEBPACK_IMPORTED_MODULE_0__utils__.c)(getters).forEach(({key: key, val: val}) => {
                res[key] = function() {
                    const namespace = Object(__WEBPACK_IMPORTED_MODULE_0__utils__.d)(this.$store.search._base);
                    return this.$store.getters[`${namespace}${val}`](resourceName);
                };
            }), res;
        });
    }
    /******/ ]);
});
//# sourceMappingURL=vuex-search.js.map